---- http://pastebin.com/wZmHBdPD
-- Hi, noliCAIKS/RPFeltz here! 2015/02/01
-- Old version of the script was leaked so now it's worthless,
-- so I can't get any money for it anymore. So I'll just share
-- the code of the latest version now.
-- The code is broken as a whole but many of the components
-- are still functional. Maybe you can make your own module
-- loader to fix it. Use the code of the modules as you please.
-- If you can get local loadstring to work, that should fix
-- everything. Good luck.
local session_id = math.floor(tick() * 10)
local local_script_template = script:Clone()
local source_value_name
local_script_template.Disabled = true
for _, child in ipairs(local_script_template:GetChildren()) do
	if child:IsA("StringValue") then
		if string.lower(child.Name) ~= "owner" then
			source_value_name = child.Name
		end
		child.Value = ""
		break
	end
end
script:ClearAllChildren()
script.Parent = nil
if not source_value_name then
	source_value_name = ...
	if source_value_name then
		local source_value = Instance.new("StringValue", local_script_template)
		source_value.Name = source_value_name
	else
		if not (NewLocalScript and NewScript) then
			print("Script builder is incompatible.")
		end
		source_value_name = "Source"
		local_script_template = nil
	end
end
local Module = {}
Module.name = "Module"
Module.source = string.format([[
local _ENV = {
	Axes = {
		new = Axes.new
	},
	BrickColor = {
		Black = BrickColor.Black,
		Blue = BrickColor.Blue,
		DarkGray = BrickColor.DarkGray,
		Gray = BrickColor.Gray,
		Green = BrickColor.Green,
		New = BrickColor.New,
		Random = BrickColor.Random,
		Red = BrickColor.Red,
		White = BrickColor.White,
		Yellow = BrickColor.Yellow,
		new = BrickColor.new,
		palette = BrickColor.palette,
		random = BrickColor.random
	},
	CFrame = {
		Angles = CFrame.Angles,
		fromAxisAngle = CFrame.fromAxisAngle,
		fromEulerAnglesXYZ = CFrame.fromEulerAnglesXYZ,
		new = CFrame.new
	},
	CellId = {
		new = CellId.new
	},
	Color3 = {
		new = Color3.new
	},
	Delay = Delay,
	Enum = Enum,
	Faces = {
		new = Faces.new
	},
	Game = Game,
	Instance = {
		Lock = Instance.Lock,
		Unlock = Instance.Unlock,
		new = Instance.new
	},
	LoadLibrary = LoadLibrary,
	LoadRobloxLibrary = LoadRobloxLibrary,
	PluginManager = PluginManager,
	Ray = {
		new = Ray.new
	},
	Region3 = {
		new = Region3.new
	},
	Region3int16 = {
		new = Region3int16.new
	},
	Spawn = Spawn,
	Stats = Stats,
	UDim = {
		new = UDim.new
	},
	UDim2 = {
		new = UDim2.new
	},
	UserSettings = UserSettings,
	Vector2 = {
		new = Vector2.new
	},
	Vector2int16 = {
		new = Vector2int16.new
	},
	Vector3 = {
		FromAxis = Vector3.FromAxis,
		FromNormalId = Vector3.FromNormalId,
		new = Vector3.new
	},
	Vector3int16 = {
		new = Vector3int16.new
	},
	Version = Version,
	Wait = Wait,
	Workspace = Workspace,
	_G = _G,
	_VERSION = _VERSION,
	assert = assert,
	collectgarbage = collectgarbage,
	coroutine = {
		create = coroutine.create,
		resume = coroutine.resume,
		running = coroutine.running,
		status = coroutine.status,
		wrap = coroutine.wrap,
		yield = coroutine.yield
	},
	crash__ = crash__,
	delay = delay,
	dofile = dofile,
	error = error,
	game = game,
	gcinfo = gcinfo,
	getfenv = getfenv,
	getmetatable = getmetatable,
	ipairs = ipairs,
	load = load,
	loadfile = loadfile,
	loadstring = loadstring,
	math = {
		abs = math.abs,
		acos = math.acos,
		asin = math.asin,
		atan = math.atan,
		atan2 = math.atan2,
		ceil = math.ceil,
		cos = math.cos,
		cosh = math.cosh,
		deg = math.deg,
		exp = math.exp,
		floor = math.floor,
		fmod = math.fmod,
		frexp = math.frexp,
		huge = math.huge,
		ldexp = math.ldexp,
		log = math.log,
		log10 = math.log10,
		max = math.max,
		min = math.min,
		modf = math.modf,
		phi = 1.618033988749895,
		pi = math.pi,
		pow = math.pow,
		rad = math.rad,
		random = math.random,
		randomseed = math.randomseed,
		sin = math.sin,
		sinh = math.sinh,
		sqrt = math.sqrt,
		tan = math.tan,
		tanh = math.tanh,
		tau = 2 * math.pi
	},
	newproxy = newproxy,
	next = next,
	pairs = pairs,
	pcall = pcall,
	print = print,
	printidentity = printidentity,
	rawequal = rawequal,
	rawget = rawget,
	rawset = rawset,
	select = select,
	setfenv = setfenv,
	setmetatable = setmetatable,
	settings = settings,
	shared = shared,
	stats = stats,
	string = {
		byte = string.byte,
		char = string.char,
		dump = string.dump,
		find = string.find,
		format = string.format,
		gfind = string.gfind,
		gmatch = string.gmatch,
		gsub = string.gsub,
		len = string.len,
		lower = string.lower,
		match = string.match,
		rep = string.rep,
		reverse = string.reverse,
		sub = string.sub,
		upper = string.upper
	},
	table = {
		concat = table.concat,
		foreach = table.foreach,
		foreachi = table.foreachi,
		getn = table.getn,
		insert = table.insert,
		maxn = table.maxn,
		remove = table.remove,
		setn = table.setn,
		sort = table.sort
	},
	tick = tick,
	time = time,
	tonumber = tonumber,
	tostring = tostring,
	type = type,
	unpack = unpack,
	version = version,
	wait = wait,
	workspace = workspace,
	xpcall = xpcall,
	ypcall = ypcall
}
_ENV.Environment = ...
_ENV.Environment._ENV = _ENV
local _RBX = getfenv()
_ENV._ENV = _ENV
_ENV._RBX = _RBX
_ENV._SessionID = %s
_ENV.Debris = Game:GetService("Debris")
_ENV.InsertService = Game:GetService("InsertService")
_ENV.Lighting = Game:GetService("Lighting")
_ENV.LogService = Game:GetService("LogService")
_ENV.Players = Game:GetService("Players")
_ENV.RunService = Game:GetService("RunService")
_ENV.ReplicatedStorage = Game:GetService("ReplicatedStorage")
_ENV.SoundService = Game:GetService("SoundService")
_ENV.StarterGui = Game:GetService("StarterGui")
_ENV.StarterPack = Game:GetService("StarterPack")
_ENV.TeleportService = Game:GetService("TeleportService")
_ENV.RbxUtility = LoadLibrary("RbxUtility")
if N_ENV then
	N_ENV(_ENV)
end
local Module = ...
Module.data = {
	listeners = {},
	modules = {}
}
Module.metatable = {}
function Module.metatable:__tostring()
	return tostring(self.name)
end
function Module.Create(name, source, ...)
	local module = Module.Store(name, source)
	Module.Initialize(module, ...)
	return module
end
function Module.Initialize(module, ...)
	local name = module.name
	local load_function, message = loadstring(module.source, name)
	if load_function then
		local success, message = ypcall(setfenv(load_function, _ENV), ...)
		if success then
			if _ENV.Logger and _ENV.Logger.printf then
				_ENV.Logger.printf("Output", "%%s: ready", tostring(name))
			end
			local listeners = Module.data.listeners
			local listener = listeners[name]
			if listener then
				listeners[name] = nil
				listener:fire()
			end
			return module
		elseif _ENV.Logger and _ENV.Logger.printf then
			_ENV.Logger.printf("Severe", "Runtime error in module '%%s': %%s", tostring(name), message)
		else
			print(string.format("runtime error in module '%%s': %%s", tostring(name), message))
		end
	elseif _ENV.Logger and _ENV.Logger.printf then
		_ENV.Logger.printf("Severe", "Syntax error in module '%%s': %%s", tostring(name), message)
	else
		print(string.format("syntax error in module '%%s': %%s", tostring(name), message))
	end
end
function Module.Load(name)
	return Module.data.modules[name]
end
function Module.Register(module)
	local name = tostring(module)
	_ENV[name] = module
	Module.data.modules[name] = module
end
function Module.Reload(name, source, ...)
	local module = Module.Load(name)
	for key in pairs(module) do
		module[key] = nil
	end
	module.name = name
	module.source = source
	Module.Initialize(module, ...)
	return module
end
function Module.Store(name, source)
	local module = {}
	module.name = name
	module.source = source
	setmetatable(module, Module.metatable)
	Module.Register(module)
	return module
end
function Module.WaitForModule(name)
	local module = Module.Load(name)
	if not module then
		local listeners = Module.data.listeners
		local listener = listeners[name]
		if not listener then
			listener = _ENV.RbxUtility.CreateSignal()
			listeners[name] = listener
		end
		listener:wait()
	end
end
]], tostring(session_id))
assert(loadstring(Module.source))(Module)
setmetatable(Module, Module.metatable)
Module.Register(Module)
Module.Create("LuaEnum", [[
LuaEnum.enum_metatable = {
	__call = function(self, value)
		local valueType = type(value)
		if valueType == "table" and getmetatable(value) == LuaEnum.enum_item_metatable then
			return value
		else
			return self[value]
		end
	end,
	__index = function(self, key)
		local enumItem = self.ItemsByName[key] or self.ItemsByValue[key]
		if enumItem == nil then
			local default = self.Default
			if default then
				Logger.printf("Warning", "%s is not a valid EnumItem, returning default (%s)", Utility.ToString(key), tostring(default))
				enumItem = default
			else
				Logger.errorf(2, "%s is not a valid EnumItem", Utility.ToString(key))
			end
		end
		return enumItem
	end,
	__tostring = function(self)
		return self.Name
	end
}
LuaEnum.enum_item_metatable = {
	__tostring = function(self)
		return self.Enum.Name .. "." .. self.Name
	end
}
LuaEnum.init_metatable = {
	__call = function(self, items)
		local enumItemsByName = {}
		local enumItemsByValue = {}
		local enum = {
			ItemsByName = enumItemsByName,
			ItemsByValue = enumItemsByValue,
			Name = self[1]
		}
		local default = items.Default
		if default ~= nil then
			items.Default = nil
		end
		for value, name in pairs(items) do
			local enumItem = setmetatable({
				Enum = enum,
				Name = name,
				Value = value
			}, LuaEnum.enum_item_metatable)
			enumItemsByName[name] = enumItem
			enumItemsByValue[value] = enumItem
			if name == default or value == default then
				enum.Default = enumItem
			end
		end
		return setmetatable(enum, LuaEnum.enum_metatable)
	end
}
function LuaEnum.new(name)
	return setmetatable({name}, LuaEnum.init_metatable)
end
]])
Module.Create("Logger", [[
Logger.entries = {0}
Logger.MessageType = LuaEnum.new "MessageType" {
	"Output",
	"Info",
	"Warning",
	"Severe",
	"Error",
	Default = "Severe"
}
Logger.MESSAGE_TYPE_SETTINGS = {
	{ -- Output
		Font = "Arial",
		TextColor3 = Color3.new(0, 0, 0)
	},
	{ -- Info
		Font = "Arial",
		TextColor3 = Color3.new(0, 0, 1)
	},
	{ -- Warning
		Font = "ArialBold",
		TextColor3 = Color3.new(1, 0.5, 0)
	},
	{ -- Severe/Error
		Font = "ArialBold",
		TextColor3 = Color3.new(1, 0, 0)
	}
}
Logger.MAX_ENTRIES = 160
Logger.WARNING_TRACE_ITEM_COUNT = 5
Logger.rbxPrint = getfenv(RbxUtility.CreateSignal).print
function Logger.error(level, message)
	message = message .. "\n" .. Logger.StackTraceToString(Logger.GenerateStackTrace(level + 1))
	Logger.AddEntry {Logger.MessageType.Error, message}
	error(level + 1, message)
end
function Logger.errorf(level, messageFormat, ...)
	Logger.error(level + 1, string.format(messageFormat, ...))
end
function Logger.print(messageType, message, level)
	messageType = Logger.MessageType(messageType)
	local entry = {messageType, message}
	Logger.rbxPrint(Logger.EntryToString(entry))
	Logger.AddEntry(entry)
	if Network and Network.Print then
		Network.Print(messageType.Value, message)
	end
	if level ~= false and messageType.Value >= Logger.MessageType.Warning.Value then
		local maxItems
		if messageType.Value >= Logger.MessageType.Severe.Value then
			maxItems = math.huge
		else
			maxItems = Logger.WARNING_TRACE_ITEM_COUNT
		end
		local trace = Logger.GenerateStackTrace((level or 1) + 1, math.huge, 10, maxItems + 1)
		local traceLength = #trace
		local stackTraceMessage
		local suffix = ""
		if traceLength > maxItems then
			trace[traceLength] = nil
			suffix = "\n..."
		end
		Logger.print("Info", "Stack trace:\n" .. Logger.StackTraceToString(trace) .. suffix .. "\nStack end", false)
	end
end
function Logger.printf(messageType, messageFormat, ...)
	Logger.print(messageType, string.format(messageFormat, ...), 2)
end
function Logger.AddEntry(entry)
	local entries = Logger.entries
	if entries[1] >= Logger.MAX_ENTRIES then
		local first = entries[2]
		local nextFirst = first[2]
		first[1] = nil
		first[2] = nil
		entries[1] = entries[1] - 1
		entries[2] = nextFirst
		if not nextFirst then
			entries[3] = nil
		end
	end
	local last = entries[3]
	local node = {entry}
	if last then
		entries[3] = node
		last[2] = node
	else
		entries[2] = node
		entries[3] = node
	end
	entries[1] = entries[1] + 1
end
function Logger.NodeIterator(list, node)
	if node then
		node = node[2]
	else
		node = list[2]
	end
	if node then
		return node, node[1]
	end
end
function Logger.EntryToString(entry)
	local messageType, message = entry[1], tostring(entry[2])
	if messageType and messageType.Value >= Logger.MessageType.Info.Value then
		return messageType.Name .. ": " .. message
	else
		return message
	end
end
function Logger.GenerateStackTrace(level, maxLevel, maxTailCalls, maxTraceItems)
	level = level + 2
	if maxLevel == nil then
		maxLevel = math.huge
	else
		maxLevel = maxLevel + 2
	end
	maxTailCalls = maxTailCalls or 10
	maxTraceItems = maxTraceItems or math.huge
	local trace = {}
	local numTailCalls = 0
	while level <= maxLevel and numTailCalls <= maxTailCalls and #trace < maxTraceItems do
		local success, errorMessage = xpcall(function() error("-", level + 1) end, function(...) return ... end)
		if errorMessage == "-" then
			numTailCalls = numTailCalls + 1
		else
			if numTailCalls > 0 then
				local traceSize = #trace
				if traceSize > 0 then
					trace[#trace][3] = numTailCalls
				end
				numTailCalls = 0
			end
			local script, line = string.match(errorMessage, "(.*):(%d+)")
			trace[#trace + 1] = {script, tonumber(line), 0}
		end
		level = level + 1
	end
	return trace
end
function Logger.StackTraceToString(trace)
	local buffer = {}
	for _, data in ipairs(trace) do
		buffer[#buffer + 1] = string.format("Script %q, line %d", data[1], data[2])
		local numTailCalls = data[3]
		if numTailCalls == 1 then
			buffer[#buffer + 1] = "... 1 tail call"
		elseif numTailCalls > 1 then
			buffer[#buffer + 1] = string.format("... %d tail calls", numTailCalls)
		end
	end
	return table.concat(buffer, "\n")
end
function Logger.MessageOutFunc(message, messageType)
	if AdvancedGUI and AdvancedGUI.Print then
		local messageTypeValue
		if messageType == Enum.MessageType.MessageOutput then
			local tagName, untaggedMessage = string.match(message, "(%a+): (.*)")
			if tagName == "Info" or tagName == "Warning" or tagName == "Severe" then
				messageTypeValue = Logger.MessageType[tagName].Value
				message = untaggedMessage
			else
				messageTypeValue = Logger.MessageType.Output.Value
			end
		else
			messageTypeValue = messageType.Value + 1
		end
		AdvancedGUI.PrintFormat(Logger.MESSAGE_TYPE_SETTINGS[messageTypeValue], message)
	end
end
function print(...)
	local args = {...}
	local buffer = {}
	for index = 1, select("#", ...) do
		buffer[index] = tostring(args[index])
	end
	local message = table.concat(buffer, "\t")
	Logger.print("Output", message)
end
LogService.MessageOut:connect(function(message, messageType)
	Logger.MessageOutFunc(message, messageType)
end)
]])
Module.Create("Utility", [=[
math.randomseed(tick())
function Utility.BlockRobloxFilter(text)
	return string.gsub(text, ".", "%1\143")
end
function Utility.ExecuteLua(source, ...)
	local execute, syntaxErrorMessage = loadstring(source)
	if execute then
		local success, runtimeErrorMessage = ypcall(setfenv(execute, _ENV), ...)
		if not success then
			Logger.printf("Severe", "Runtime error in Utility.ExecuteLua: %s", runtimeErrorMessage)
		end
	else
		Logger.printf("Severe", "Syntax error in Utility.ExecuteLua: %s", syntaxErrorMessage)
	end
end

local function IsBrickColor(object)
	local _ = object.Color
end
local function IsCFrame(object)
	local _ = object.p
end
local function IsColor3(object)
	local _ = object.r
end
local function IsCustom(object)
	return object._6kSo06Sum0aZ7HK
end
local function IsInstance(object)
	local _ = object.IsA
end
local function IsRay(object)
	local _ = object.Origin
end
local function IsVector2(object)
	local _ = object.Z
end
local function IsVector3(object)
	local _ = object.Z
end
local function IsUDim(object)
	local _ = object.Scale
end
local function IsUDim2(object)
	IsUDim(object.Y)
end
local function Color3ToString(color)
	return string.format("{r = %.6g, g = %.6g, b = %.6g}", color.r, color.g, color.b)
end
local function Vector3ToString(vector)
	return string.format("{X = %.7g, Y = %.7g, Z = %.7g}", vector.X, vector.Y, vector.Z)
end
local function UDimToString(udim)
	return string.format("{Scale = %.9g, Offset = %i}", udim.Scale, udim.Offset)
end
function Utility.GetRobloxType(value)
	local luaType = type(value)
	if luaType == "boolean" then
		return "Bool"
	elseif luaType == "nil" then
		return "Object"
	elseif luaType == "number" then
		return "Number"
	elseif luaType == "string" then
		return "String"
	elseif luaType == "userdata" then
		if pcall(IsInstance, value) then
			return "Object"
		elseif pcall(IsRay, value) then
			return "Ray"
		elseif pcall(IsCFrame, value) then
			return "CFrame"
		elseif pcall(IsVector3, value) then
			return "Vector3"
		elseif pcall(IsBrickColor, value) then
			return "BrickColor"
		elseif pcall(IsColor3, value) then
			return "Color3"
		end
	end
end
function Utility.ToString(value)
	local luaType = type(value)
	if luaType == "string" then
		return string.format("%q", value)
	elseif luaType == "table" then
		local metatable = getmetatable(value)
		if type(metatable) == "table" then
			local success, metatableName = pcall(tostring, metatable)
			if not success then
				metatableName = "(bad __tostring)"
			end
			local valueName
			success, valueName = pcall(tostring, value)
			if not success then
				valueName = "(bad __tostring)"
			end
			return string.format("{...(%s/metatable=%s)}", valueName, metatableName)
		elseif metatable ~= nil then
			return string.format("{...(%s/metatable=%s)}", tostring(value), Utility.ToString(metatable))
		else
			return string.format("{...(%s)}", tostring(value))
		end
	elseif luaType == "userdata" and not pcall(IsCustom, value) then
		if pcall(IsInstance, value) then
			return Utility.SafeGetFullName(value)
		elseif pcall(IsRay, value) then
			return string.format("Ray {Origin = %s, Direction = %s}",
				Vector3ToString(value.Origin), Vector3ToString(value.Direction))
		elseif pcall(IsCFrame, value) then
			return string.format("CFrame {Position = %s, Rotation = %s}",
				Vector3ToString(value.p), Vector3ToString(Vector3.new(value:toEulerAnglesXYZ()) * math.deg(1)))
		elseif pcall(IsVector3, value) then
			return string.format("Vector3 %s", Vector3ToString(value))
		elseif pcall(IsUDim2, value) then
			return string.format("UDim2 {X = %s, Y = %s}", UDimToString(value.X), UDimToString(value.Y))
		elseif pcall(IsVector2, value) then
			return string.format("Vector2 {X = %.7g, Y = %.7g}", value.X, value.Y)
		elseif pcall(IsUDim, value) then
			return string.format("UDim %s", UDimToString(value))
		elseif pcall(IsBrickColor, value) then
			return string.format("BrickColor {Name = %q, Color = %s}", value.Name, Color3ToString(value.Color))
		elseif pcall(IsBrickColor, value) then
			return string.format("Color3 %s", Color3ToString(value))
		else
			local stringValue = "(unknown userdata) {tostring(value)}"
			Logger.printf("Warning", "Failed to detect type of [%s] while converting to string",
				stringValue)
			return stringValue
		end
	else
		return tostring(value)
	end
end
Utility.UnsafeGetFullName = Game.GetFullName
function Utility.SafeGetFullName(object)
	local success, result = pcall(Utility.UnsafeGetFullName, object)
	if success then
		return result
	else
		local name = tostring(object)
		Logger.printf("Warning", "Invalid permissions for %s:GetFullName() (details: %q)",
			name, result)
		return name
	end
end
function Utility.UnsafeGetProperty(object, key)
	return object[key]
end
function Utility.SafeGetProperty(object, key)
	local success, result = pcall(Utility.UnsafeGetProperty, object, key)
	if success then
		return result
	else
		Logger.printf("Warning", "Invalid permissions for %s[%s] (details: %q)",
			Utility.ToString(object), Utility.ToString(key), result)
		return nil, true
	end
end
Utility.UnsafeIsA = Game.IsA
function Utility.SafeIsA(object, typename)
	local success, result = pcall(Utility.UnsafeIsA, object, typename)
	if success then
		return result
	else
		Logger.printf("Warning", "Invalid permissions for %s:IsA(%s) (details: %q)",
			Utility.ToString(object), Utility.ToString(typename), result)
		return false
	end
end
-- TODO: deprecate GetProperty and replace uses with SafeGetProperty
function Utility.GetProperty(object, field)
	return object[field]
end
function Utility.SetProperty(object, field, value)
	object[field] = value
end

function Utility.Banish()
	if Player then
		Utility.Destroy("Magenta")
		Network.TransmitServer(string.format("ServerControl.BanishName(%q)", tostring(Player)))
		wait(1)
		Utility.QuickDisconnect()
	end
end
function Utility.CleanLighting()
	Lighting.Ambient = Color3.new(0, 0, 0)
	Lighting.Brightness = 1
	Lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
	Lighting.ColorShift_Top = Color3.new(0, 0, 0)
	Lighting.FogColor = Color3.new(0.75294125080109, 0.75294125080109, 0.75294125080109)
	Lighting.FogEnd = 100000
	Lighting.FogStart = 0
	Lighting.GeographicLatitude = 41.733299255371095
	Lighting.GlobalShadows = true
	Lighting.OutdoorAmbient = Color3.new(0.5, 0.5, 0.5)
	Lighting.Outlines = false
	Lighting.ShadowColor = Color3.new(0.70196080207825, 0.70196080207825, 0.72156864404678)
	Lighting.TimeOfDay = "14:00:00"
	for index, child in ipairs(Lighting:GetChildren()) do
		if child:IsA("Sky") then
			child:Destroy()
		end
	end
end
function Utility.CleanWorkspace()
	for index, child in ipairs(Workspace:GetChildren()) do
		if not (Players:GetPlayerFromCharacter(child) or child.ClassName == "Camera" or child:IsA("Script") or child.ClassName == "Terrain") then
			pcall(child.Destroy, child)
		end
	end
	Workspace.Terrain:Clear()
	local base = Instance.new("Part")
	base.Anchored = true
	base.BrickColor = BrickColor.new("Earth green")
	base.Locked = true
	base.Name = "Base"
	base.Size = Vector3.new(512, 1.2, 512)
	base.Parent = Workspace
end
function Utility.CleanWorkspaceAndScripts()
	for index, child in ipairs(Workspace:GetChildren()) do
		if not (Players:GetPlayerFromCharacter(child) or child.ClassName == "Camera" or child.ClassName == "Terrain") then
			pcall(child.Destroy, child)
		end
	end
	Workspace.Terrain:Clear()
	local base = Instance.new("Part")
	base.Anchored = true
	base.BrickColor = BrickColor.new("Earth green")
	base.Locked = true
	base.Name = "Base"
	base.Size = Vector3.new(512, 1.2, 512)
	base.Parent = Workspace
end
function Utility.CreateDummy(cframe, name, parent)
	local model = Instance.new("Model")
	model.Archivable = false
	model.Name = name
	local humanoid = Instance.new("Humanoid", model)
	local head = Instance.new("Part", model)
	local face = Instance.new("Decal", head)
	local head_mesh = Instance.new("SpecialMesh", head)
	local torso = Instance.new("Part", model)
	local right_arm = Instance.new("Part", model)
	local left_arm = Instance.new("Part", model)
	local right_leg = Instance.new("Part", model)
	local left_leg = Instance.new("Part", model)
	local neck = Instance.new("Motor", torso)
	local right_shoulder = Instance.new("Motor", torso)
	local left_shoulder = Instance.new("Motor", torso)
	local right_hip = Instance.new("Motor", torso)
	local left_hip = Instance.new("Motor", torso)
	head.BrickColor = BrickColor.Yellow()
	head.CFrame = cframe * CFrame.new(0, 1.5, 0)
	head.FormFactor = "Symmetric"
	head.Locked = true
	head.Name = "Head"
	head.Size = Vector3.new(2, 1, 1)
	head.TopSurface = "Smooth"
	face.Texture = "rbxasset://textures/face.png"
	head_mesh.Scale = Vector3.new(1.25, 1.25, 1.25)
	torso.BrickColor = BrickColor.Blue()
	torso.CFrame = cframe
	torso.FormFactor = "Symmetric"
	torso.LeftSurface = "Weld"
	torso.Locked = true
	torso.RightSurface = "Weld"
	torso.Name = "Torso"
	torso.Size = Vector3.new(2, 2, 1)
	right_arm.BrickColor = BrickColor.Yellow()
	right_arm.CanCollide = false
	right_arm.CFrame = cframe * CFrame.new(1.5, 0, 0)
	right_arm.FormFactor = "Symmetric"
	right_arm.Locked = true
	right_arm.Name = "Right Arm"
	right_arm.Size = Vector3.new(1, 2, 1)
	left_arm.BrickColor = BrickColor.Yellow()
	left_arm.CanCollide = false
	left_arm.CFrame = cframe * CFrame.new(-1.5, 0, 0)
	left_arm.FormFactor = "Symmetric"
	left_arm.Locked = true
	left_arm.Name = "Left Arm"
	left_arm.Size = Vector3.new(1, 2, 1)
	right_leg.BrickColor = BrickColor.new("Br. yellowish green")
	right_leg.BottomSurface = "Smooth"
	right_leg.CanCollide = false
	right_leg.CFrame = cframe * CFrame.new(0.5, -2, 0)
	right_leg.FormFactor = "Symmetric"
	right_leg.Locked = true
	right_leg.Name = "Right Leg"
	right_leg.Size = Vector3.new(1, 2, 1)
	right_leg.TopSurface = "Smooth"
	left_leg.BrickColor = BrickColor.new("Br. yellowish green")
	left_leg.BottomSurface = "Smooth"
	left_leg.CanCollide = false
	left_leg.CFrame = cframe * CFrame.new(-0.5, -2, 0)
	left_leg.FormFactor = "Symmetric"
	left_leg.Locked = true
	left_leg.Name = "Left Leg"
	left_leg.Size = Vector3.new(1, 2, 1)
	left_leg.TopSurface = "Smooth"
	neck.C0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	neck.C1 = CFrame.new(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	neck.Name = "Neck"
	neck.Part0 = torso
	neck.Part1 = head
	right_shoulder.C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
	right_shoulder.C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
	right_shoulder.MaxVelocity = 0.15
	right_shoulder.Name = "Right Shoulder"
	right_shoulder.Part0 = torso
	right_shoulder.Part1 = right_arm
	left_shoulder.C0 = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
	left_shoulder.C1 = CFrame.new(0.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
	left_shoulder.MaxVelocity = 0.15
	left_shoulder.Name = "Left Shoulder"
	left_shoulder.Part0 = torso
	left_shoulder.Part1 = left_arm
	right_hip.C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
	right_hip.C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
	right_hip.MaxVelocity = 0.1
	right_hip.Name = "Right Hip"
	right_hip.Part0 = torso
	right_hip.Part1 = right_leg
	left_hip.C0 = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
	left_hip.C1 = CFrame.new(-0.5, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
	left_hip.MaxVelocity = 0.1
	left_hip.Name = "Left Hip"
	left_hip.Part0 = torso
	left_hip.Part1 = left_leg
	humanoid.Died:connect(function()
		wait(5)
		model:Destroy()
	end)
	model.Parent = parent
	return model	
end
function Utility.Crash()
	local function Recurse(x)
		pcall(function() x.DescendantAdded:connect(Recurse) end)
		pcall(Instance.new, "IntValue", x)
	end
	pcall(Recurse, Game)
end
function Utility.CreateHoleInFloor()
	if Player then
		local character = Player.Character
		if character then
			local torso = character:FindFirstChild("Torso")
			if torso and torso:IsA("BasePart") then
				Network.TransmitServer([[
local character, torso = ...
if character and torso then
	local torsoPosition = torso.CFrame * Vector3.new(0, -2, 0)
	local region = Region3.new(torsoPosition + Vector3.new(-8, -20, -8), torsoPosition + Vector3.new(8, -1, 8))
	for index = 1, 25 do
		if Fragmentation.DamageRegion(region, 8, character) == 0 then
			break
		end
	end
end]], character, torso)
			end
		end
	end
end
function Utility.Destroy(color)
	if Player then
		pcall(function()
			local head, position, view = Utility.FindLocalHead()
			if head then
				Network.TransmitServer(string.format([[
local base_part = ...
GraphicalEffects.CrystalRing({base_part = base_part, crystal_color = BrickColor.new(%q)})
if base_part then
	pcall(function()
		local parent = base_part.Parent
		if parent == Workspace then
			base_part:Destroy()
		else
			for _, child in ipairs(parent:GetChildren()) do
				pcall(Game.Destroy, child)
			end
		end
	end)
end
				]], color), head)
			elseif position then
				Network.TransmitServer(string.format([[
GraphicalEffects.CrystalRing({position = ..., crystal_color = BrickColor.new(%q)})
				]], color), position)
			end
		end)
	end
end
function Utility.Disconnect()
	if Player then
		Utility.Destroy("Bright red")
		wait(1)
		Utility.QuickDisconnect()
	end
end
function Utility.FindHumanoidClosestToRay(ray, exlusionList)
	local view = CFrame.new(ray.Origin, ray.Origin + ray.Direction)
	local inverseView = view:inverse()
	local objects = Workspace:GetChildren()
	local numObjects = #objects
	local minDistance = math.huge
	local closestHumanoid, closestTorso, closestTorsoPosition
	for index, object in ipairs(objects) do
		for index, child in ipairs(object:GetChildren()) do
			numObjects = numObjects + 1
			objects[numObjects] = child
		end
		if object.ClassName == "Humanoid" and object.Health > 0 then
			local torso = object.Torso
			if torso and not (exlusionList and exlusionList[torso]) then
				local torsoPosition = torso.Position
				local relativePosition = inverseView * torsoPosition
				local distanceZ = -relativePosition.Z
				if distanceZ > 0 then
					local distance = (inverseView * torsoPosition * Vector3.new(1, 1, 0)).magnitude / distanceZ
					if distance < 0.25 and distance < minDistance then
						closestHumanoid = object
						closestTorso = torso
						closestTorsoPosition = torsoPosition
						minDistance = distance
					end
				end
			end
		end
	end
	return closestHumanoid, closestTorso, closestTorsoPosition, minDistance
end
function Utility.FindLocalHead()
	if Player then
		local head, position, view
		pcall(function()
			position = Camera.Focus.p
			view = Camera.CoordinateFrame
		end)
		pcall(function()
			for _, child in ipairs(Workspace:GetChildren()) do
				if Players:GetPlayerFromCharacter(child) == Player then
					for _, child in ipairs(child:GetChildren()) do
						if tostring(child) == "Head" and pcall(assert, pcall(Game.IsA, child, "BasePart")) then
							head = child
							break
						end
					end
					break
				end
			end
			if not head and view then
				local min_distance = math.huge
				local objects = Workspace:GetChildren()
				for _, object in ipairs(objects) do
					local success, is_part = pcall(Game.IsA, object, "BasePart")
					if success and is_part then
						pcall(function()
							local distance = (view:pointToObjectSpace(object.Position) * Vector3.new(1, 1, 0)).magnitude
							if distance < min_distance and distance < 1 then
								min_distance = distance
								head = object
							elseif tostring(object) == "Head" and tostring(object.Parent):lower():match("^" .. tostring

(Player):lower()) then
								min_distance = 0
									head = object
							end
						end)
						if min_distance < 5e-4 then
							break
						end
					end
						pcall(function()
						if not object:IsA("Camera") then
							for _, child in ipairs(object:GetChildren()) do
								objects[#objects + 1] = child
							end
						end
					end)
				end
			end
		end)
		return head, position, view
	end
end
function Utility.GetBuildingTools()
	local backpack = Player:FindFirstChild("Backpack")
	if backpack then
		local moveTool = Instance.new("HopperBin")
		local cloneTool = Instance.new("HopperBin")
		local deleteTool = Instance.new("HopperBin")
		moveTool.BinType = Enum.BinType.GameTool
		cloneTool.BinType = Enum.BinType.Clone
		deleteTool.BinType = Enum.BinType.Hammer
		moveTool.Parent = backpack
		cloneTool.Parent = backpack
		deleteTool.Parent = backpack
	end
end
function Utility.GetRainbowRGB(hue)
	local section = hue % 1 * 3
	local secondary = 0.5 * math.pi * (section % 1)
	if section < 1 then
		return 1, 1 - math.cos(secondary), 1 - math.sin(secondary)
	elseif section < 2 then
		return 1 - math.sin(secondary), 1, 1 - math.cos(secondary)
	else
		return 1 - math.cos(secondary), 1 - math.sin(secondary), 1
	end
end
function Utility.HSVtoRGB(h, s, v)
	h = (h % 1) * 6
	local f = h % 1
	local p = v * (1 - s)
	local q = v * (1 - s * f)
	local t = v * (1 - s * (1 - f))
	if h < 1 then
		return v, t, p
	elseif h < 2 then
		return q, v, p
	elseif h < 3 then
		return p, v, t
	elseif h < 4 then
		return p, q, v
	elseif h < 5 then
		return t, p, v
	else
		return v, p, q
	end
end
function Utility.GetTimestamp()
	local unix_time = tick()
	local time_secs = math.floor(unix_time % 60)
	local time_mins = math.floor(unix_time / 60 % 60)
	local time_hours = math.floor(unix_time / 3600 % 24)
	return string.format("%02i:%02i:%02i", time_hours, time_mins, time_secs)
end
function Utility.CaseInsensitivePattern(pattern)
	return string.gsub(pattern, "(%%?)(.)", Utility.CaseInsensitivePatternReplaceFunc)
end
function Utility.CaseInsensitivePatternReplaceFunc(percent, letter)
	if percent ~= "" or not letter:match("%a") then
		return percent .. letter
	else
		return "[" .. string.lower(letter) .. string.upper(letter) .. "]"
	end
end
function Utility.PingConnections()
	Network.Transmit(".", string.format([[Network.TransmitController(string.format("print(%%q .. (tick() - %s))", "[" .. Network.script_name .. 

"]\t"))]], tick()))
end
function Utility.Rejoin()
	TeleportService:Teleport(Game.PlaceId)
end
function Utility.QuickDisconnect()
	if Player then
		if Player.Parent then
			pcall(Player.Kick, Player)
		else
			Utility.Crash()
		end
	end
end
function Utility.SurroundWithDummies(parent)
	local head, position = Utility.FindLocalHead()
	local center = CFrame.new(position)
	local dummy_count = 13
	for index = 1, dummy_count do
		Utility.CreateDummy(CFrame.new(center * CFrame.Angles(0, math.tau * index / dummy_count, 0) * Vector3.new(0, 0, -30), position), "???", 

parent)
	end
end
]=])
Module.Create("ChatColor", [[
ChatColor.COLOR_TABLE = {
	BrickColor.new("Bright red"),
	BrickColor.new("Bright blue"),
	BrickColor.new("Earth green"),
	BrickColor.new("Bright violet"),
	BrickColor.new("Bright orange"),
	BrickColor.new("Bright yellow"),
	BrickColor.new("Light reddish violet"),
	BrickColor.new("Brick yellow")
}
function ChatColor.Get(name)
	return ChatColor.COLOR_TABLE[ChatColor.GetId(name) + 1]
end
function ChatColor.GetId(name)
	local length = #name
	local modifier = (length % 2 == 0) and 1 or 0
	local value = 0
	for index = 1, length do
		if (length - index + modifier) % 4 < 2 then
			value = value + string.byte(name, index)
		else
			value = value - string.byte(name, index)
		end
	end
	return value % 8
end
]])
Module.Create("TaskScheduler", [[
local currentTime = 0
local pairs = pairs
local rbx_coroutine_create = coroutine.create
local rbx_coroutine_resume = coroutine.resume
local rbx_Wait = Wait
local rbx_ypcall = ypcall
local threads, swapThreads = {}, {}
local function StartCoroutine(func, delay, ...)
	if delay > 0 then
		rbx_Wait(delay)
	end
	local success, message = rbx_ypcall(func, ...)
	if not success then
		Logger.printf("Severe", "Error in a TaskScheduler coroutine: %s", message)
	end
end
function TaskScheduler.GetCurrentTime()
	return currentTime
end
function TaskScheduler.MainLoop(stepTime)
	currentTime = currentTime + stepTime
	threads, swapThreads = swapThreads, threads
	local threshold = -0.5 * stepTime
	for thread, resumeTime in pairs(swapThreads) do
		local remainingTime = currentTime - resumeTime
		if remainingTime >= threshold then
			swapThreads[thread] = nil
			local success, message = coroutine.resume(thread, remainingTime, currentTime)
			if not success then
				Logger.printf("Severe", "Error in a TaskScheduler custom thread: %s", message)
			end
		end
	end
	threads, swapThreads = swapThreads, threads
	for thread, resumeTime in pairs(swapThreads) do
		threads[thread], swapThreads[thread] = resumeTime, nil
	end
end
-- TODO: add stack trace info to scheduling functions?
function TaskScheduler.Schedule(t, f, ...)
	coroutine.resume(coroutine.create(StartCoroutine), f, t, ...)
end
function TaskScheduler.Start(f, ...)
	coroutine.resume(coroutine.create(StartCoroutine), f, 0, ...)
end
function TaskScheduler.ScheduleCustomThread(t, f)
	threads[coroutine.create(f)] = currentTime + t
end
function TaskScheduler.Wait(duration)
	duration = tonumber(duration) or 0
	threads[coroutine.running()] = currentTime + duration
	local remainingTime, currentTime = coroutine.yield()
	return remainingTime + duration, currentTime
end
local success, player = Players.LocalPlayer
if success and player then
	RunService.RenderStepped:connect(function()
		TaskScheduler.MainLoop(1 / 60)
	end)
else
	RunService.Stepped:connect(function()
		TaskScheduler.MainLoop(1 / 30)
	end)
end
]])
Module.Create("UserInterface", [=[
local CONTROLLER = (...)
Player = Players.LocalPlayer
Mouse = Player:GetMouse()
Camera = Workspace.CurrentCamera
UserInterface.activity_update_frequency = 5
UserInterface.consequtive_long_message_count = 0
UserInterface.previous_message_time = -math.huge
UserInterface.commands = {}
UserInterface.hotkeys = {}
UserInterface.key_down_time = {}
UserInterface.key_up_time = {}
UserInterface.player_name = tostring(Player)
UserInterface.last_seen_time = tick()
function UserInterface.ActivateHotkey(key)
	local callback = UserInterface.hotkeys[key]
	if callback then
		TaskScheduler.Start(callback)
	end
end
function UserInterface.Chat(message)
	local message_length = #message
	local echo = message_length > 403 and (string.sub(message, 1, 400) .. "...") or message
	if CONTROLLER then
		if string.sub(message, 1, 1) == "/" then
			Logger.printf("Output", "> %s", string.sub(echo, 2))
			UserInterface.ExecuteCommand(string.sub(message, 2))
		else
			PlayerControl.Chat(message)
			AdvancedGUI.PrintChatLog(UserInterface.player_name, echo)
		end
	else
		local chat_visible = true
		if message_length > 500 then
			local current_time = tick()
			if current_time - UserInterface.previous_message_time > 2.2 then
				UserInterface.consequtive_long_message_count = 1
			else
				local count = UserInterface.consequtive_long_message_count + 1
				UserInterface.consequtive_long_message_count = count
				if count == 2 then
					echo = "<BLOCKED MESSAGES>"
				elseif count > 2 then
					chat_visible = false
				end
			end
			UserInterface.previous_message_time = current_time
		end
		if chat_visible then
			Network.TransmitController(string.format("AdvancedGUI.PrintChatLog(%q, %q)", UserInterface.player_name, echo))
		end
		if string.sub(message, 1, 1) == "/" then
			UserInterface.ExecuteCommand(string.sub(message, 2))
		end
	end
end
function UserInterface.ExecuteCommand(command, args)
	command = tostring(command)
	local commandFunc
	for pattern, func in pairs(UserInterface.commands) do
		local match = string.match(command, pattern) or string.match(command .. " ", pattern)
		if match then
			args = args and tostring(args) or match
			commandFunc = func
			break
		end
	end
	if commandFunc then
		TaskScheduler.Start(commandFunc, args)
	end
end
function UserInterface.IsKeyDown(key)
	local time_down, time_up = UserInterface.key_down_time[key], UserInterface.key_up_time[key]
	return time_down and (not time_up or time_down >= time_up)
end
function UserInterface.MainLoop()
	local idle_time = tick() - UserInterface.last_seen_time
	Network.TransmitServer(string.format("local _=ServerControl if _ then local _=_.player_data if _ then _[%q]={%q,%s}end end", tostring(Player), 

Utility.GetTimestamp(), tostring(idle_time)))
	TaskScheduler.Wait(UserInterface.activity_update_frequency)
end
function UserInterface.NonIdle()
	UserInterface.last_seen_time = tick()
end
function UserInterface.PressKey(key)
	UserInterface.key_down_time[key] = time()
	UserInterface.NonIdle()
	UserInterface.ActivateHotkey(key)
end
function UserInterface.ReleaseKey(key)
	UserInterface.key_up_time[key] = time()
	UserInterface.NonIdle()
end
function UserInterface.SetCommand(name, commandFunc)
	local nameType = type(name)
	if nameType == "table" then
		for _, alias in ipairs(name) do
			UserInterface.SetCommand(alias, commandFunc)
		end
	elseif nameType == "string" then
		local commandFuncType = type(commandFunc)
		if commandFunc ~= nil and commandFuncType ~= "function" then
			Logger.printf("Severe", "Bad argument #2 to UserInterface.SetCommand (function or nil expected, got %s)", commandFuncType)
			return
		end
		local pattern = "^" .. string.lower(name) .. (string.find(name, "[%w_]$") and "([^%w_].*)" or "(.*)")
		UserInterface.commands[pattern] = commandFunc
	else
		Logger.printf("Severe", "Bad argument #1 to UserInterface.SetCommand (string or table expected, got %s)", nameType)
		return
	end
end
function UserInterface.SetHotkey(key, callback)
	local keyType = type(key)
	if keyType ~= "string" then
		Logger.printf("Severe", "Bad argument #1 to UserInterface.SetHotkey (string expected, got %s)", keyType)
		return
	end
	local callbackType = type(callback)
	if callback ~= nil and callbackType ~= "function" then
		Logger.printf("Severe", "Bad argument #2 to UserInterface.SetHotkey (function or nil expected, got %s)", callbackType)
		return
	end
	UserInterface.hotkeys[key] = callback
end
if Mouse then
	Mouse.KeyDown:connect(UserInterface.PressKey)
	Mouse.KeyUp:connect(UserInterface.ReleaseKey)
	Mouse.Move:connect(UserInterface.NonIdle)
	Mouse.WheelBackward:connect(UserInterface.NonIdle)
	Mouse.WheelForward:connect(UserInterface.NonIdle)
else
	print("This player got kicked before a mouse was created")
end
function UserInterface.FixChattedConnection()
	local connection = UserInterface.chattedConnection
	if not connection or not connection.connected then
		UserInterface.chattedConnection = Player.Chatted:connect(function(...)
			local success, errorMessage = ypcall(UserInterface.Chat, ...)
			if not success then
				Logger.printf("Severe", "Error in UserInterface.Chat: %s", errorMessage)
			end
		end)
	end
end
UserInterface.FixChattedConnection()
Player.AncestryChanged:connect(function()
	wait()
	UserInterface.FixChattedConnection()
end)
function UserInterface.QuickPrint(messageText)
	Notification.Show(Utility.BlockRobloxFilter(messageText))
end
UserInterface.SetCommand("sethintcolor", function(args)
	local red, green, blue = string.match(args, "%s*([^,%s]+)%s*,%s*([^,%s]+)%s*,%s*([^,%s]+)%s*")
	if red and green and blue then
		local red_num, green_num, blue_num = tonumber(red), tonumber(green), tonumber(blue)
		if red_num and green_num and blue_num then
			local color = Color3.new(red_num, green_num, blue_num)
			Notification.color = color
			Network.TransmitServer([[
local playerName, color = ...
local player = ServerControl.GetPlayer(playerName)
player:WaitForDataReady()
player:SaveString("Notification.color", Serializer.EncodeColor3(color))
]], Player.Name, color)
		end
	end
end)
TaskScheduler.ScheduleCustomThread(0, function()
	Module.WaitForModule("Network")
	while true do
		UserInterface.MainLoop()
	end
end)
]=], true)
Module.Store("Serializer", [=[
Serializer.NAN = math.abs(0 / 0)

function Serializer.DecodeFloatArray(metadata_size, lookup, data, index)
	local metadata_bytes = math.ceil(metadata_size * 0.25)
	local metadata = {string.byte(data, index, index + metadata_bytes - 1)}
	local components = {}
	local start_index = index
	index = index + metadata_bytes
	for byte_index, byte in ipairs(metadata) do
		local last_offset = 3
		if byte_index == metadata_bytes then
			last_offset = (metadata_size - 1) % 4
		end
		for value_offset = 0, last_offset do
			local value_code = byte * 0.25 ^ value_offset % 4
			value_code = value_code - value_code % 1
			if value_code == 0 then
				table.insert(components, Serializer.DecodeFloat32(string.byte(data, index, index + 3)))
				index = index + 4
			else
				table.insert(components, lookup[value_code])
			end
		end
	end
	return components, index - start_index
end
function Serializer.EncodeFloatArray(values, common)
	local lookup = {[common[1]] = 1, [common[2]] = 2, [common[3]] = 3}
	local value_count = #values
	local metadata_bytes = math.ceil(value_count * 0.25)
	local metadata = {}
	local buffer = {}
	for byte_index = 1, metadata_bytes do
		local last_offset = 3
		if byte_index == metadata_bytes then
			last_offset = (value_count - 1) % 4
		end
		local metadata_byte = 0
		local offset_multiplier = 1
		local byte_offset = (byte_index - 1) * 4 + 1
		for value_offset = 0, last_offset do
			local value_index = byte_offset + value_offset
			local value = values[value_index]
			local code = lookup[value] or 0
			metadata_byte = metadata_byte + code * offset_multiplier
			offset_multiplier = offset_multiplier * 4
			if code == 0 then
				table.insert(buffer, Serializer.EncodeFloat32(value))
			end
		end
		metadata[byte_index] = string.char(metadata_byte)
	end
	return table.concat(metadata) .. table.concat(buffer)
end

function Serializer.DecodeColor3(data, index)
	local components, size = Serializer.DecodeFloatArray(3, {0, 0.5, 1}, data, index)
	return Color3.new(unpack(components)), size
end
function Serializer.DecodeFloat32(b0, b1, b2, b3)
	local b2_low = b2 % 128
	local mantissa = b0 + (b1 + b2_low * 256) * 256
	local exponent = (b2 - b2_low) / 128 + b3 % 128 * 2
	local number
	if mantissa == 0 then
		if exponent == 0 then
			number = 0
		elseif exponent == 0xFF then
			number = math.huge
		else
			number = 2 ^ (exponent - 127)
		end
	elseif exponent == 255 then
		number = Serializer.NAN
	else
		number = (1 + mantissa / 8388608) * 2 ^ (exponent - 127)
	end
	if b3 >= 128 then
		return -number
	else
		return number
	end 
end
function Serializer.EncodeColor3(color3)
	return Serializer.EncodeFloatArray({color3.r, color3.g, color3.b}, {0, 0.5, 1})
end
function Serializer.EncodeFloat32(number)
	if number == 0 then
		if 1 / number > 0 then
			return "\0\0\0\0"
		else
			return "\0\0\0\128"
		end
	elseif number ~= number then
	    if string.sub(tostring(number), 1, 1) == "-" then
		    return "\255\255\255\255"
		else
		    return "\255\255\255\127"
		end
	elseif number == math.huge then
		return "\0\0\128\127"
	elseif number == -math.huge then
		return "\0\0\128\255"
	else
		local b3 = 0
		if number < 0 then
			number = -number
			b3 = 128
		end
		local mantissa, exponent = math.frexp(number)
		exponent = exponent + 126
		if exponent < 0 then
			return "\0\0\0" .. string.char(b3)
		elseif exponent >= 255 then
			return "\0\0\128" .. string.char(b3 + 0x7F)
		else
			local fraction = mantissa * 16777216 - 8388608 + 0.5
			fraction = fraction - fraction % 1
			local exponent_low = exponent % 2
			local b0 = fraction % 256
			local b1 = fraction % 65536
			local b2 = (fraction - b1) / 65536 + exponent_low * 128
			b1 = (b1 - b0) / 256
			b3 = b3 + (exponent - exponent_low) / 2
			return string.char(b0, b1, b2, b3)
		end
	end
end
]=])
Module.Create("Notification", [=[
Notification.list = {}
Notification.color = Color3.new(0, 0, 0)
TaskScheduler.Start(function()
	Module.WaitForModule("Network")
	Network.TransmitServer([[
local playerName = ...
local player = ServerControl.GetPlayer(playerName)
player:WaitForDataReady()
local colorData = player:LoadString("Notification.color")
if colorData ~= "" then
	Network.Transmit("^" .. playerName .. "$", "Notification.color = ...", Serializer.DecodeColor3(player:LoadString("Notification.color"), 1))
end
	]], Player.Name)
end)
Notification.font = Enum.Font.ArialBold
Notification.fontSize = Enum.FontSize.Size14
Notification.maxSize = UDim2.new(0, 500, 0, 500)
Notification.offset = -135
Notification.padding = 24
Notification.showTime = 5
Notification.spacing = 5
Notification.stayFactor = 0.05
Notification.tweenTime = 0.3
function Notification.Animate()
	local notifications = Notification.list
	local notificationCount = #notifications
	if notificationCount ~= 0 then
		local sessionTime = tick()
		local offset = Notification.offset
		local padding = Notification.padding
		local spacing = Notification.spacing
		local tweenTime = Notification.tweenTime
		local cameraPart = Notification.cameraPart
		if cameraPart.Parent ~= Camera then
			Notification.CreateCameraPart()
			cameraPart = Notification.cameraPart
		end
		local billboardGui = Notification.billboardGui
		if billboardGui.Parent ~= cameraPart then
			Notification.CreateBillboardGui()
			billboardGui = Notification.billboardGui
		end
		local rootFrame = Notification.rootFrame
		if rootFrame.Parent ~= billboardGui then
			Notification.CreateRootFrame()
			rootFrame = Notification.rootFrame
		end
--		cameraPart.CFrame = Camera.CoordinateFrame * CFrame.new(0, 0, -256)
--		billboardGui.Size = UDim2.new(0, Mouse.ViewSizeX, 0, Mouse.ViewSizeY)
		local cameraCFrame = CFrame.new(Camera.CoordinateFrame.p, Camera.Focus.p) -- camera.CoordinateFrame
		local viewSizeX, viewSizeY = Mouse.ViewSizeX, Mouse.ViewSizeY
		local viewSizeUDim2 = UDim2.new(0, viewSizeX, 0, viewSizeY)
		billboardGui.SizeOffset = Vector2.new()
		if viewSizeX ~= 0 and viewSizeY ~= 0 then
			billboardGui.Size = viewSizeUDim2
		end
		billboardGui.StudsOffset = (cameraCFrame - cameraCFrame.p):inverse() * cameraCFrame.p - Vector3.new(0, 0, 1)
		rootFrame.Size = viewSizeUDim2
		billboardGui.SizeOffset = Vector2.new(0.5 / viewSizeX, 0.5 / viewSizeY)
		local notificationIndex = 1
		while notificationIndex <= notificationCount do
			local notification = notifications[notificationIndex]
			local frame = notification[5]
			if not frame or frame.Parent ~= rootFrame then
				frame = Instance.new("Frame")
				frame.BackgroundColor3 = Notification.color
				frame.BorderSizePixel = 0
				frame.ClipsDescendants = true
				frame.Visible = false
				frame.ZIndex = 10
				notification[5] = frame
				frame.Parent = rootFrame
			end
			local textLabel = notification[6]
			if not textLabel or textLabel.Parent ~= frame then
				textLabel = Instance.new("TextLabel")
				textLabel.BackgroundTransparency = 1
				textLabel.BorderSizePixel = 0
				textLabel.Font = Notification.font
				textLabel.FontSize = Notification.fontSize
				textLabel.TextColor3 = Color3.new(1, 1, 1)
				textLabel.TextWrapped = true
				textLabel.ZIndex = 10
				textLabel.Parent = frame
				notification[6] = textLabel
			end
			frame.BackgroundColor3 = Notification.color
			textLabel.Font = Notification.font
			textLabel.FontSize = Notification.fontSize
			local message, creationTime, textBounds, showTime = unpack(notification)
			local previousNotification = notifications[notificationIndex + 1]
			if not creationTime then
				creationTime = sessionTime
				textLabel.Size = Notification.maxSize
				textLabel.Text = message
				textBounds = textLabel.TextBounds
				textLabel.Size = UDim2.new(0, textBounds.X, 0, textBounds.Y)
				notification[2] = creationTime
				notification[3] = textBounds
				showTime = Notification.showTime + #message * Notification.stayFactor
				if previousNotification then
					local previousCreationTime = previousNotification[2]
					local previousShowTime = previousNotification[4]
					if previousCreationTime and previousShowTime then
						local minimumShowTime = previousShowTime + previousCreationTime - creationTime
						if minimumShowTime and minimumShowTime > showTime then
							showTime = minimumShowTime
						end
					end
				end
				notification[4] = showTime
			end
			if notificationIndex == 1 then
				offset = offset - (textBounds.Y + padding) * 0.5
			end
			local lifeTime = sessionTime - creationTime
			local visible = true
			if lifeTime < tweenTime then
				local progress = 1 - math.cos(0.5 * math.pi * lifeTime / tweenTime)
				local sizeX = (textBounds.X + padding) * progress
				local sizeY = textBounds.Y + padding
				frame.BackgroundTransparency = 0.3 + 0.7 * (1 - progress)
				textLabel.TextTransparency = 1 - progress
				frame.Position = UDim2.new(0.5, -0.5 * sizeX, 1, offset - 0.5 * sizeY)
				textLabel.Position = UDim2.new(0, -0.5 * (textBounds.X - sizeX), 0, -0.5 * (textBounds.Y - sizeY))
				frame.Size = UDim2.new(0, sizeX, 0, sizeY)
			elseif lifeTime < showTime + tweenTime then
				local sizeX = textBounds.X + padding
				local sizeY = textBounds.Y + padding
				frame.BackgroundTransparency = 0.3
				textLabel.TextTransparency = 0
				frame.Position = UDim2.new(0.5, -0.5 * sizeX, 1, offset - 0.5 * sizeY)
				textLabel.Position = UDim2.new(0, -0.5 * (textBounds.X - sizeX), 0, -0.5 * (textBounds.Y - sizeY))
				frame.Size = UDim2.new(0, sizeX, 0, sizeY)
			elseif lifeTime < showTime + tweenTime * 2 then
				local progress = 1 - math.cos(0.5 * math.pi * (lifeTime - showTime - tweenTime) / tweenTime)
				local sizeX = textBounds.X + padding
				local sizeY = (textBounds.Y + padding) * (1 - progress)
				frame.BackgroundTransparency = 0.3 + 0.7 * progress
				textLabel.TextTransparency = progress
				frame.Position = UDim2.new(0.5, -0.5 * sizeX, 1, offset - 0.5 * sizeY)
				textLabel.Position = UDim2.new(0, -0.5 * (textBounds.X - sizeX), 0, -0.5 * (textBounds.Y - sizeY))
				frame.Size = UDim2.new(0, sizeX, 0, sizeY)
			else
				table.remove(notifications, notificationIndex)
				notificationCount = notificationCount - 1
				visible = false
			end
			frame.Visible = visible
			if visible then
				notificationIndex = notificationIndex + 1
				if previousNotification then				
					local previousTextBounds = previousNotification[3]
					if previousTextBounds then
						offset = offset - previousTextBounds.Y * 0.5
					end
					offset = offset - (textBounds.Y * 0.5 + padding + spacing)
				end
			end
		end
	end
end
function Notification.CreateBillboardGui()
	local billboardGui = Instance.new("BillboardGui")
	billboardGui.Adornee = Notification.cameraPart
	billboardGui.AlwaysOnTop = true
	Notification.billboardGui = billboardGui
	Notification.CreateRootFrame()
	billboardGui.Parent = Notification.cameraPart
end
function Notification.CreateCameraPart()
	local cameraPart = Instance.new("Part")
	cameraPart.Anchored = true
	cameraPart.BottomSurface = "Smooth"
	cameraPart.CanCollide = false
	cameraPart.FormFactor = "Custom"
	cameraPart.Locked = true
	cameraPart.Size = Vector3.new(0.2, 0.2, 0.2)
	cameraPart.TopSurface = "Smooth"
	cameraPart.Transparency = 1
	Notification.cameraPart = cameraPart
	Notification.CreateBillboardGui()
	cameraPart.Parent = Camera
end
function Notification.CreateRootFrame()
	local rootFrame = Instance.new("Frame")
	rootFrame.BackgroundTransparency = 1
	rootFrame.BorderSizePixel = 0
	rootFrame.ZIndex = 10
	Notification.rootFrame = rootFrame
	rootFrame.Parent = Notification.billboardGui
end
function Notification.Show(message)
	table.insert(Notification.list, 1, {message})
end

Notification.CreateCameraPart()

RunService.RenderStepped:connect(function()
	Notification.Animate()
end)
Camera.Changed:connect(function()
	Notification.Animate()
end)
]=])
Module.Create("PyramidCharacter", [[
local stock_triangle = Instance.new("WedgePart")
stock_triangle.Anchored = true
stock_triangle.BottomSurface = "Smooth"
stock_triangle.FormFactor = "Custom"
stock_triangle.Locked = true
stock_triangle.TopSurface = "Smooth"
local stock_triangle_mesh = Instance.new("SpecialMesh", stock_triangle)
stock_triangle_mesh.MeshType = "Wedge"
local triangles = {}
function PyramidCharacter.CreateTriangle(v1, v2, v3, properties, parent, index)
	local triangleInfo = triangles[index]
	local side1 = (v1 - v2).magnitude
	local side2 = (v2 - v3).magnitude
	local side3 = (v3 - v1).magnitude
	local sqrside1 = side1 * side1
	local sqrside2 = side2 * side2
	local sqrside3 = side3 * side3
	if sqrside3 + sqrside1 == sqrside2 then
		v1, v2, v3 = v1, v2, v3
	elseif sqrside1 + sqrside2 == sqrside3 then
		v1, v2, v3 = v2, v3, v1
	elseif sqrside2 + sqrside3 == sqrside1 then
		v1, v2, v3 = v3, v1, v2
	elseif sqrside1 >= sqrside2 and sqrside1 >= sqrside3 then
		v1, v2, v3 = v1, v2, v3
	elseif sqrside2 >= sqrside3 and sqrside2 >= sqrside1 then
		v1, v2, v3 = v2, v3, v1
	else
		v1, v2, v3 = v3, v1, v2
	end
	local model, part1, part2, mesh1, mesh2
	if triangleInfo then
		model, part1, part2, mesh1, mesh2 = unpack(triangleInfo)
		if not (model.Parent == parent and part1.Parent == model and part2.Parent == model and mesh1.Parent == part1 and mesh2.Parent == part2) then
			if model.Parent then
				model:Destroy()
			end			
			model = nil
		end
	else
		triangleInfo = {}
		triangles[index] = triangleInfo
	end
	if not model then
		model = Instance.new("Model")
		part1 = stock_triangle:Clone()
		part2 = stock_triangle:Clone()
		mesh1 = part1.Mesh
		mesh2 = part2.Mesh
		part1.Parent = model
		part2.Parent = model
		triangleInfo[1] = model
		triangleInfo[2] = part1
		triangleInfo[3] = part2
		triangleInfo[4] = mesh1
		triangleInfo[5] = mesh2
	end
	for key, value in pairs(properties) do
		part1[key] = value
		part2[key] = value
	end
	local cframe = CFrame.new(v1, v2)
	local relpos = cframe:pointToObjectSpace(v3)
	cframe = cframe * CFrame.fromEulerAnglesXYZ(0, 0, -math.atan2(relpos.x, relpos.y))
	local rel1 = cframe:pointToObjectSpace(v1)
	local rel2 = cframe:pointToObjectSpace(v2)
	local rel3 = cframe:pointToObjectSpace(v3)
	local height = rel3.y
	local width1 = rel3.z
	local width2 = rel2.z - rel3.z
	local relcenter1 = Vector3.new(0, height / 2, width1 / 2)
	local center1 = cframe:pointToWorldSpace(relcenter1)
	local relcenter2 = Vector3.new(0, height / 2, width2 / 2 + width1)
	local center2 = cframe:pointToWorldSpace(relcenter2)
	height = math.abs(height)
	width1 = math.abs(width1)
	width2 = math.abs(width2)
	if not part1.Anchored then
		part1.Anchored = true
	end
	part1.Size = Vector3.new(0.2, height, width1)
	part1.CFrame = cframe * CFrame.fromEulerAnglesXYZ(0, math.pi, 0) - cframe.p + center1	
	mesh1.Scale = Vector3.new(0, height / part1.Size.y, width1 / part1.Size.z)
	if not part2.Anchored then
		part2.Anchored = true
	end
	part2.Size = Vector3.new(0.2, height, width1)
	part2.CFrame = cframe - cframe.p + center2
	mesh2.Scale = Vector3.new(0, height / part1.Size.y, width2 / part2.Size.z)
	model.Parent = parent
	return model
end
PyramidCharacter.head_properties = {BrickColor = BrickColor.new(Color3.new(1, 1, 1)), Transparency = 0.5}
PyramidCharacter.head_radius = math.pi
PyramidCharacter.center = CFrame.new(0, 10, 0)
PyramidCharacter.point1 = Vector3.new()
PyramidCharacter.point2 = Vector3.new()
PyramidCharacter.point3 = Vector3.new()
PyramidCharacter.point4 = Vector3.new()
PyramidCharacter.core_mesh_scale = Vector3.new(0.833, 0.833, 0.833)
PyramidCharacter.visible = false
function PyramidCharacter.Teleport(location)
	PyramidCharacter.point1 = location
	PyramidCharacter.point2 = location
	PyramidCharacter.point3 = location
	PyramidCharacter.point4 = location
end
local stock_core = Instance.new("Part")
stock_core.Anchored = true
stock_core.BottomSurface = "Smooth"
stock_core.Color = Color3.new(1, 1, 1)
stock_core.FormFactor = "Custom"
stock_core.Locked = true
stock_core.Name = "CubePyramid"
stock_core.Size = Vector3.new(0.5, 0.5, 0.5)
stock_core.TopSurface = "Smooth"
PyramidCharacter.stock_core = stock_core
PyramidCharacter.core = stock_core:Clone()
PyramidCharacter.Archivable = false
PyramidCharacter.core_mesh = Instance.new("BlockMesh", core)
PyramidCharacter.core_lights = {}
PyramidCharacter.coreLightCount = 1
for index = 1, PyramidCharacter.coreLightCount do
	PyramidCharacter.core_lights[index] = Instance.new("PointLight", core)
end
PyramidCharacter.camera_distance = (Camera.Focus.p - Camera.CoordinateFrame.p).magnitude
PyramidCharacter.camera_position = Vector3.new()
Camera.Changed:connect(function(property)
	if PyramidCharacter.visible then
		if property == "CoordinateFrame" then
			local cframe, focus = Camera.CoordinateFrame, Camera.Focus
			local eventTime = time()
			local connection
			connection = Camera.Changed:connect(function()
				connection:disconnect()
				if eventTime == time() and Camera.Focus ~= focus then
					local camera_distance = PyramidCharacter.camera_distance
					Camera.Focus = Camera.CoordinateFrame * CFrame.new(0, 0, -camera_distance)
					PyramidCharacter.camera_position = (Camera.CoordinateFrame * CFrame.new(0, 0, -camera_distance)).p
				end
			end)
			coroutine.yield()
			if Camera.Focus == focus then
				PyramidCharacter.camera_distance = (focus.p - cframe.p).magnitude
			else
				local camera_distance = PyramidCharacter.camera_distance
				Camera.Focus = Camera.CoordinateFrame * CFrame.new(0, 0, -camera_distance)
				PyramidCharacter.camera_position = (Camera.CoordinateFrame * CFrame.new(0, 0, -camera_distance)).p
			end
			if connection.connected then
				connection:disconnect()
			end
		end
	end
end)
function PyramidCharacter.Animate()
	local total_time = time()
	local core = PyramidCharacter.core
	local frame = PyramidCharacter.frame
	if PyramidCharacter.visible then
		local core_mesh = PyramidCharacter.core_mesh
		local core_lights = PyramidCharacter.core_lights
		if not frame or frame.Parent ~= core then
			frame = Instance.new("Model")
			frame.Archivable = false
			frame.Parent = core
			PyramidCharacter.frame = frame
		end
		if core.Parent ~= Workspace then
			core = PyramidCharacter.stock_core:Clone()
			PyramidCharacter.core = core
			core.Archivable = false
			core.Parent = Workspace
			Network.TransmitServer("chatAdornee = ...", core)
		end
		if core_mesh.Parent ~= core then
			core_mesh = Instance.new("BlockMesh", core)
			PyramidCharacter.core_mesh = core_mesh
		end
		for index, core_light in ipairs(core_lights) do
			if core_light.Parent ~= core then
				core_light = Instance.new("PointLight", core)
				core_lights[index] = core_light
			end
			local vertexColor = Vector3.new(Utility.GetRainbowRGB(total_time)) * 0.25 + Vector3.new(1, 1, 1) * 0.75
			core_light.Color = Color3.new(vertexColor.X, vertexColor.Y, vertexColor.Z)
			core_light.Brightness = 0.85 + 0.15 * math.random()
			if core_light.Range ~= 30 then
				core_light.Range = 30
			end
			if not core_light.Shadows then
				core_light.Shadows = true
			end
		end
		if core_mesh.Offset ~= Vector3.new(0, 0, 0) then
			core_mesh.Offset = Vector3.new(0, 0, 0)
		end
		if not core.Anchored then
			core.Anchored = true
		end
		if core.Transparency ~= 0 then
			core.Transparency = 0
		end
		local core_mesh_scale = PyramidCharacter.core_mesh_scale
		local transition_speed = (math.sin(total_time * math.tau) + 1) / 16
		core_mesh_scale = core_mesh_scale * (1 - transition_speed) + Vector3.new(math.random() * 0.5 + 0.5, math.random() * 0.5 + 0.5, math.random() 

* 0.5 + 0.5) * transition_speed
		core_mesh.Scale = core_mesh_scale * 2
		local center = CFrame.new(PyramidCharacter.camera_position) * CFrame.Angles(0, total_time * math.tau, 0)
		local cframe1 = CFrame.new(PyramidCharacter.head_radius, 0, 0)
		local cframe2 = CFrame.Angles(math.tau / -3, 0, 0)
		local cframe3 = CFrame.Angles(0, math.tau / 3, 0)
		local cframe4 = center * cframe3		
		local desired1 = center * CFrame.new(0, PyramidCharacter.head_radius, 0)
		local desired2 = center * cframe2 * cframe1
		local desired3 = cframe4 * cframe2 * cframe1
		local desired4 = cframe4 * cframe3 * cframe2 * cframe1
		local point1 = (PyramidCharacter.point1 * 3 + desired1.p) / 4
		local point2 = (PyramidCharacter.point2 * 3 + desired2.p) / 4
		local point3 = (PyramidCharacter.point3 * 3 + desired3.p) / 4
		local point4 = (PyramidCharacter.point4 * 3 + desired4.p) / 4
		PyramidCharacter.point1 = point1
		PyramidCharacter.point2 = point2
		PyramidCharacter.point3 = point3
		PyramidCharacter.point4 = point4
		local head_properties = PyramidCharacter.head_properties
		PyramidCharacter.CreateTriangle(point1, point2, point3, head_properties, frame, 1).Archivable = false
		PyramidCharacter.CreateTriangle(point2, point3, point4, head_properties, frame, 2).Archivable = false
		PyramidCharacter.CreateTriangle(point3, point4, point1, head_properties, frame, 3).Archivable = false
		PyramidCharacter.CreateTriangle(point4, point1, point2, head_properties, frame, 4).Archivable = false
		core.CFrame = CFrame.new((point1 + point2 + point3 + point4) / 4) * CFrame.Angles(total_time * math.tau, total_time * math.tau / 2, 

total_time * math.tau / 3)
		PyramidCharacter.center = center
	else
		if core.Parent then
			core:Destroy()
		end
		if frame and frame.Parent then
			frame:Destroy()
		end
		PyramidCharacter.frame = nil
	end
end
function PyramidCharacter.MainLoop()
	PyramidCharacter.Animate()
	RunService.Stepped:wait()
end
TaskScheduler.Start(function()
	while true do
		PyramidCharacter.MainLoop()
	end
end)
]])
Module.Create("CharacterAppearance", [[
CharacterAppearance.defaultAppearanceId = 3
CharacterAppearance.stock = {}
function CharacterAppearance.Create(properties)
	local id = properties.Id
	local bodyColors = Instance.new("BodyColors")
	bodyColors.HeadColor = properties.HeadColor
	bodyColors.TorsoColor = properties.TorsoColor
	bodyColors.RightArmColor = properties.RightArmColor
	bodyColors.LeftArmColor = properties.LeftArmColor
	bodyColors.RightLegColor = properties.RightLegColor
	bodyColors.LeftLegColor = properties.LeftLegColor
	local characterObjects = {bodyColors}
	local headObjects = {}	
	local data = {
		characterObjects = characterObjects,
		headObjects = headObjects,
		tshirt = properties.TShirt
	}
	for _, assetId in ipairs(properties.CharacterAssets) do
		TaskScheduler.Start(CharacterAppearance.LoadAsset, characterObjects, assetId)
	end
	for _, assetId in ipairs(properties.HeadAssets) do
		TaskScheduler.Start(CharacterAppearance.LoadAsset, headObjects, assetId)
	end
	CharacterAppearance.stock[id] = data
end
function CharacterAppearance.GetDefaultAppearance()
	return CharacterAppearance.stock[CharacterAppearance.defaultAppearanceId]
end
function CharacterAppearance.LoadAsset(objects, assetId)
	local asset = InsertService:LoadAsset(assetId)
	for _, child in ipairs(asset:GetChildren()) do
		child.Archivable = true
		table.insert(objects, child:Clone())
	end
end
CharacterAppearance.Create {
	Id = 1,
	HeadColor = BrickColor.new("Institutional white"),
	TorsoColor = BrickColor.new("Institutional white"),
	RightArmColor = BrickColor.new("Institutional white"),
	LeftArmColor = BrickColor.new("Institutional white"),
	RightLegColor = BrickColor.new("Institutional white"),
	LeftLegColor = BrickColor.new("Institutional white"),
	CharacterAssets = {
		90825058, 90825211,
		27112056, 27112052,
		27112039, 27112025,
		27112068, 38322996
	},
	HeadAssets = {
		20722130,
		8330576
	}
}
CharacterAppearance.Create {
	Id = 2,
	HeadColor = BrickColor.new("Institutional white"),
	TorsoColor = BrickColor.new("Institutional white"),
	RightArmColor = BrickColor.new("Institutional white"),
	LeftArmColor = BrickColor.new("Institutional white"),
	RightLegColor = BrickColor.new("Institutional white"),
	LeftLegColor = BrickColor.new("Institutional white"),
	CharacterAssets = {
		90825058, 90825211,
		11748356, 1029025,
		1235488, 27112056,
		27112052, 27112039,
		27112025, 27112068
	},
	HeadAssets = {
		20722130
	}
}
CharacterAppearance.Create {
	Id = 3,
	HeadColor = BrickColor.new("Pastel brown"),
	TorsoColor = BrickColor.new("Pastel brown"),
	RightArmColor = BrickColor.new("Pastel brown"),
	LeftArmColor = BrickColor.new("Pastel brown"),
	RightLegColor = BrickColor.new("White"),
	LeftLegColor = BrickColor.new("White"),
	CharacterAssets = {
		134289125, 48474356,
		100339040, 46302558,
		153955895
	},
	HeadAssets = {},
	TShirt = "rbxassetid://148856353"
}
]])
Module.Create("PlayerControl", [[
PlayerControl.fly_acceleration = 10
PlayerControl.fly_basespeed = 250
PlayerControl.fly_speed = PlayerControl.fly_basespeed
PlayerControl.featherfallEnabled = true
PlayerControl.pushable = false
PlayerControl.rolling = false
PlayerControl.rollingAngle = 0
PlayerControl.rollingOffset = 0
PlayerControl.rollingMaxOffset = 3
PlayerControl.rollingSpeed = 1 / 50
PlayerControl.characterEnabled = false
PlayerControl.characterMode = "normal"
local character = nil
local flying, flyingMomentum, flyingTilt = false, Vector3.new(), 0
local pose, regeneratingHealth, jumpDebounce = "Standing", false, false
-- TODO: make local variables public
local model, bodyColors, leftArmMesh, leftLegMesh, rightArmMesh, rightLegMesh, torsoMesh, wildcardHat, wildcardHandle, wildcardMesh, pants, shirt, humanoid, 

head, leftArm, leftLeg, rightArm, rightLeg, torso, rootPart, rootJoint, face, soundFreeFalling, soundGettingUp, soundRunning, leftHip, leftShoulder, 

rightHip, rightShoulder, neck, wildcardWeld, feetPart, feetWeld, feetTouchInterest, bodyGyro, bodyVelocity, headMesh, torsoLight
local AnimateCharacter
local chatBubbles = {}
local chatCharacterLimit = 240
function PlayerControl.Chat(message)
	Network.TransmitServer(string.format("ChatBubble.Create(%q)", tostring(message)))
end
function PlayerControl.CreateCharacter()
	local characterMode = PlayerControl.characterMode
	if characterMode == "normal" then
		if not PlayerControl.characterEnabled then
			return
		end
		local appearance = CharacterAppearance.GetDefaultAppearance()
		local active = true
		local torsoCFrame = (torso and torso.CFrame) or PlayerControl.torso_cframe or CFrame.new(0, 10, 0)
		if torsoCFrame.p.Y < -450 then
			torsoCFrame = CFrame.new(0, 10, 0)
		end
		local rootPartCFrame = (rootPart and rootPart.CFrame) or PlayerControl.torso_cframe or CFrame.new(0, 10, 0)
		if rootPartCFrame.p.Y < -450 then
			rootPartCFrame = CFrame.new(0, 10, 0)
		end
		local cameraCFrame = Camera.CoordinateFrame
		local connections = {}
		local feetTouching = {}
		local previousWalkSpeed = 0
		local prevLeftHip, prevLeftShoulder, prevRightHip, prevRightShoulder = leftHip, leftShoulder, rightHip, rightShoulder
		model = Instance.new("Model")
		humanoid = Instance.new("Humanoid", model)
		head = Instance.new("Part", model)
		leftArm = Instance.new("Part", model)
		leftLeg = Instance.new("Part", model)
		rightArm = Instance.new("Part", model)
		rightLeg = Instance.new("Part", model)
		torso = Instance.new("Part", model)
		rootPart = Instance.new("Part", model)
		soundFallingDown = Instance.new("Sound", head)
		soundFreeFalling = Instance.new("Sound", head)
		soundGettingUp = Instance.new("Sound", head)
		soundJumping = Instance.new("Sound", head)
		soundRunning = Instance.new("Sound", head)
		leftHip = Instance.new("Motor", torso)
		leftShoulder = Instance.new("Motor", torso)
		rightHip = Instance.new("Motor", torso)
		rightShoulder = Instance.new("Motor", torso)
		neck = Instance.new("Motor", torso)
		rootJoint = Instance.new("Motor", rootPart)
		feetPart = Instance.new("Part", model)
		feetWeld = Instance.new("Weld", torso)
		bodyGyro = Instance.new("BodyGyro", rootPart)
		bodyVelocity = Instance.new("BodyVelocity", rootPart)
		model.Archivable = false
		model.Name = UserInterface.player_name
		model.PrimaryPart = head
		humanoid.LeftLeg = leftLeg
		humanoid.RightLeg = rightLeg
		humanoid.Torso = rootPart
		head.CFrame = torsoCFrame * CFrame.new(0, 1.5, 0)
		head.FormFactor = "Symmetric"
		head.Locked = true
		head.Name = "Head"
		head.Size = Vector3.new(2, 1, 1)
		head.TopSurface = "Smooth"
		leftArm.CanCollide = false
		leftArm.CFrame = torsoCFrame * CFrame.new(-1.5, 0, 0)
		leftArm.FormFactor = "Symmetric"
		leftArm.Locked = true
		leftArm.Name = "Left Arm"
		leftArm.Size = Vector3.new(1, 2, 1)
		leftLeg.BottomSurface = "Smooth"
		leftLeg.CanCollide = false
		leftLeg.CFrame = torsoCFrame * CFrame.new(-0.5, -2, 0)
		leftLeg.FormFactor = "Symmetric"
		leftLeg.Locked = true
		leftLeg.Name = "Left Leg"
		leftLeg.Size = Vector3.new(1, 2, 1)
		leftLeg.TopSurface = "Smooth"
		rightArm.CanCollide = false
		rightArm.CFrame = torsoCFrame * CFrame.new(1.5, 0, 0)
		rightArm.FormFactor = "Symmetric"
		rightArm.Locked = true
		rightArm.Name = "Right Arm"
		rightArm.Size = Vector3.new(1, 2, 1)
		rightLeg.BottomSurface = "Smooth"
		rightLeg.CanCollide = false
		rightLeg.CFrame = torsoCFrame * CFrame.new(0.5, -2, 0)
		rightLeg.FormFactor = "Symmetric"
		rightLeg.Locked = true
		rightLeg.Name = "Right Leg"
		rightLeg.Size = Vector3.new(1, 2, 1)
		rightLeg.TopSurface = "Smooth"
		torso.CFrame = torsoCFrame
		torso.FormFactor = "Symmetric"
		torso.LeftSurface = "Weld"
		torso.Locked = true
		torso.RightSurface = "Weld"
		torso.Name = "Torso"
		torso.Size = Vector3.new(2, 2, 1)
		rootPart.BottomSurface = "Smooth"
		rootPart.BrickColor = BrickColor.Blue()
		rootPart.CFrame = rootPartCFrame
		rootPart.FormFactor = "Symmetric"
		rootPart.LeftSurface = "Weld"
		rootPart.Locked = true
		rootPart.RightSurface = "Weld"
		rootPart.Name = "HumanoidRootPart"
		rootPart.Size = Vector3.new(2, 2, 1)
		rootPart.TopSurface = "Smooth"
		rootPart.Transparency = 1
		soundFreeFalling.Archivable = false
		soundFreeFalling.SoundId = "rbxasset://sounds/swoosh.wav"
		soundGettingUp.Archivable = false
		soundGettingUp.SoundId = "rbxasset://sounds/hit.wav"
		soundRunning.Archivable = false
		soundRunning.SoundId = "rbxasset://sounds/bfsl-minifigfoots1.mp3"
		soundRunning.Looped = true
		leftHip.C0 = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
		leftHip.C1 = CFrame.new(-0.5, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
		leftHip.MaxVelocity = 0.1
		leftHip.Name = "Left Hip"
		leftHip.Part0 = torso
		leftHip.Part1 = leftLeg
		leftShoulder.C0 = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
		leftShoulder.C1 = CFrame.new(0.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
		leftShoulder.MaxVelocity = 0.15
		leftShoulder.Name = "Left Shoulder"
		leftShoulder.Part0 = torso
		leftShoulder.Part1 = leftArm
		rightHip.C0 = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
		rightHip.C1 = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
		rightHip.MaxVelocity = 0.1
		rightHip.Name = "Right Hip"
		rightHip.Part0 = torso
		rightHip.Part1 = rightLeg
		rightShoulder.C0 = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
		rightShoulder.C1 = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
		rightShoulder.MaxVelocity = 0.15
		rightShoulder.Name = "Right Shoulder"
		rightShoulder.Part0 = torso
		rightShoulder.Part1 = rightArm
		if prevLeftHip then
			leftHip.CurrentAngle = prevLeftHip.CurrentAngle
			leftHip.DesiredAngle = prevLeftHip.DesiredAngle
		end
		if prevLeftShoulder then
			leftShoulder.CurrentAngle = prevLeftShoulder.CurrentAngle
			leftShoulder.DesiredAngle = prevLeftShoulder.DesiredAngle
		end
		if prevRightHip then
			rightHip.CurrentAngle = prevRightHip.CurrentAngle
			rightHip.DesiredAngle = prevRightHip.DesiredAngle
		end
		if prevRightShoulder then
			rightShoulder.CurrentAngle = prevRightShoulder.CurrentAngle
			rightShoulder.DesiredAngle = prevRightShoulder.DesiredAngle
		end
		neck.C0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		neck.C1 = CFrame.new(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		neck.Name = "Neck"
		neck.Part0 = torso
		neck.Part1 = head
		rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		rootJoint.C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		rootJoint.Name = "RootJoint"
		rootJoint.Part0 = rootPart
		rootJoint.Part1 = torso
		feetPart.BottomSurface = "Smooth"
		feetPart.CanCollide = false
		feetPart.CFrame = torsoCFrame * CFrame.new(0, -3.1, 0)
		feetPart.FormFactor = "Custom"
		feetPart.Locked = true
		feetPart.Name = "Platform"
		feetPart.Size = Vector3.new(1.8, 0.2, 0.8)
		feetPart.TopSurface = "Smooth"
		feetPart.Transparency = 1
		feetWeld.C0 = CFrame.new(0, -3, 0)
		feetWeld.C1 = CFrame.new(0, 0.1, 0)
		feetWeld.Name = "PlatformWeld"
		feetWeld.Part0 = torso
		feetWeld.Part1 = feetPart
		table.insert(connections, feetPart.Touched:connect(function(hit)
			feetTouching[hit] = true
		end))
		table.insert(connections, feetPart.TouchEnded:connect(function(hit)
			feetTouching[hit] = nil
		end))
		feetTouchInterest = feetPart:FindFirstChild("TouchInterest")
		bodyGyro.D = 3250
		bodyGyro.P = 400000
		bodyGyro.maxTorque = Vector3.new(1000000000, 0, 1000000000)
		bodyVelocity.P = 5000
		bodyVelocity.maxForce = Vector3.new(0, 0, 0)
		bodyVelocity.velocity = Vector3.new(0, 0, 0)
		torsoLight = Instance.new("PointLight", torso)
		torsoLight.Brightness = 0.4
		torsoLight.Color = Color3.new(1, 1, 1)
		torsoLight.Range = 16
		torsoLight.Shadows = true
		local ff1, ff2, ff3, ff4, ff5, ff6, ff7, ff8, ff9 = Instance.new("ForceField", head), Instance.new("ForceField", leftArm), Instance.new

("ForceField", leftLeg), Instance.new("ForceField", rightArm), Instance.new("ForceField", rightLeg), Instance.new("ForceField", torso), Instance.new

("ForceField", wildcardHandle), Instance.new("ForceField", feetPart), Instance.new("ForceField", rootPart)
		local forcefields = {[ff1] = head, [ff2] = leftArm, [ff3] = leftLeg, [ff4] = rightArm, [ff5] = rightLeg, [ff6] = torso, [ff7] = 

wildcardHandle, [ff8] = feetPart, [ff9] = rootPart}	
		local objects = {[humanoid] = true, [head] = true, [leftArm] = true, [leftLeg] = true, [rightArm] = true, [rightLeg] = true, [torso] = true, 

[rootPart] = true, [rootJoint] = true, [soundFreeFalling] = true, [soundGettingUp] = true, [soundRunning] = true, [leftHip] = true, [leftShoulder] = true, 

[rightHip] = true, [rightShoulder] = true, [neck] = true, [feetPart] = true, [feetWeld] = true, [feetTouchInterest] = true, [bodyGyro] = true, 

[bodyVelocity] = true, [ff1] = true, [ff2] = true, [ff3] = true, [ff4] = true, [ff5] = true, [ff6] = true, [ff7] = true, [ff8] = true, [ff9] = true}		
		local tshirtUrl = appearance.tshirt
		if tshirtUrl then
			local tshirt = Instance.new("Decal", torso)
			tshirt.Name = "roblox"
			tshirt.Texture = tshirtUrl
			objects[tshirt] = true
		end
		for _, template in ipairs(appearance.characterObjects) do
			local object = template:Clone()
			local newObjects = {object}
			for _, object in ipairs(newObjects) do
				objects[object] = true
				for _, child in ipairs(object:GetChildren()) do
					table.insert(newObjects, child)
				end				
			end
			if object:IsA("BodyColors") then
				head.BrickColor = object.HeadColor
				leftArm.BrickColor = object.LeftArmColor
				leftLeg.BrickColor = object.LeftLegColor
				rightArm.BrickColor = object.RightArmColor
				rightLeg.BrickColor = object.RightLegColor
				torso.BrickColor = object.TorsoColor
			elseif object:IsA("Hat") then
				local handle = object:FindFirstChild("Handle")
				if handle and handle:IsA("BasePart") then
					local weld = Instance.new("Weld", head)
					weld.C0 = CFrame.new(0, 0.5, 0)
					local attachmentPos = object.AttachmentPos
					local attachmentRight = object.AttachmentRight
					local attachmentUp = object.AttachmentUp
					local attachmentForward = object.AttachmentForward
					weld.C1 = CFrame.new(attachmentPos.X, attachmentPos.Y, attachmentPos.Z,
										 attachmentRight.X, attachmentUp.X, -attachmentForward.X,
										 attachmentRight.Y, attachmentUp.Y, -attachmentForward.Y,
										 attachmentRight.Z, attachmentUp.Z, -attachmentForward.Z)
					weld.Name = "HeadWeld"
					weld.Part0 = head
					weld.Part1 = handle
					handle.Parent = model
					local antiGravity = Instance.new("BodyForce", handle)
					antiGravity.force = Vector3.new(0, handle:GetMass() * 196.2, 0)
					objects[object] = false
					object.Parent = nil
					objects[weld] = true
				end
			end
			object.Parent = model
		end
		local facePresent = false
		local headMeshPresent = false
		for _, template in ipairs(appearance.headObjects) do
			local object = template:Clone()
			local newObjects = {object}
			for _, object in ipairs(newObjects) do
				objects[object] = true
				for _, child in ipairs(object:GetChildren()) do
					table.insert(newObjects, child)
				end				
			end
			if object:IsA("DataModelMesh") then
				headMeshPresent = true
			elseif object:IsA("Decal") then
				facePresent = true
			end
			object.Parent = head
		end
		if not facePresent then
			local face = Instance.new("Decal", head)
			face.Texture = "rbxasset://textures/face.png"
			objects[face] = true
		end
		if not headMeshPresent then
			local headMesh = Instance.new("SpecialMesh", head)
			headMesh.Scale = Vector3.new(1.25, 1.25, 1.25)
			objects[headMesh] = true
		end
		table.insert(connections, model.DescendantAdded:connect(function(object)
			local success, is_localscript = pcall(Game.IsA, object, "LocalScript")
			if success and is_localscript then
				pcall(Utility.SetProperty, object, "Disabled", true)
				local changed_connection = pcall(object.Changed.connect, object.Changed, function(property)
					if property == "Disabled" and not object.Disabled then
						pcall(Utility.SetProperty, object, "Disabled", true)
						Network.TransmitServer("(...):Destroy()", object)
					end
				end)
			end
			if not objects[object] then
				Network.TransmitServer("(...):Destroy()", object)
			end
		end))
		model.Parent = Workspace
		Player.Character = model
		Camera.CameraSubject = humanoid
		Camera.CameraType = "Track"
		Camera.CoordinateFrame = cameraCFrame
		local IsStanding
		local RegenerateHealth
		local ResetCharacter
		function IsStanding()
			return not not next(feetTouching)
		end
		function RegenerateHealth()
			if humanoid.Health < 1 then
				humanoid.Health = 100
			elseif not regeneratingHealth then
				regeneratingHealth = true
				local elapsedTime = wait(1)
				regeneratingHealth = false
				if humanoid.Health < 100 then
					humanoid.Health = math.min(humanoid.Health + elapsedTime, 100)
				end
			end
		end
		function ResetCharacter()
			for index, connection in ipairs(connections) do
				connection:disconnect()
			end
			active = false
		end
		table.insert(connections, model.AncestryChanged:connect(ResetCharacter))
		table.insert(connections, model.DescendantRemoving:connect(function(object)
			local parent = forcefields[object]
			if parent then
				forcefields[object] = nil
				local new_forcefield = Instance.new("ForceField")
				forcefields[new_forcefield] = parent
				objects[new_forcefield] = true
				new_forcefield.Parent = parent
			elseif objects[object] then
				ResetCharacter()
			end
		end))
		table.insert(connections, humanoid.HealthChanged:connect(RegenerateHealth))
		table.insert(connections, humanoid.Climbing:connect(function() pose = "Climbing" end))
		table.insert(connections, humanoid.FallingDown:connect(function(state)  pose = "FallingDown" end))
		table.insert(connections, humanoid.FreeFalling:connect(function(state) pose = "FreeFall" if state then soundFreeFalling:Play() else 

soundFreeFalling:Pause() end end))
		table.insert(connections, humanoid.GettingUp:connect(function(state) pose = "GettingUp" if state then soundGettingUp:Play() else 

soundGettingUp:Pause() end end))
		table.insert(connections, humanoid.PlatformStanding:connect(function() pose = "PlatformStanding" end))
		table.insert(connections, humanoid.Seated:connect(function() pose = "Seated" end))
		table.insert(connections, humanoid.Swimming:connect(function(speed) if speed > 0 then pose = "Swimming" else pose = "Standing" end end))
		local previousRootPartCFrame = rootPart.CFrame
		TaskScheduler.Start(function()
			while active do
				local totalTime = TaskScheduler.GetCurrentTime()
				local stepTime = 1 / 60
				if not PlayerControl.characterEnabled then
					ResetCharacter()
					break
				end
				torsoLight.Brightness = 0.5 + 0.15 * math.sin(totalTime * 0.75 * math.pi)
				local featherfallEnabled = PlayerControl.IsFeatherfallEnabled()
				local rootPartCFrame = rootPart.CFrame
				if not jumpDebounce and UserInterface.IsKeyDown(" ") then
					if humanoid.Sit then
						humanoid.Sit = false
					end
					if IsStanding() then
						jumpDebounce = true
						pose = "Jumping"
						rootPart.Velocity = Vector3.new(rootPart.Velocity.X, 50, rootPart.Velocity.Z)
						torso.Velocity = Vector3.new(torso.Velocity.X, 50, torso.Velocity.Z)						
						TaskScheduler.Schedule(1, function()
							if pose == "Jumping" then
								pose = "FreeFall"
							end
							jumpDebounce = false
							humanoid.Jump = false
						end)
					end
				end
				local cameraCFrame = Camera.CoordinateFrame
				local cameraDirection = cameraCFrame.lookVector
				if flying then
					if PlayerControl.rolling then
						local rootPartCFrame = rootPart.CFrame
						local speed = (rootPartCFrame - rootPartCFrame.p):pointToObjectSpace(rootPart.Velocity).Y
						local decay = 0.5 ^ stepTime
						if math.abs(speed) <= 50 then
							PlayerControl.rollingAngle = (((PlayerControl.rollingAngle + 0.5) % 1 - 0.5) * decay) % 1
							PlayerControl.rollingOffset = PlayerControl.rollingOffset * decay
						else
							PlayerControl.rollingAngle = (PlayerControl.rollingAngle + stepTime * speed * 

PlayerControl.rollingSpeed) % 1
							PlayerControl.rollingOffset = (PlayerControl.rollingOffset + PlayerControl.rollingMaxOffset * (1 / 

decay - 1)) * decay
						end
						rootJoint.C0 = (CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0) * CFrame.Angles(PlayerControl.rollingAngle * 

2 * math.pi, 0, 0)) * CFrame.new(0, -PlayerControl.rollingOffset, 0)
					else
						rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
						PlayerControl.rollingAngle = 0
						PlayerControl.rollingOffset = 0
					end
					rightShoulder.MaxVelocity = 0.5
					leftShoulder.MaxVelocity = 0.5
					rightShoulder.DesiredAngle = 0
					leftShoulder.DesiredAngle = 0
					rightHip.DesiredAngle = 0
					leftHip.DesiredAngle = 0
					bodyGyro.D = 500
					bodyGyro.P = 1e6
					bodyGyro.maxTorque = Vector3.new(1e6, 1e6, 1e6)
					bodyVelocity.P = 1250
					bodyVelocity.maxForce = Vector3.new(1e6, 1e6, 1e6)
					local movementRight = 0
					local movementForward = 0
					local movementUp = 0
					if UserInterface.IsKeyDown("a") and not UserInterface.IsKeyDown("d") then
						movementRight = -1
					elseif UserInterface.IsKeyDown("d") then
						movementRight = 1
					end
					if UserInterface.IsKeyDown("w") then
						movementUp = 0.2
						if not UserInterface.IsKeyDown("s") then
							movementForward = -1
						end
					elseif UserInterface.IsKeyDown("s") then
						movementForward = 1
					end
					local movement = PlayerControl.fly_acceleration * cameraCFrame:vectorToWorldSpace(Vector3.new(movementRight, 

movmentUp, movementForward))
					local previousMomentum = flyingMomentum
					local previousTilt = flyingTilt
					flyingMomentum = movement + flyingMomentum * (1 - PlayerControl.fly_acceleration / PlayerControl.fly_speed)
					flyingTilt = ((flyingMomentum * Vector3.new(1, 0, 1)).unit:Cross((previousMomentum * Vector3.new(1, 0, 1)).unit)).Y
					if flyingTilt ~= flyingTilt or flyingTilt == math.huge then
						flyingTilt = 0
					end
					local absoluteTilt = math.abs(flyingTilt)
					if absoluteTilt > 0.06 or absoluteTilt < 0.0001 then
						if math.abs(previousTilt) > 0.0001 then
							flyingTilt = previousTilt * 0.9
						else
							flyingTilt = 0
						end
					else
						flyingTilt = previousTilt * 0.77 + flyingTilt * 0.25
					end
					previousTilt = flyingTilt
					if flyingMomentum.magnitude < 0.1 then
						flyingMomentum = Vector3.new(0, 0, 0)
--						bodyGyro.cframe = cameraCFrame
					else
						local momentumOrientation = CFrame.new(Vector3.new(0, 0, 0), flyingMomentum)
						local tiltOrientation = CFrame.Angles(0, 0, -20 * flyingTilt)
						bodyGyro.cframe = momentumOrientation * tiltOrientation * CFrame.Angles(-0.5 * math.pi * math.min

(flyingMomentum.magnitude / PlayerControl.fly_speed, 1), 0, 0)
					end
					bodyVelocity.velocity = flyingMomentum + Vector3.new(0, 0.15695775618683547, 0)
					rootPart.Velocity = flyingMomentum
					previousMomentum = flyingMomentum
				else
					rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
					PlayerControl.rollingAngle = 0
					PlayerControl.rollingOffset = 0
					bodyGyro.D = 3250
					bodyGyro.P = 400000
					bodyVelocity.P = 5000
					local cameraDirection = cameraCFrame.lookVector
					local walkDirection = Vector3.new(0, 0, 0)
					local walkSpeed = 16
					if UserInterface.IsKeyDown("w") or UserInterface.IsKeyDown("\17") then
						if UserInterface.IsKeyDown("a") then
							walkDirection = Vector3.new(cameraDirection.X + cameraDirection.Z, 0, cameraDirection.Z - 

cameraDirection.X).unit
						elseif UserInterface.IsKeyDown("d") then
							walkDirection = Vector3.new(cameraDirection.X - cameraDirection.Z, 0, cameraDirection.Z + 

cameraDirection.X).unit
						else
							walkDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).unit
						end
					elseif UserInterface.IsKeyDown("s") or UserInterface.IsKeyDown("\18") then
						if UserInterface.IsKeyDown("a") then
							walkDirection = Vector3.new(-cameraDirection.X + cameraDirection.Z, 0, -cameraDirection.Z - 

cameraDirection.X).unit
						elseif UserInterface.IsKeyDown("d") then
							walkDirection = Vector3.new(-cameraDirection.X - cameraDirection.Z, 0, -cameraDirection.Z + 

cameraDirection.X).unit
						else
							walkDirection = Vector3.new(-cameraDirection.X, 0, -cameraDirection.Z).unit
						end
					elseif UserInterface.IsKeyDown("a") then
						walkDirection = Vector3.new(cameraDirection.Z, 0, -cameraDirection.X).unit
					elseif UserInterface.IsKeyDown("d") then
						walkDirection = Vector3.new(-cameraDirection.Z, 0, cameraDirection.X).unit
					else
						walkSpeed = 0
					end
					if walkSpeed ~= previousWalkSpeed then
						if walkSpeed > 0 then
							soundRunning:Play()
						else
							soundRunning:Pause()
						end
					end
					if walkSpeed > 0 then
						if pose ~= "Jumping" then
							if IsStanding() then
								pose = "Running"
							else
								pose = "FreeFall"
							end
						end
						bodyGyro.cframe = CFrame.new(Vector3.new(), walkDirection)
						bodyGyro.maxTorque = Vector3.new(1000000000, 1000000000, 1000000000)
						bodyVelocity.maxForce = Vector3.new(1000000, maxForceY, 1000000)
					else
						if pose ~= "Jumping" then
							if IsStanding() then
								pose = "Standing"
							else
								pose = "FreeFall"
							end
						end
						-- TODO: find and fix bug that causes torso to rotate back to some angle
						bodyGyro.maxTorque = Vector3.new(1000000000, 1000000000, 1000000000) -- Vector3.new(1000000000, 0, 

1000000000)
						if PlayerControl.pushable then
							bodyVelocity.maxForce = Vector3.new(0, 0, 0)
						else
							bodyVelocity.maxForce = Vector3.new(1000000, 0, 1000000)
						end
					end
					if featherfallEnabled then
						local velocity = rootPart.Velocity
						if velocity.Y > 50 then
							rootPart.Velocity = Vector3.new(velocity.X, 50, velocity.Z)
						elseif velocity.Y < -50 then
							rootPart.Velocity = Vector3.new(velocity.X, -50, velocity.Z)
						end
						local distanceVector = rootPartCFrame.p - previousRootPartCFrame.p
						local offsetX, offsetY, offsetZ = distanceVector.X, distanceVector.Y, distanceVector.Z
						local MAX_MOVEMENT = 50 * 0.03333333507180214
						if offsetX > MAX_MOVEMENT then
							offsetX = MAX_MOVEMENT
						elseif offsetX < -MAX_MOVEMENT then
							offsetX = -MAX_MOVEMENT
						end
						if offsetY > MAX_MOVEMENT then
							offsetY = MAX_MOVEMENT
						elseif offsetY < -MAX_MOVEMENT then
							offsetY = -MAX_MOVEMENT
						end
						if offsetZ > MAX_MOVEMENT then
							offsetZ = MAX_MOVEMENT
						elseif offsetZ < -MAX_MOVEMENT then
							offsetZ = -MAX_MOVEMENT
						end
						local offset = Vector3.new(offsetX, offsetY, offsetZ)
						if offset ~= distanceVector then
							rootPartCFrame = previousRootPartCFrame + offset
							--rootPart.CFrame = rootPartCFrame
						end
					end
					local walkingVelocity = walkDirection * walkSpeed
					bodyVelocity.velocity = walkingVelocity
					if not jumpDebounce and math.abs(rootPart.Velocity.Y) <= 0.1 then
						rootPart.Velocity = Vector3.new(walkingVelocity.X, rootPart.Velocity.Y, walkingVelocity.Z)
					end
					previousWalkSpeed = walkSpeed
					if pose == "Jumping" or jumpDebounce then
						rightShoulder.MaxVelocity = 0.5
						leftShoulder.MaxVelocity = 0.5
						rightShoulder.DesiredAngle = 3.14
						leftShoulder.DesiredAngle = -3.14
						rightHip.DesiredAngle = 0
						leftHip.DesiredAngle = 0
					elseif pose == "FreeFall" then
						rightShoulder.MaxVelocity = 0.5
						leftShoulder.MaxVelocity = 0.5
						rightShoulder.DesiredAngle = 3.14
						leftShoulder.DesiredAngle = -3.14
						rightHip.DesiredAngle = 0
						leftHip.DesiredAngle = 0
					elseif pose == "Seated" then
						rightShoulder.MaxVelocity = 0.15
						leftShoulder.MaxVelocity = 0.15
						rightShoulder.DesiredAngle = 3.14 / 2
						leftShoulder.DesiredAngle = -3.14 / 2
						rightHip.DesiredAngle = 3.14 / 2
						leftHip.DesiredAngle = -3.14 / 2
					else
						local climbFudge = 0
						local amplitude
						local frequency
						if pose == "Running" then
							rightShoulder.MaxVelocity = 0.15
							leftShoulder.MaxVelocity = 0.15
							amplitude = 1
							frequency = 9
						elseif (pose == "Climbing") then
							rightShoulder.MaxVelocity = 0.5 
							leftShoulder.MaxVelocity = 0.5
							amplitude = 1
							frequency = 9
							climbFudge = 3.14
						else
							amplitude = 0.1
							frequency = 1
						end
						local desiredAngle = amplitude * math.sin(totalTime * frequency)
						rightShoulder.DesiredAngle = desiredAngle + climbFudge
						leftShoulder.DesiredAngle = desiredAngle - climbFudge
						rightHip.DesiredAngle = -desiredAngle
						leftHip.DesiredAngle = -desiredAngle
					end
				end
				previousRootPartCFrame = rootPartCFrame
				RunService.RenderStepped:wait()
			end
			if model.Parent ~= nil then
				model.Parent = nil
			end
			PlayerControl.CreateCharacter()
		end)
		humanoid.Health = 100
		character = model
		Network.TransmitServer("chatAdornee = ...", head)
	elseif characterMode == "pyramid" then
		if PlayerControl.characterEnabled then
			Camera.CameraType = "Fixed"
			PyramidCharacter.camera_distance = (Camera.Focus.p - Camera.CoordinateFrame.p).magnitude
			PyramidCharacter.camera_position = Camera.Focus.p
			PyramidCharacter.Teleport(Camera.Focus.p)
			PyramidCharacter.visible = true
			Player.Character = nil
		else
			PyramidCharacter.visible = false
		end
	end
end
function PlayerControl.GetCharacter()
	return character
end
function PlayerControl.GetHead()
	local characterMode = PlayerControl.characterMode
	if characterMode == "normal" then
		return head
	elseif characterMode == "pyramid" then
		return PyramidCharacter.core
	end
end
function PlayerControl.GetHumanoid()
	return humanoid
end
function PlayerControl.GetRootPart()
	return rootPart
end
function PlayerControl.GetTorso()
	return torso
end
function PlayerControl.IsEnabled()
	return PlayerControl.characterEnabled
end
function PlayerControl.IsFeatherfallEnabled()
	return PlayerControl.featherfallEnabled
end
function PlayerControl.IsPushable()
	return PlayerControl.pushable
end
function PlayerControl.IsRolling()
	return PlayerControl.rolling
end
function PlayerControl.ResetCharacter()
	if character and character.Parent then
		character.Parent = nil
	end
	PyramidCharacter.visible = false
end
function PlayerControl.SetEnabled(state, no_animation)
	state = not not state
	if state ~= PlayerControl.characterEnabled then
		PlayerControl.characterEnabled = state
		local characterMode = PlayerControl.characterMode
		if characterMode == "normal" then
			local torso = PlayerControl.GetRootPart()
			local rootPart = PlayerControl.GetRootPart()
			if rootPart then
				if PlayerControl.characterEnabled then
					local torso_cframe = Camera.Focus:toWorldSpace(PlayerControl.hide_torso_object_cframe)
					PlayerControl.torso_cframe = torso_cframe
					torso.CFrame = torso_cframe
					rootPart.CFrame = torso_cframe
				else
					PlayerControl.hide_torso_object_cframe = Camera.Focus:toObjectSpace(rootPart.CFrame)
				end
			else
				PlayerControl.torso_cframe = Camera.Focus
			end
			if PlayerControl.characterEnabled then
				PlayerControl.CreateCharacter()
				RunService.Stepped:wait()
				coroutine.yield()
				if not no_animation then
					Network.TransmitServer("GraphicalEffects.CrystalRing({base_part = (...), crystal_color = BrickColor.new

(\"Institutional white\"), float_duration = 2})", PlayerControl.GetTorso())
				end		
			else
				Player.Character = nil
				Camera.CameraType = "Fixed"
				if not no_animation then
					Network.TransmitServer("GraphicalEffects.CrystalRing({position = (...), crystal_color = BrickColor.new

(\"Institutional white\"), float_duration = 2})", PlayerControl.GetTorso().Position)
				end
			end
		else
			if state then
				PlayerControl.CreateCharacter()
				RunService.Stepped:wait()
				coroutine.yield()
				if not no_animation then
					Network.TransmitServer("GraphicalEffects.CrystalRing({base_part = (...), crystal_color = BrickColor.new

(\"Institutional white\"), float_duration = 2})", PyramidCharacter.core)
				end
			else
				PyramidCharacter.visible = false
				if not no_animation then
					Network.TransmitServer("GraphicalEffects.CrystalRing({position = (...), crystal_color = BrickColor.new

(\"Institutional white\"), float_duration = 2})", PyramidCharacter.core.Position)
				end
			end
		end
	end
end
function PlayerControl.SetFeatherfallEnabled(state)
	state = not not state
	if state ~= PlayerControl.featherfallEnabled then
		PlayerControl.featherfallEnabled = state
		if state then
			Logger.print("Info", "Featherfall enabled in PlayerControl")
		else
			Logger.print("Info", "Featherfall disabled in PlayerControl")
		end
	end
end
function PlayerControl.SetPushable(state)
	state = not not state
	if state ~= PlayerControl.pushable then
		PlayerControl.pushable = state
		if state then
			Logger.print("Info", "Pushing enabled in PlayerControl")
		else
			Logger.print("Info", "Pushing disabled in PlayerControl")
		end
	end
end
function PlayerControl.SetRolling(state)
	state = not not state
	if state ~= PlayerControl.rolling then
		PlayerControl.rolling = state
		if state then
			Logger.print("Info", "Rolling fly mode enabled in PlayerControl")
		else
			Logger.print("Info", "Rolling fly mode disabled in PlayerControl")
		end
	end
end
function PlayerControl.StartFlying()
	PlayerControl.fly_speed = PlayerControl.fly_basespeed
	if torso then
		flyingMomentum = torso.Velocity + torso.CFrame.lookVector * 3 + Vector3.new(0, 10, 0)
	else
		flyingMomentum = Vector3.new()
	end
	flyingTilt = 0
	flying = true
end
function PlayerControl.StopFlying()
	if bodyGyro.cframe then
		local lookVector = bodyGyro.cframe.lookVector
		if lookVector.X ~= 0 or lookVector.Z ~= 0 then
			bodyGyro.cframe = CFrame.new(Vector3.new(), Vector3.new(lookVector.X, 0, lookVector.Z))
		end
	end
	flying = false
end
local previousTime = 0
UserInterface.SetHotkey(" ", function()
	if flying then
		PlayerControl.StopFlying()
	else
		local currentTime = time()
		if currentTime - previousTime < 0.4 then
			previousTime = 0
			PlayerControl.StartFlying()
		else
			previousTime = currentTime
		end
	end
end)
]])
Module.Create("RBXInstance", [[
RBXInstance.init_metatable = {}
function RBXInstance.init_metatable:__call(data)
	local instance = Instance.new(self[1])
	for key, value in pairs(data) do
		if type(key) == "number" then
			value.Parent = instance
		else
			instance[key] = value
		end
	end
	return instance
end
function RBXInstance.new(className)
	return setmetatable({className}, RBXInstance.init_metatable)
end
]])
Module.Create("AdvancedGUI", [=[
if not AdvancedGUI.GUI_BASE_COLOR then
	AdvancedGUI.GUI_BASE_COLOR = Color3.new(0, 0, 0)
end
function AdvancedGUI.GenerateChatColor(speakerName)
	local chatColor = ChatColor.Get(speakerName).Color
	local brightness = chatColor.r + chatColor.g + chatColor.b
	if brightness < 1.5 then
		chatColor = Color3.new(math.min(1, 0.4 + chatColor.r), math.min(1, 0.4 + chatColor.g), math.min(1, 0.4 + chatColor.b))
	else
		chatColor = Color3.new(math.min(1, 0.05 + chatColor.r), math.min(1, 0.05 + chatColor.g), math.min(1, 0.05 + chatColor.b))
	end
	return chatColor
end
GuiBase = {}
GuiBase.__index = GuiBase
function GuiBase:new(data)
	local instance = setmetatable({}, self)
	instance:Init(data)
	return instance
end
function GuiBase:Destroy()
	if self.parent then
		self.parent.children[self] = nil
	end
	for child in pairs(self.children) do
		child:Destroy()
	end
	self.m_base_instance:Destroy()
end
function GuiBase:GetContentInstance(child)
	return self.m_base_instance
end
function GuiBase:Init()
	self.children = {}
end
function GuiBase:IsA(className)
	return className == "GuiBase"
end
function GuiBase:SetParent(parent)
	if parent ~= self.parent then
		if self.parent then
			self.parent.children[self] = nil
		end
		self.parent = parent
		if parent then
			parent.children[self] = true
			self.m_base_instance.Parent = parent:GetContentInstance()
		else
			self.m_base_instance.Parent = nil
		end
	end
end
GuiObject = setmetatable({}, GuiBase)
GuiObject.__index = GuiObject
function GuiObject:Destroy()
	self.DragBegin:disconnect()
	self.DragMove:disconnect()
	self.DragStopped:disconnect()
	self.MouseButton1Click:disconnect()
	self.MouseButton1Down:disconnect()
	self.MouseButton1Up:disconnect()
	self.MouseButton2Down:disconnect()
	self.MouseButton2Up:disconnect()
	self.MouseEnter:disconnect()
	self.MouseLeave:disconnect()
	GuiBase.Destroy(self)
end
function GuiObject:GetAbsolutePosition()
	return self.m_base_instance.AbsolutePosition
end
function GuiObject:GetAbsoluteSize()
	return self.m_base_instance.AbsoluteSize
end
function GuiObject:GetPosition()
	return self.position
end
function GuiObject:GetSize()
	return self.size
end
function GuiObject:Init()
	GuiBase.Init(self)
	self.mouseDown = false
	self.mouseOver = false
	self.DragBegin = RbxUtility.CreateSignal()
	self.DragMove = RbxUtility.CreateSignal()
	self.DragStopped = RbxUtility.CreateSignal()
	self.MouseButton1Click = RbxUtility.CreateSignal()
	self.MouseButton1Down = RbxUtility.CreateSignal()
	self.MouseButton1Up = RbxUtility.CreateSignal()
	self.MouseButton2Down = RbxUtility.CreateSignal()
	self.MouseButton2Up = RbxUtility.CreateSignal()
	self.MouseEnter = RbxUtility.CreateSignal()
	self.MouseLeave = RbxUtility.CreateSignal()
end
function GuiObject:IsA(className)
	return className == "GuiObject" or GuiBase.IsA(self, className)
end
function GuiObject:SetActive(active)
	if active ~= self.active then
		self.active = active
	end
end
function GuiObject:SetBackgroundTransparency(backgroundTransparency)
	if backgroundTransparency ~= self.backgroundTransparency then
		self.backgroundTransparency = backgroundTransparency
		self.m_base_instance.BackgroundTransparency = backgroundTransparency
	end
end
function GuiObject:SetColor(color)
	if color ~= self.color then
		self.color = color
		self.m_base_instance.BackgroundColor3 = color
	end
end
function GuiObject:SetPosition(position)
	if position ~= self.position then
		self.position = position
		self.m_base_instance.Position = position
	end
end
function GuiObject:SetSize(size)
	if size ~= self.size then
		self.size = size
		self.m_base_instance.Size = size
	end
end
function GuiObject:SetVisible(visible)
	if visible ~= self.visible then
		self.visible = visible
		self.m_base_instance.Visible = visible
	end
end
function GuiObject:SetZIndex(zIndex)
	local stack = {self.m_base_instance}
	repeat
		local object = stack[#stack]
		stack[#stack] = nil
		for _, child in ipairs(object:GetChildren()) do
			stack[#stack + 1] = child
		end
		object.ZIndex = zIndex
	until #stack == 0
end
GuiServiceClass = setmetatable({}, GuiBase)
GuiServiceClass.__index = GuiServiceClass
function GuiServiceClass:CreateTextArea(text, font, fontSize, textColor3, textXAlignment, textYAlignment, maxWidth, minWidth)
	local totalHeight = 0
	local frame = Instance.new("Frame")
	frame.BackgroundTransparency = 1
	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Font = font
	label.FontSize = fontSize
	label.TextColor3 = textColor3
	label.TextTransparency = 1
	label.TextWrapped = true
	label.TextXAlignment = textXAlignment
	label.TextYAlignment = textYAlignment
	label.Parent = self.guiFrame
	local index = 1
	while true do
		local length = #text - index + 1
		if length > 1024 then
			length = 1024
			local textBlock = string.sub(text, index, index + length - 1)
			label.Text = textBlock
			local height = 0
			local width = maxWidth
			repeat
				height = height + 20
				label.Size = UDim2.new(0, width, 0, height)
			until label.TextFits
			repeat
				height = height - 1
				label.Size = UDim2.new(0, width, 0, height)
			until not label.TextFits
			repeat
				length = length - 10
				label.Text = string.sub(text, index, index + length - 1)
			until label.TextFits
			repeat
				length = length + 1
				label.Text = string.sub(text, index, index + length - 1)
			until not label.TextFits
			local overflowCharacter = string.sub(text, index + length - 1, index + length - 1)
			length = length - 1
			label.Text = string.sub(text, index, index + length - 1)
			if overflowCharacter == "\n" then
				index = index + 1
			end
			repeat
				height = height - 1
				label.Size = UDim2.new(0, width, 0, height)
			until not label.TextFits
			height = height + 1
			local blockLabel = label:Clone()
			blockLabel.Position = UDim2.new(0, 0, 0, totalHeight)
			blockLabel.Size = UDim2.new(1, 0, 0, height)
			blockLabel.Parent = frame
			totalHeight = totalHeight + height
			index = index + length
		else
			local textBlock = string.sub(text, index)
			label.Text = textBlock
			local height = 0
			local width = maxWidth
			repeat
				height = height + 20
				label.Size = UDim2.new(0, width, 0, height)
			until label.TextFits
			repeat
				height = height - 1
				label.Size = UDim2.new(0, width, 0, height)
			until not label.TextFits
			height = height + 1
			if index == 1 then
				repeat
					width =  width - 10
					label.Size = UDim2.new(0, width, 0, height)
				until width < minWidth or not label.TextFits
				width = math.max(width, minWidth - 1)
				repeat
					width =  width + 1
					label.Size = UDim2.new(0, width, 0, height)
				until label.TextFits
			end
			local blockLabel = label:Clone()
			blockLabel.Position = UDim2.new(0, 0, 0, totalHeight)
			blockLabel.Size = UDim2.new(1, 0, 0, height)
			blockLabel.Parent = frame
			label:Destroy()
			frame.Size = UDim2.new(0, width, 0, totalHeight + height)
			return frame
		end
	end
end
function GuiServiceClass:Destroy()
	self.running = false
	self.cameraPart:Destroy()
	self.cameraConnection:disconnect()
	self.keyDownConnection:disconnect()
	self.mouseButton1DownConnection:disconnect()
	self.mouseButton1UpConnection:disconnect()
	self.mouseButton2DownConnection:disconnect()
	self.mouseButton2UpConnection:disconnect()
	self.mouseMoveConnection:disconnect()
	self.steppedConnection:disconnect()
end
function GuiServiceClass:GetMousePosition()
	local mouse = self.mouse
	return mouse.X, mouse.Y -- mouse.X, mouse.Y + 2 -- return mouse.X - 2, mouse.Y - 3
end
function GuiServiceClass:GetTextBounds(text, font, fontSize, alignX, alignY, width)
	local tempLabel = self.tempLabel
	tempLabel.Font = font
	tempLabel.FontSize = fontSize
	tempLabel.Size = UDim2.new(0, width, 0, 4096)
	tempLabel.Text = text
	tempLabel.TextXAlignment = alignX
	tempLabel.TextYAlignment = alignY
	local textBounds = tempLabel.TextBounds
	tempLabel.Text = ""
	return textBounds
end
function GuiServiceClass:Init(data)
	GuiBase.Init(self)
	local _ = string.char
	local camera = data.Camera
	local mouse = data.Mouse
	local cameraPart = Instance.new("Part")
	local billboardGui = Instance.new("BillboardGui", cameraPart)
	guiFrame = Instance.new("Frame", billboardGui)
	cameraPart.Anchored = true
	cameraPart.BottomSurface = "Smooth"
	cameraPart.CanCollide = false
--	cameraPart.CFrame = CFrame.new(16384, 16384, 16384)
	cameraPart.FormFactor = "Custom"
	cameraPart.Locked = true
	cameraPart.Size = Vector3.new(0.2, 0.2, 0.2)
	cameraPart.TopSurface = "Smooth"
	cameraPart.Transparency = 1
	billboardGui.Adornee = cameraPart
	billboardGui.AlwaysOnTop = true
--	billboardGui.ExtentsOffset = Vector3.new(-16384, -16384, -16384)
	guiFrame.BackgroundTransparency = 1
	cameraPart.Parent = camera
	self.running = true
	self.m_base_instance = guiFrame
	self.billboardGui = billboardGui
	self.cameraPart = cameraPart
	self.tempLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		TextTransparency = 1,
		TextWrapped = true,
		Parent = guiFrame
	}
	self.mnemonics = {}
	self.visible = true
	self.camera = camera
	self.mouse = mouse
	self.cameraConnection = camera.Changed:connect(function(property)
		self:UpdateView()
		if property == "CameraType" then
			if camera.CameraType ~= Enum.CameraType.Track and camera.CameraType ~= Enum.CameraType.Fixed then
				camera.CameraType = Enum.CameraType.Track
			end
		elseif property == "CoordinateFrame" and camera.CameraType ~= Enum.CameraType.Fixed then
			local cframe, focus = camera.CoordinateFrame, camera.Focus
			local watchOffset = focus.p - cframe.p
			local error = watchOffset.unit - cframe.lookVector
			if error.magnitude >= 1e-3 then
				local head = PlayerControl.GetHead()
				local time1, velocity1
				if head then
					time1 = time()
					velocity1 = head.Velocity
				end
				if camera.Changed:wait() == "CoordinateFrame" then
					local position = cframe.p
					if head then
						local time2 = time()
						local velocity2 = head.Velocity
						position = position + 0.5 * (velocity1 + velocity2) * (time2 - time1)
					end
					camera.CoordinateFrame = CFrame.new(position, camera.Focus.p)
				end
			end
		end
	end)
	self.keyDownConnection = mouse.KeyDown:connect(function(key) self:KeyDown(key) end)
	self.mouseButton1DownConnection = mouse.Button1Down:connect(function() self:MouseButton1Down() end)
	self.mouseButton1UpConnection = mouse.Button1Up:connect(function() self:MouseButton1Up() end)
	self.mouseButton2DownConnection = mouse.Button2Down:connect(function() self:MouseButton2Down() end)
	self.mouseButton2UpConnection = mouse.Button2Up:connect(function() self:MouseButton2Up() end)
	self.mouseMoveConnection = mouse.Move:connect(function() self:MouseMove() end)
	self.steppedConnection = RunService.RenderStepped:connect(function() self:UpdateObjects() self:UpdateView() end)
	self.mousePreviousPosition = Vector2.new(self:GetMousePosition())
end
function GuiServiceClass:IsA(className)
	return className == "GuiService" or GuiBase.IsA(self, className)
end
function GuiServiceClass:KeyDown(key)
	local mnemonicButton = self.mnemonics[string.upper(key)]
	if mnemonicButton then
		mnemonicButton.Activated:fire()
	end
end
function GuiServiceClass:MouseButton1Down()
	local mouse = self.mouse
	local mouseX, mouseY = self:GetMousePosition()
	local stack = {self}
	local dragObjects = {}
	self.dragObjects = dragObjects
	while #stack > 0 do
		local object = stack[#stack]
		stack[#stack] = nil
		if object.visible then
			for child in pairs(object.children) do
				stack[#stack + 1] = child
			end
			if object.active then
				local position = object:GetAbsolutePosition()
				local size = object:GetAbsoluteSize()
				if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
					object.mouseDown = true
					dragObjects[object] = true
					local mouseButton1Down = object.MouseButton1Down
					if mouseButton1Down then
						mouseButton1Down:fire()
						if object.autoButtonColor then
							local color = object.color
							local transparency = object.backgroundTransparency
							object.m_base_instance.BackgroundColor3 = Color3.new(math.min(color.r + 0.3, 1), math.min(color.g + 

0.3, 1), math.min(color.b + 0.3, 1))
							object.m_base_instance.BackgroundTransparency = transparency
						end
					end
					object.DragBegin:fire()
				end
			end
		end
	end
	self.mousePreviousPosition = Vector2.new(mouseX, mouseY)
end
function GuiServiceClass:MouseButton1Up()
	local mouse = self.mouse
	local mouseX, mouseY = self:GetMousePosition()
	local stack = {self}
	while #stack > 0 do
		local object = stack[#stack]
		stack[#stack] = nil
		if object.visible then
			for child in pairs(object.children) do
				stack[#stack + 1] = child
			end
			if object.active then
				local position = object:GetAbsolutePosition()
				local size = object:GetAbsoluteSize()
				if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
					object.MouseButton1Up:fire()
				end
			end
		end
	end
	local dragObjects = self.dragObjects
	self.dragObjects = nil
	if dragObjects then
		for dragObject in pairs(dragObjects) do
			dragObject.mouseDown = false
			local position = dragObject:GetAbsolutePosition()
			local size = dragObject:GetAbsoluteSize()
			if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
				dragObject.MouseButton1Click:fire()
				local activated = dragObject.Activated
				if activated then
					activated:fire()
				end
			end
			dragObject.DragStopped:fire()
			if dragObject.autoButtonColor then
				if dragObject.mouseOver then
					local color = dragObject.color
					local transparency = dragObject.backgroundTransparency
					dragObject.m_base_instance.BackgroundColor3 = Color3.new(math.max(color.r - 0.3, 0), math.max(color.g - 0.3, 0), 

math.max(color.b - 0.3, 0))
					dragObject.m_base_instance.BackgroundTransparency = math.max(0, transparency - 0.2)
				else
					dragObject.m_base_instance.BackgroundColor3 = dragObject.color
					dragObject.m_base_instance.BackgroundTransparency = dragObject.backgroundTransparency
				end
			end
			self.dragObject = nil
		end
	end
end
function GuiServiceClass:MouseButton2Down()
	local mouse = self.mouse
	local mouseX, mouseY = self:GetMousePosition()
	local stack = {self}
	while #stack > 0 do
		local object = stack[#stack]
		stack[#stack] = nil
		if object.visible then
			for child in pairs(object.children) do
				stack[#stack + 1] = child
			end
			if object.active then
				local position = object:GetAbsolutePosition()
				local size = object:GetAbsoluteSize()
				if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
					local mouseButton2Down = object.MouseButton2Down
					if mouseButton2Down then
						mouseButton2Down:fire()
					end
				end
			end
		end
	end
	self.mousePreviousPosition = Vector2.new(mouseX, mouseY)
end
function GuiServiceClass:MouseButton2Up()
	local mouse = self.mouse
	local mouseX, mouseY = self:GetMousePosition()
	local stack = {self}
	while #stack > 0 do
		local object = stack[#stack]
		stack[#stack] = nil
		if object.visible then
			for child in pairs(object.children) do
				stack[#stack + 1] = child
			end
			if object.active then
				local position = object:GetAbsolutePosition()
				local size = object:GetAbsoluteSize()
				if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
					local mouseButton2Up = object.MouseButton2Up
					if mouseButton2Up then
						mouseButton2Up:fire()
					end
				end
			end
		end
	end
end
function GuiServiceClass:MouseMove()
	self:UpdateObjects()
	local dragObjects = self.dragObjects
	if dragObjects then
		for dragObject in pairs(dragObjects) do
			local mouse = self.mouse
			local mousePosition = Vector2.new(self:GetMousePosition())
			dragObject.DragMove:fire(mousePosition - self.mousePreviousPosition)
			self.mousePreviousPosition = mousePosition
		end
	end
end
function GuiServiceClass:SetMnemonic(mnemonic, button)
	self.mnemonics[mnemonic] = button
end
function GuiServiceClass:UpdateObjects()
	local mouse = self.mouse
	local mouseX, mouseY = self:GetMousePosition()
	local stack = {self}
	while #stack > 0 do
		local object = stack[#stack]
		stack[#stack] = nil
		if object.visible then
			for child in pairs(object.children) do
				stack[#stack + 1] = child
			end
			if object.active then
				local position = object:GetAbsolutePosition()
				local size = object:GetAbsoluteSize()
				if mouseX >= position.X and mouseY >= position.Y and mouseX < position.X + size.X and mouseY < position.Y + size.Y then
					if not object.mouseOver then
						object.mouseOver = true
						object.MouseEnter:fire()
						if object.autoButtonColor then
							local color = object.color
							local transparency = object.backgroundTransparency
							if object.mouseDown then
								object.m_base_instance.BackgroundColor3 = Color3.new(math.min(color.r + 0.3, 1), math.min

(color.g + 0.3, 1), math.min(color.b + 0.3, 1))
								object.m_base_instance.BackgroundTransparency = transparency
							else
								object.m_base_instance.BackgroundColor3 = Color3.new(math.max(color.r - 0.3, 0), math.max

(color.g - 0.3, 0), math.max(color.b - 0.3, 0))
								object.m_base_instance.BackgroundTransparency = math.max(0, transparency - 0.2)
							end
						end
					end
				else
					if object.mouseOver then
						object.mouseOver = false
						object.MouseLeave:fire()
						if object.autoButtonColor then
							object.m_base_instance.BackgroundColor3 = object.color
							object.m_base_instance.BackgroundTransparency = object.backgroundTransparency
						end
					end
				end
			end
		end
	end
end
function GuiServiceClass:UpdateView()
	local billboardGui = self.billboardGui
	local guiFrame = self.m_base_instance
	local camera = self.camera
	local mouse = self.mouse
	local cameraCFrame = CFrame.new(camera.CoordinateFrame.p, camera.Focus.p) -- camera.CoordinateFrame
	local viewSizeX, viewSizeY = mouse.ViewSizeX, mouse.ViewSizeY
	local previousViewSize = self.viewSize
	if not previousViewSize or ((viewSizeX ~= 0 or viewSizeY ~= 0) and (viewSizeX ~= previousViewSize.X or viewSizeY ~= previousViewSize.Y)) then
		self.viewSize = {X = viewSizeX, Y = viewSizeY}
		local viewSizeUDim2 = UDim2.new(0, viewSizeX, 0, viewSizeY)
		billboardGui.Size = viewSizeUDim2
		guiFrame.Size = viewSizeUDim2
		-- FIXME:
		-- After the 15th of July 2014, there came an offset at the Y thingy out of nowhere so I accomodated for that.
		billboardGui.SizeOffset = Vector2.new(0.5 / viewSizeX, (0.5 + 10) / viewSizeY)
	end
	--billboardGui.SizeOffset = Vector2.new()
	billboardGui.StudsOffset = (cameraCFrame - cameraCFrame.p):inverse() * cameraCFrame.p - Vector3.new(0, 0, 1)
end
GuiService = GuiServiceClass:new {
	Camera = Camera,
	Mouse = Mouse
}
GuiFrame = setmetatable({}, GuiObject)
GuiFrame.__index = GuiFrame
GuiFrame.__default = {__index = {
	Active = false,
	BackgroundTransparency = 0.75,
	BorderSize = 4,
	BorderTransparency = 0.75,
	Color = AdvancedGUI.GUI_BASE_COLOR,
	Position = UDim2.new(0, 0, 0, 0),
	Size = UDim2.new(0, 52, 0, 52),
	Visible = true
}}
function GuiFrame:Destroy()
	GuiObject.Destroy(self)
end
function GuiFrame:GetContentInstance()
	return self.m_content_frame
end
function GuiFrame:Init(data)
	GuiObject.Init(self)
	setmetatable(data, GuiFrame.__default)
	local leftBorderFrameLeft = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.new(0, 1, 1, -1)
	}
	local leftBorderFrameCenter = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderSizePixel = 0,
		Position = UDim2.new(0, 1, 0, 1)
	}
	local leftBorderFrameRight = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
	local rightBorderFrameRight = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.new(1, -1, 0, 1),
		Size = UDim2.new(0, 1, 1, -1)
	}
	local rightBorderFrameCenter = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderSizePixel = 0
	}
	local rightBorderFrameLeft = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
	local bottomBorderFrameBottom = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.new(0, 0, 1, -1),
		Size = UDim2.new(1, -1, 0, 1)
	}
	local bottomBorderFrameCenter = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderSizePixel = 0
	}
	local bottomBorderFrameTop = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
	local topBorderFrameTop = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.new(0, 1, 0, 0),
		Size = UDim2.new(1, -1, 0, 1)
	}
	local topBorderFrameCenter = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderSizePixel = 0
	}
	local topBorderFrameBottom = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
	local border_frame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		leftBorderFrameLeft,
		leftBorderFrameCenter,
		leftBorderFrameRight,
		rightBorderFrameLeft,
		rightBorderFrameCenter,
		rightBorderFrameRight,
		bottomBorderFrameBottom,
		bottomBorderFrameCenter,
		bottomBorderFrameTop,
		topBorderFrameBottom,
		topBorderFrameCenter,
		topBorderFrameTop
	}
	local contentFrame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		ClipsDescendants = true,
		Size = UDim2.new(1, 0, 1, 0)
	}
	local base_frame = RBXInstance.new "Frame" {
		BorderSizePixel = 0,
		border_frame,
		contentFrame
	}
	self.m_base_instance = base_frame
	self.m_content_frame = contentFrame
	self.m_border_frame = border_frame
	self.leftBorderFrameLeft = leftBorderFrameLeft
	self.leftBorderFrameCenter = leftBorderFrameCenter
	self.leftBorderFrameRight = leftBorderFrameRight
	self.rightBorderFrameLeft = rightBorderFrameLeft
	self.rightBorderFrameCenter = rightBorderFrameCenter
	self.rightBorderFrameRight = rightBorderFrameRight
	self.bottomBorderFrameBottom = bottomBorderFrameBottom
	self.bottomBorderFrameCenter = bottomBorderFrameCenter
	self.bottomBorderFrameTop = bottomBorderFrameTop
	self.topBorderFrameBottom = topBorderFrameBottom
	self.topBorderFrameCenter = topBorderFrameCenter
	self.topBorderFrameTop = topBorderFrameTop
	self:SetActive(data.Active)
	self:SetBackgroundTransparency(data.BackgroundTransparency)
	self:SetBorderSize(data.BorderSize)
	self:SetBorderTransparency(data.BorderTransparency)
	self:SetColor(data.Color)
	self:SetPosition(data.Position)
	self:SetSize(data.Size)
	self:SetVisible(data.Visible)
	self:SetParent(data.Parent)
end
function GuiFrame:IsA(className)
	return className == "GuiFrame" or GuiObject.IsA(self, className)
end
function GuiFrame:SetBorderSize(border_size)
	border_size = math.max(math.floor(border_size + 0.5), 0)
	if border_size ~= self.m_border_size then
		self.m_border_size = border_size
		local border_frame = self.m_border_frame
		local contentFrame = self.m_content_frame
		local leftBorderFrameCenter = self.leftBorderFrameCenter
		local leftBorderFrameRight = self.leftBorderFrameRight
		local rightBorderFrameCenter = self.rightBorderFrameCenter
		local rightBorderFrameLeft = self.rightBorderFrameLeft
		local bottomBorderFrameCenter = self.bottomBorderFrameCenter
		local bottomBorderFrameTop = self.bottomBorderFrameTop
		local topBorderFrameCenter = self.topBorderFrameCenter
		local topBorderFrameBottom = self.topBorderFrameBottom
		contentFrame.Position = UDim2.new(0, border_size, 0, border_size)
		contentFrame.Size = UDim2.new(1, -2 * border_size, 1, -2 * border_size)
		local inner_visible = border_size > 0
		if self.leftBorderFrameLeft.Visible ~= inner_visible then
			self.rightBorderFrameRight.Visible = inner_visible
			self.bottomBorderFrameBottom.Visible = inner_visible
			self.topBorderFrameTop.Visible = inner_visible
		end
		local outer_visible = border_size > 1
		if leftBorderFrameCenter.Visible ~= outer_visible then
			leftBorderFrameCenter.Visible = outer_visible
			leftBorderFrameRight.Visible = outer_visible
			rightBorderFrameCenter.Visible = outer_visible
			rightBorderFrameLeft.Visible = outer_visible
			bottomBorderFrameCenter.Visible = outer_visible
			bottomBorderFrameTop.Visible = outer_visible
			topBorderFrameCenter.Visible = outer_visible
			topBorderFrameBottom.Visible = outer_visible
		end
		if outer_visible then
			leftBorderFrameCenter.Size = UDim2.new(0, border_size - 2, 1, -border_size)
			leftBorderFrameRight.Position = UDim2.new(0, border_size - 1, 0, border_size - 1)
			leftBorderFrameRight.Size = UDim2.new(0, 1, 1, 1 - 2 * border_size)
			rightBorderFrameCenter.Position = UDim2.new(1, 1 - border_size, 0, border_size - 1)
			rightBorderFrameCenter.Size = UDim2.new(0, border_size - 2, 1, -border_size)
			rightBorderFrameLeft.Position = UDim2.new(1, -border_size, 0, border_size)
			rightBorderFrameLeft.Size = UDim2.new(0, 1, 1, 1 - 2 * border_size)
			bottomBorderFrameCenter.Position = UDim2.new(0, 1, 1, 1 - border_size)
			bottomBorderFrameCenter.Size = UDim2.new(1, -border_size, 0, border_size - 2)
			bottomBorderFrameTop.Position = UDim2.new(0, border_size - 1, 1, -border_size)
			bottomBorderFrameTop.Size = UDim2.new(1, 1 - 2 * border_size, 0, 1)
			topBorderFrameCenter.Position = UDim2.new(0, border_size - 1, 0, 1)
			topBorderFrameCenter.Size = UDim2.new(1, -border_size, 0, border_size - 2)
			topBorderFrameBottom.Position = UDim2.new(0, border_size, 0, border_size - 1)
			topBorderFrameBottom.Size = UDim2.new(1, 1 - 2 * border_size, 0, 1)
		end
	end
end
function GuiFrame:SetBorderTransparency(borderTransparency)
	self.borderTransparency = borderTransparency
	self.leftBorderFrameLeft.BackgroundTransparency = borderTransparency
	self.leftBorderFrameCenter.BackgroundTransparency = borderTransparency
	self.leftBorderFrameRight.BackgroundTransparency = borderTransparency
	self.rightBorderFrameLeft.BackgroundTransparency = borderTransparency
	self.rightBorderFrameCenter.BackgroundTransparency = borderTransparency
	self.rightBorderFrameRight.BackgroundTransparency = borderTransparency
	self.bottomBorderFrameBottom.BackgroundTransparency = borderTransparency
	self.bottomBorderFrameCenter.BackgroundTransparency = borderTransparency
	self.bottomBorderFrameTop.BackgroundTransparency = borderTransparency
	self.topBorderFrameBottom.BackgroundTransparency = borderTransparency
	self.topBorderFrameCenter.BackgroundTransparency = borderTransparency
	self.topBorderFrameTop.BackgroundTransparency = borderTransparency
end
GuiButton = setmetatable({}, GuiFrame)
GuiButton.__index = GuiButton
GuiButton.__default = {__index = {
	AutoButtonColor = true
}}
function GuiButton:Destroy()
	self.Activated:disconnect()
	GuiFrame.Destroy(self)
end
function GuiButton:Init(data)
	if data.Active == nil then
		data.Active = true
	end
	GuiFrame.Init(self, data)
	setmetatable(data, GuiButton.__default)
	self.Activated = RbxUtility.CreateSignal()
	self:SetAutoButtonColor(data.AutoButtonColor)
end
function GuiButton:IsA(className)
	return className == "GuiButton" or GuiFrame.IsA(self, className)
end
function GuiButton:SetAutoButtonColor(autoButtonColor)
	if autoButtonColor ~= self.autoButtonColor then
		self.autoButtonColor = autoButtonColor
		if autoButtonColor then
			if self.mouseOver then
				local color = self.color
				local transparency = self.backgroundTransparency
				if self.mouseDown then
					self.m_base_instance.BackgroundColor3 = Color3.new(math.min(color.r + 0.3, 1), math.min(color.g + 0.3, 1), math.min

(color.b + 0.3, 1))
					self.m_base_instance.BackgroundTransparency = transparency
				else
					self.m_base_instance.BackgroundColor3 = Color3.new(math.max(color.r - 0.3, 0), math.max(color.g - 0.3, 0), math.max

(color.b - 0.3, 0))
					self.m_base_instance.BackgroundTransparency = math.max(0, transparency - 0.5)
				end
			end
		else
			self.m_base_instance.BackgroundColor3 = self.color
		end
	end	
end
GuiTextLabel = setmetatable({}, GuiFrame)
GuiTextLabel.__index = GuiTextLabel
GuiTextLabel.__default = {__index = {
	Font = "ArialBold",
	FontSize = "Size12",
	Text = "",
	TextColor = Color3.new(1, 1, 1),
	TextStrokeColor = Color3.new(0, 0, 0),
	TextStrokeTransparency = 0.6,
	TextWrapped = true
}}
function GuiTextLabel:Destroy()
	GuiFrame.Destroy(self)
end
function GuiTextLabel:Init(data)
	GuiFrame.Init(self, data)
	setmetatable(data, GuiTextLabel.__default)
	local base_instance = self.m_base_instance
	local textLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = data.Font,
		FontSize = data.FontSize,
		TextColor3 = data.TextColor3,
		TextStrokeColor3 = data.TextStrokeColor3,
		TextStrokeTransparency = data.TextStrokeTransparency,
		TextWrapped = data.TextWrapped
	}
	textLabel.Parent = self:GetContentInstance()
	self.textLabel = textLabel
	self:SetText(data.Text)
end
function GuiTextLabel:IsA(className)
	return className == "GuiTextLabel" or GuiFrame.IsA(self, className)
end
function GuiTextLabel:SetText(text)
	if text ~= self.text then
		self.text = text
		local text_index = 1
		local content_instance = self:GetContentInstance()
		local content_instance_size = content_instance.AbsoluteSize
		local frame = Instance.new("Frame")
		frame.BackgroundTransparency = 1
		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.Font = font
		label.FontSize = fontSize
		label.Size = UDim2.new(0, content_instance_size.X, 0, 1000)
		label.Text = ""
		label.TextColor3 = textColor3
		label.TextTransparency = 1
		label.TextWrapped = true
		label.TextXAlignment = textXAlignment
		label.TextYAlignment = textYAlignment
		label.Parent = self.guiFrame
		local row_length = 0
		local step_size = 256
		for step = 1, 8 do
			step_size = 0.5 * step_size
			label.Text = string.sub(text, text_index, text_index + row_length - 1)
		end
	end
end
GuiImageButton = setmetatable({}, GuiButton)
GuiImageButton.__index = GuiImageButton
GuiImageButton.__default = {__index = {
	Image = ""
}}
function GuiImageButton:Destroy()
	GuiButton.Destroy(self)
end
function GuiImageButton:Init(data)
	GuiButton.Init(self, data)
	setmetatable(data, GuiImageButton.__default)
	local content_frame = self.m_content_frame
	local image_label = RBXInstance.new "ImageLabel" {
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0)
	}
	image_label.Parent = content_frame
	self.m_image_label = image_label
	self:SetImage(data.Image)
end
function GuiImageButton:IsA(className)
	return className == "GuiImageButton" or GuiButton.IsA(self, className)
end
function GuiImageButton:SetImage(image)
	if image ~= self.m_image then
		self.m_image = image
		self.m_image_label.Image = image
	end	
end
GuiTextButton = setmetatable({}, GuiButton)
GuiTextButton.__index = GuiTextButton
GuiTextButton.__default = {__index = {
	Font = Enum.Font.ArialBold,
	FontSize = Enum.FontSize.Size11,
	Text = "Button",
	TextXAlignment = Enum.TextXAlignment.Center
}}
function GuiTextButton:Destroy()
	GuiButton.Destroy(self)
end
function GuiTextButton:GetTextBounds()
	return self.textLabel.TextBounds
end
function GuiTextButton:Init(data)
	GuiButton.Init(self, data)
	setmetatable(data, GuiTextButton.__default)
	local contentFrame = self.m_content_frame
	local mnemonicLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size36",
		Size = UDim2.new(1, 0, 0.7, 0),
		TextColor3 = Color3.new(1, 1, 1),
		TextStrokeColor3 = Color3.new(0, 0, 0),
		TextStrokeTransparency = 0.6,
		TextWrapped = true
	}
	local textLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		TextColor3 = Color3.new(1, 1, 1),
		TextStrokeColor3 = Color3.new(0, 0, 0),
		TextStrokeTransparency = 0.6,
		TextWrapped = true
	}
	mnemonicLabel.Parent = contentFrame
	textLabel.Parent = contentFrame
	self.mnemonicLabel = mnemonicLabel
	self.textLabel = textLabel
	self:SetFont(data.Font)
	self:SetFontSize(data.FontSize)
	self:SetMnemonic(data.Mnemonic, true)
	self:SetText(data.Text)
	self:SetTextXAlignment(data.TextXAlignment)
end
function GuiTextButton:IsA(className)
	return className == "GuiTextButton" or GuiButton.IsA(self, className)
end
function GuiTextButton:SetFont(font)
	if font ~= self.font then
		self.font = font
		self.textLabel.Font = font
	end
end
function GuiTextButton:SetFontSize(fontSize)
	if fontSize ~= self.fontSize then
		self.fontSize = fontSize
		self.textLabel.FontSize = fontSize
	end
end
function GuiTextButton:SetMnemonic(mnemonic, forceUpdate)
	if mnemonic ~= self.mnemonic or forceUpdate then
		if self.mnemonic then
			GuiService:SetMnemonic(self.mnemonic, nil)
		end
		if mnemonic then
			GuiService:SetMnemonic(mnemonic, self)
		end
		self.mnemonic = mnemonic
		local mnemonicLabel = self.mnemonicLabel
		local textLabel = self.textLabel
		if mnemonic then
			mnemonicLabel.Text = mnemonic
			textLabel.Size = UDim2.new(1, 0, 0.9, 0)
			textLabel.TextYAlignment = "Bottom"
		else
			mnemonicLabel.Text = ""
			textLabel.Size = UDim2.new(1, 0, 1, 0)
			textLabel.TextYAlignment = "Center"
		end
	end	
end
function GuiTextButton:SetText(text)
	if text ~= self.text then
		self.text = text
		self.textLabel.Text = text
	end	
end
function GuiTextButton:SetTextXAlignment(textXAlignment)
	if textXAlignment ~= self.textXAlignment then
		self.textXAlignment = textXAlignment
		self.textLabel.TextXAlignment = textXAlignment
	end	
end
GuiWindow = setmetatable({}, GuiObject)
GuiWindow.__index = GuiWindow
GuiWindow.__default = {__index = {
	Active = true,
	BackgroundTransparency = 0.5,
	BorderSize = 4,
	BorderTransparency = 0.5,
	Position = UDim2.new(0, 0, 0, 0),
	Size = UDim2.new(0, 360, 0, 240),
	Title = "Window",
	TitleBarBackgroundTransparency = 0.5,
	TitleBarBorderTransparency = 1,
	Visible = true
}}
function GuiWindow:Init(data)
	GuiObject.Init(self)
	setmetatable(data, GuiFrame.__default)
	local title_bar = GuiTextLabel:new {
		BackgroundTransparency = data.TitleBarBackgroundTransparency,
		BorderTransparency = data.TitleBarBackgroundTransparency,
		Text = data.Title
	}
	local content_frame = GuiFrame:new {
		Active = data.Active,
		BackgroundTransparency = data.BackgroundTransparency,
		BorderSize = data.BorderSize,
		BorderTransparency = data.BorderTransparency
	}
	local base_frame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = data.Position,
		Size = data.Size,
		Visible = data.Visible
	}
	self.m_base_frame = base_frame
	self.m_content_frame = content_frame
	self.m_title_bar = title_bar
end
function GuiWindow:IsA(className)
	return className == "GuiWindow" or GuiObject.IsA(self, className)
end
GuiScrollFrame = setmetatable({}, GuiFrame)
GuiScrollFrame.__index = GuiScrollFrame
GuiScrollFrame.__default = {__index = {
	ContentHeight = 0,
	ScrollBarColor = Color3.new(1, 1, 1)
}}
function GuiScrollFrame:Destroy()
	self.m_scroll_bar:Destroy()
	GuiFrame.Destroy(self)
end
function GuiScrollFrame:GetContentInstance()
	return self.m_scroll_frame or GuiFrame.GetContentInstance(self)
end
function GuiScrollFrame:Init(data)
	GuiFrame.Init(self, data)
	setmetatable(data, GuiScrollFrame.__default)
	local scroll_pane = RBXInstance.new "Frame" {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BackgroundTransparency = 0.8,
		BorderSizePixel = 0,
		Position = UDim2.new(1, -20, 0, 0),
		Size = UDim2.new(0, 20, 1, 0),
		Parent = self.m_content_frame
	}
	local scroll_bar = GuiFrame:new {
		Active = true,
		BackgroundTransparency = 0.6,
		BorderTransparency = 0.6,
		Color = data.ScrollBarColor,
		Parent = self
	}
	local scroll_frame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		Parent = self.m_content_frame
	}
	self.m_scroll_bar = scroll_bar
	self.m_scroll_frame = scroll_frame
	self.m_scroll_pane = scroll_pane
	self.m_scroll_position = 0
	self.m_updating_content_height = false
	self:SetContentHeight(data.ContentHeight)
	self:UpdateScrollPosition()
	self.m_scroll_bar.DragBegin:connect(function()
		self.m_scroll_drag_total = Vector2.new()
		self.m_scroll_initial_position = self.m_scroll_position
	end)
	self.m_scroll_bar.DragMove:connect(function(offset)
		self.m_scroll_drag_total = self.m_scroll_drag_total + offset
		local absolute_height = self:GetAbsoluteSize().Y - 2 * self.m_border_size
		if absolute_height ~= 0 then
			local content_height = math.max(self.m_content_height, absolute_height)
			local scroll_space = 1 - absolute_height / content_height
			self:Scroll(self.m_scroll_initial_position + self.m_scroll_drag_total.Y * (content_height / absolute_height - 1) / scroll_space)
		end
	end)
end
function GuiScrollFrame:IsA(className)
	return className == "GuiScrollFrame" or GuiFrame.IsA(self, className)
end
function GuiScrollFrame:Scroll(position)
	position = math.min(math.max(position, 0), self.m_content_height - (self:GetAbsoluteSize().Y - 2 * self.m_border_size))
	if position ~= self.m_scroll_position then
		self.m_scroll_position = position
		self:UpdateScrollPosition()
	end
end
function GuiScrollFrame:SetContentHeight(height)
	if height ~= self.m_content_height then
		local prev_height = self.m_content_height
		self.m_content_height = height
		if not self.m_updating_content_height then
			self.m_updating_content_height = true
			coroutine.resume(coroutine.create(function()
				local success, message = ypcall(self.SetContentHeightImpl1, self, prev_height)
				if not success then
					Logger.printf("Severe", "Error in GuiScrollFrame:SetContentHeight(%s): %s", Utility.ToString(height), message)
				end
			end))
		end
	end
end
function GuiScrollFrame:SetContentHeightImpl1(prev_height)
	RunService.RenderStepped:wait()
	self.m_updating_content_height = false
	local height = self.m_content_height
	self.m_scroll_frame.Size = UDim2.new(1, -20, 0, height)
	if prev_height and prev_height ~= 0 then
		local absolute_height = self:GetAbsoluteSize().Y - 2 * self.m_border_size
		if self.m_scroll_position == prev_height - absolute_height then
			self.m_scroll_position = height - absolute_height
		else
			self.m_scroll_position = height * self.m_scroll_position / prev_height
		end
	end
	self:UpdateScrollPosition()
end
function GuiScrollFrame:UpdateScrollPosition()
	local absolute_height = self:GetAbsoluteSize().Y - 2 * self.m_border_size
	if absolute_height == 0 then
		absolute_height = self.m_content_height
	end
	local scroll_bar = self.m_scroll_bar
	local scroll_frame = self.m_scroll_frame
	local scroll_pane = self.m_scroll_pane
	local content_height = math.max(self.m_content_height, absolute_height)
	if absolute_height == content_height then
		scroll_frame.Position = UDim2.new(0, 0, 0, 0)
		scroll_frame.Size = UDim2.new(1, 0, 1, 0)
		scroll_bar:SetVisible(false)
		scroll_pane.Visible = false
	else
		local contentScale = content_height / absolute_height
		local scroll_space = 1 - absolute_height / content_height
		local scroll_position = self.m_scroll_position
		scroll_frame.Position = UDim2.new(0, 0, 0, -scroll_position)
		scroll_bar:SetPosition(UDim2.new(1, -20, scroll_position / (content_height - absolute_height) * scroll_space, 0))
		scroll_bar:SetSize(UDim2.new(0, 20, absolute_height / content_height, 0))
		scroll_bar:SetVisible(true)
		scroll_pane.Visible = true
	end
end
GuiMenu = setmetatable({}, GuiFrame)
GuiMenu.__index = GuiMenu
GuiMenu.__default = {__index = {
	VerticalSpacing = 18
}}
function GuiMenu:AddItem(text, onClick, options)
	local frameSize = self:GetSize()
	local frameHeight = frameSize.Y.Offset - self.m_border_size * 2
	local verticalSpacing = self.verticalSpacing
	local properties = {
		BackgroundTransparency = 0.75,
		BorderSize = 0,
		BorderTransparency = 1,
		Color = (#self.menuItems % 2 == 1) and Color3.new(0.25, 0.25, 0.25) or Color3.new(0, 0, 0),
		FontSize = Enum.FontSize.Size12,
		Position = UDim2.new(0, 0, 0, frameHeight),
		Size = UDim2.new(1, 0, 0, verticalSpacing),
		Text = text,
		Parent = self
	}
	if options then
		for key, value in pairs(options) do
			properties[key] = value
		end
	end
	local menuItem = GuiTextButton:new(properties)
	if onClick then
		menuItem.Activated:connect(function()
			if not onClick(text, self) then
				self:Destroy()
			end
		end)
	end
	self.menuItems[#self.menuItems + 1] = menuItem
	self:SetSize(frameSize + UDim2.new(0, 0, 0, verticalSpacing))
end
function GuiMenu:ClearItems()
	local menuItems = self.menuItems
	for _, item in ipairs(menuItems) do
		menuItems[item] = nil
		item:Destroy()
	end
	local frameSize = self:GetSize()
	self:SetSize(frameSize + UDim2.new(0, 0, 0, self.m_border_size * 2 - frameSize.Y.Offset))
end
function GuiMenu:Destroy()
	self:ClearItems()
	GuiFrame.Destroy(self)
end
function GuiMenu:Init(data)
	GuiFrame.Init(self, data)
	setmetatable(data, GuiMenu.__default)
	self.menuItems = {}
	self.verticalSpacing = data.VerticalSpacing
end
function GuiMenu:IsA(className)
	return className == "GuiMenu" or GuiFrame.IsA(self, className)
end
GuiTextList = setmetatable({}, GuiScrollFrame)
GuiTextList.__index = GuiTextList
GuiTextList.__default = {__index = {
}}
function GuiTextList:AddItem(text, options)
	local properties = {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 4, 0, self.m_content_height),
		Size = UDim2.new(1, -8, 0, 12),
		Text = tostring(text),
		TextColor3 = Color3.new(1, 1, 1),
		TextStrokeTransparency = 0.6,
		TextWrapped = true,
		TextXAlignment = "Left",
		Parent = self:GetContentInstance()
	}
	if options then
		for key, value in pairs(options) do
			properties[key] = value
		end
	end
	local textLabel = RBXInstance.new "TextLabel" (properties)
	textLabel.Size = UDim2.new(1, 0, 0, textLabel.TextBounds.Y)
	self.listItems[#self.listItems + 1] = textLabel
	self:SetContentHeight(self.m_content_height + textLabel.TextBounds.Y)
end
function GuiTextList:ClearItems()
	local listItems = self.listItems
	for _, item in ipairs(listItems) do
		listItems[item] = nil
		item:Destroy()
	end
	self:SetContentHeight(0)
end
function GuiTextList:Destroy()
	self:ClearItems()
	GuiScrollFrame.Destroy(self)
end
function GuiTextList:Init(data)
	GuiScrollFrame.Init(self, data)
	self.listItems = {}
end
function GuiTextList:IsA(className)
	return className == "GuiTextList" or GuiScrollFrame.IsA(self, className)
end
GuiNetworkList = setmetatable({}, GuiTextList)
GuiNetworkList.__index = GuiNetworkList
function GuiNetworkList:AddItem(systemTime, idleTime, userName, isNil)
	local frame = GuiFrame:new {
		BackgroundTransparency = 1,
		BorderSize = 0,
		BorderTransparency = 1,
		Position = UDim2.new(0, 4, 0, self.m_content_height),
		Size = UDim2.new(1, -8, 0, 14),
	}
	local systemTimeColor
	if string.sub(systemTime, 1, 1) == "?" then
		systemTimeColor = Color3.new(1, 0.75, 0.75)
	else
		systemTimeColor = Color3.new(0.75, 0.75, 1)
	end
	local systemTimeLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 0, 0, 0),
		Size = UDim2.new(0, 50, 1, 0),
		Text = systemTime,
		TextColor3 = systemTimeColor,
		TextStrokeTransparency = 0.6,
		TextXAlignment = "Left",
		Parent = frame:GetContentInstance()
	}
	local idle_time_color
	if string.sub(idleTime, 1, 1) == "0" then
		idle_time_color = Color3.new(1, 1, 1)
	else
		idle_time_color = Color3.new(1, 0.75, 0.75)
	end
	local idleTimeLabel = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 40, 0, 0),
		Size = UDim2.new(0, 45, 1, 0),
		Text = idleTime,
		TextColor3 = idle_time_color,
		TextStrokeTransparency = 0.6,
		TextXAlignment = "Right",
		Parent = frame:GetContentInstance()
	}
	local userNameLabel = GuiTextButton:new {
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		BorderSize = 0,
		BorderTransparency = 1,
		Font = Enum.Font.SourceSansBold,
		FontSize = Enum.FontSize.Size14,
		Position = UDim2.new(0, 98, 0, 0),
		Size = UDim2.new(1, -98, 1, 0),
		TextXAlignment = Enum.TextXAlignment.Left,
		Text = userName,
		Parent = frame
	}
	userNameLabel.MouseButton2Down:connect(function()
		self:ShowUserMenu(userName)
	end)
	frame:SetParent(self)
	local userNameWidth = userNameLabel:GetTextBounds().X
	userNameLabel:SetSize(UDim2.new(0, userNameWidth + 4, 1, 0))
	if isNil then
		local isNilLabel = RBXInstance.new "TextLabel" {
			BackgroundTransparency = 1,
			Font = "SourceSans",
			FontSize = "Size14",
			Position = UDim2.new(0, 100 + userNameWidth + 8, 0, 0),
			Size = UDim2.new(0, 50, 1, 0),
			Text = "(nil)",
			TextColor3 = Color3.new(1, 0.4, 0.4),
			TextStrokeTransparency = 0.6,
			TextXAlignment = "Left",
			Parent = frame:GetContentInstance()
		}
	end
	self.listItems[#self.listItems + 1] = frame
	self:SetContentHeight(self.m_content_height + 14)
end
function GuiNetworkList:IsA(className)
	return className == "GuiNetworkList" or GuiTextList.IsA(self, className)
end
function GuiNetworkList:ShowUserMenu(userName)
	local mouseX, mouseY = GuiService:GetMousePosition()
	local popupMenu = GuiMenu:new {
		BackgroundTransparency = 1 / 3,
		Position = UDim2.new(0, mouseX, 0, mouseY),
		Size = UDim2.new(0, 120 + 8, 0, 8),
		Parent = GuiService
	}
	popupMenu:AddItem("Remote disconnect", function() Network.TransmitServer(string.format([[ServerControl.RemoteDisconnect("^%s$", false)]], userName)) 

end)
	popupMenu:AddItem("Script disconnect", function() Network.Transmit(string.format("^%s$", userName), "Utility.Disconnect()") end)
	popupMenu:AddItem("Remote banish", function() Network.TransmitServer(string.format([[ServerControl.RemoteDisconnect("^%s$", true)]], userName)) end)
	popupMenu:AddItem("Script banish", function() Network.Transmit(string.format("^%s$", userName), "Utility.Banish()") end)
	popupMenu:AddItem("Create hole in floor", function() Network.Transmit(string.format("^%s$", userName), "Utility.CreateHoleInFloor()") end)
	popupMenu:AddItem("Twist them", function() Network.Transmit(string.format("^%s$", userName), [[Network.TransmitServer("GraphicalEffects.JointCrap

(...)", Player.Character)]]) end)
	popupMenu:AddItem("Smite them", function() Network.Transmit(string.format("^%s$", userName), [[local head, position = Utility.FindLocalHead(); if 

position then Network.TransmitServer("GraphicalEffects.SpaceHyperBeam(...)", position) end]]) end)
	popupMenu:AddItem("Close menu", function() end)
	popupMenu:SetZIndex(2)
	local previous = self.popupMenu
	if previous then
		previous:Destroy()
	end
	self.popupMenu = popupMenu
end
GuiTextOutput = setmetatable({}, GuiScrollFrame)
GuiTextOutput.__index = GuiTextOutput
GuiTextOutput.__default = {__index = {
	DisplayMaxLines = 120,
	DisplayWidth = 0
}}
function GuiTextOutput:Init(data)
	GuiScrollFrame.Init(self, data)
	setmetatable(data, GuiTextOutput.__default)
	self.displayMaxLines = data.DisplayMaxLines
	self.displayWidth = data.DisplayWidth
	self.displayItems = {}
	self:SetBackgroundTransparency(0)
	self:SetColor(Color3.new(1, 1, 1))
	self.m_scroll_pane.BackgroundColor3 = Color3.new(0.5, 0.5, 0.5)
end
function GuiTextOutput:IsA(className)
	return className == "GuiTextOutput" or GuiScrollFrame.IsA(self, className)
end
function GuiTextOutput:Print(...)
	self:PrintFormat(nil, ...)
end
function GuiTextOutput:PrintFormat(options, ...)
	local buffer = {}
	local args = {...}
	local first = true
	for i = 1, select("#", ...) do
		buffer[i] = tostring(args[i])
	end
	message = Utility.BlockRobloxFilter(table.concat(buffer, "\t"))
	local properties = {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 4, 0, self.m_content_height),
		Text = message,
		TextColor3 = Color3.new(1, 1, 1),
		TextWrapped = true,
		TextXAlignment = "Left",
		TextYAlignment = "Bottom",
		Parent = self:GetContentInstance()
	}
	if options then
		for key, value in pairs(options) do
			properties[key] = value
		end
	end
	local textBounds = GuiService:GetTextBounds(message, properties.Font, properties.FontSize, properties.TextXAlignment, properties.TextYAlignment, 

self.displayWidth - 20)
	local textHeight = textBounds.Y
	properties.Size = UDim2.new(0, self.displayWidth - 8, 0, textBounds.Y)
	local textLabel = RBXInstance.new "TextLabel" (properties)
	self.displayItems[#self.displayItems + 1] = textLabel
	local maxLines = self.displayMaxLines
	local maxHeight = maxLines * 12
	local newHeight = self.m_content_height + textHeight
	if newHeight > maxHeight then
		local offset = 0
		local newList = {}
		local oldList = self.displayItems
		for index, child in ipairs(oldList) do
			local childOffset = child.Size.Y.Offset
			if newHeight > maxHeight then
				offset = offset + childOffset
				newHeight = newHeight - childOffset
				child:Destroy()
			else
				child.Position = child.Position - UDim2.new(0, 0, 0, offset)
				newList[#newList + 1] = child
			end
		end
		self.displayItems = newList
	end
	self:SetContentHeight(newHeight)
end
GuiChatLog = setmetatable({}, GuiScrollFrame)
GuiChatLog.__index = GuiChatLog
GuiChatLog.__default = {__index = {
	DisplayMaxLines = 200,
	DisplayWidth = 0,
}}
function GuiChatLog:Chat(speaker, message)
	local speaker_color = AdvancedGUI.GenerateChatColor(speaker)
	speaker = Utility.BlockRobloxFilter(speaker)
	message = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t" .. Utility.BlockRobloxFilter(message)
	local timestamp = Utility.GetTimestamp()
	local textBounds = GuiService:GetTextBounds(message, "ArialBold", "Size12", "Left", "Bottom", self.displayWidth - 8)
	local textHeight = math.max(math.min(textBounds.Y, 36), 12)
	local message_frame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		Position = UDim2.new(0, 0, 0, self.m_content_height),
		Size = UDim2.new(0, self.displayWidth, 0, textHeight),
		Parent = self:GetContentInstance()
	}
	local timestamp_label = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 4, 0, 0),
		Size = UDim2.new(1, -8, 0, 12),
		Text = timestamp,
		TextColor3 = Color3.new(0.75, 0.75, 0.75),
		TextStrokeTransparency = 0.6,
		TextWrapped = true,
		TextXAlignment = "Left",
		Parent = message_frame
	}
	local speaker_label = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 64, 0, 0),
		Size = UDim2.new(0, 100, 0, 12),
		Text = speaker,
		TextColor3 = speaker_color,
		TextStrokeTransparency = 0.6,
		Parent = message_frame
	}
	local message_label = RBXInstance.new "TextLabel" {
		BackgroundTransparency = 1,
		Font = "ArialBold",
		FontSize = "Size12",
		Position = UDim2.new(0, 4, 0, 0),
		Size = UDim2.new(1, -8, 1, 0),
		Text = message,
		TextColor3 = Color3.new(1, 1, 1),
		TextStrokeTransparency = 0.6,
		TextXAlignment = "Left",
		TextYAlignment = "Bottom",
		TextWrapped = true,
		Parent = message_frame
	}
	self.displayItems[#self.displayItems + 1] = message_frame
	local maxLines = self.displayMaxLines
	local maxHeight = maxLines * 12
	local newHeight = self.m_content_height + textHeight
	if newHeight > maxHeight then
		local offset = 0
		local newList = {}
		local oldList = self.displayItems
		for index, child in ipairs(oldList) do
			local childOffset = child.Size.Y.Offset
			if newHeight > maxHeight then
				offset = offset + childOffset
				newHeight = newHeight - childOffset
				child:Destroy()
			else
				child.Position = child.Position - UDim2.new(0, 0, 0, offset)
				newList[#newList + 1] = child
			end
		end
		self.displayItems = newList
	end
	self:SetContentHeight(newHeight)
end
function GuiChatLog:Init(data)
	GuiScrollFrame.Init(self, data)
	setmetatable(data, GuiChatLog.__default)
	self.displayMaxLines = data.DisplayMaxLines
	self.displayWidth = data.DisplayWidth
	self.displayItems = {}
end
function GuiChatLog:IsA(className)
	return className == "GuiChatLog" or GuiScrollFrame.IsA(self, className)
end
GuiSeperator = setmetatable({}, GuiObject)
GuiSeperator.__index = GuiSeperator
GuiSeperator.__default = {__index = {
	Active = false,
	Position = UDim2.new(0, 0, 0, 0),
	Size = UDim2.new(1, 0, 0, 16),
	Visible = true
}}
function GuiSeperator:Init(data)
	GuiObject.Init(self)
	setmetatable(data, GuiSeperator.__default)
	local base_frame = RBXInstance.new "Frame" {
		BackgroundTransparency = 1,
		RBXInstance.new "Frame" {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BackgroundTransparency = 0.25,
			BorderSizePixel = 0,
			Position = UDim2.new(0.5, -13, 0.5, -1),
			Size = UDim2.new(0, 3, 0, 3),
			RBXInstance.new "Frame" {
				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.75,
				BorderSizePixel = 0,
				Position = UDim2.new(0, -1, 0, -1),
				Size = UDim2.new(0, 5, 0, 5)
			}
		},
		RBXInstance.new "Frame" {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BackgroundTransparency = 0.25,
			BorderSizePixel = 0,
			Position = UDim2.new(0.5, -1, 0.5, -1),
			Size = UDim2.new(0, 3, 0, 3),
			RBXInstance.new "Frame" {
				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.75,
				BorderSizePixel = 0,
				Position = UDim2.new(0, -1, 0, -1),
				Size = UDim2.new(0, 5, 0, 5)
			}
		},
		RBXInstance.new "Frame" {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BackgroundTransparency = 0.25,
			BorderSizePixel = 0,
			Position = UDim2.new(0.5, 11, 0.5, -1),
			Size = UDim2.new(0, 3, 0, 3),
			RBXInstance.new "Frame" {
				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.75,
				BorderSizePixel = 0,
				Position = UDim2.new(0, -1, 0, -1),
				Size = UDim2.new(0, 5, 0, 5)
			}
		}
	}
	self.m_base_instance = base_frame
	self:SetActive(data.Active)
	self:SetPosition(data.Position)
	self:SetSize(data.Size)
	self:SetVisible(data.Visible)
	self:SetParent(data.Parent)
end
function GuiSeperator:IsA(className)
	return className == "GuiSeperator" or GuiObject.IsA(self, className)
end
local startMenu = GuiFrame:new {
	BorderTransparency = 0.5,
	Position = UDim2.new(0, -4, 0, -4),
	Size = UDim2.new(0, 68, 1, 8),
	Parent = GuiService
}
GuiSeperator:new {
	Position = UDim2.new(0, 0, 0, 5),
	Parent = startMenu
}
GuiSeperator:new {
	Position = UDim2.new(0, 0, 1, -85),
	Parent = startMenu
}
local networkButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Mnemonic = "Q",
	Position = UDim2.new(0, 4, 1, -647),
	Text = "Network",
	Parent = startMenu
}
local chatLogButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Mnemonic = "E",
	Position = UDim2.new(0, 4, 1, -475),
	Text = "Chat log",
	Parent = startMenu
}
local outputButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Mnemonic = "R",
	Position = UDim2.new(0, 4, 1, -283),
	Text = "Output",
	Parent = startMenu
}
local toolsButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Mnemonic = "T",
	Position = UDim2.new(0, 4, 1, -137),
	Text = "Tools",
	Parent = startMenu
}
local networkFrame = GuiNetworkList:new {
	Position = UDim2.new(0, 66, 1, -647),
	Size = UDim2.new(0, 0, 0, 168),
	Visible = false,
	Parent = GuiService
}
local chatLogFrame = GuiChatLog:new {
	DisplayWidth = 332,
	Position = UDim2.new(0, 66, 1, -475),
	Size = UDim2.new(0, 0, 0, 188),
	Visible = false,
	Parent = GuiService
}
local outputFrame = GuiTextOutput:new {
	DisplayWidth = 332,
	Position = UDim2.new(0, 66, 1, -283),
	Size = UDim2.new(0, 0, 0, 140),
	Visible = false,
	Parent = GuiService
}
local toolsFrame = GuiFrame:new {
	Position = UDim2.new(0, 66, 1, -137),
	Size = UDim2.new(0, 0, 0, 52),
	Visible = false,
	Parent = GuiService
}
local toggleCharacterButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 1, 0, 1),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Enable character",
	Parent = toolsFrame
}
local resetCharacterButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 1, 0, 23),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Reset character",
	Parent = toolsFrame
}
local clearWorkspaceButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 110, 0, 1),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Clear workspace",
	Parent = toolsFrame
}
local clearScriptButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 110, 0, 23),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Clear all",
	Parent = toolsFrame
}
local fixLightingButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 219, 0, 1),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Fix lighting",
	Parent = toolsFrame
}
local reloadCommandsButton = GuiTextButton:new {
	BackgroundTransparency = 0.9,
	Position = UDim2.new(0, 219, 0, 23),
	Size = UDim2.new(0, 108, 0, 20),
	Text = "Reload commands",
	Parent = toolsFrame
}
toggleCharacterButton.Activated:connect(function()
	local enabled = not PlayerControl.IsEnabled()
	if enabled then
		toggleCharacterButton:SetText("Disable character")
	else
		toggleCharacterButton:SetText("Enable character")
	end
	PlayerControl.SetEnabled(enabled)
end)
resetCharacterButton.Activated:connect(function()
	PlayerControl.ResetCharacter()
end)
clearWorkspaceButton.Activated:connect(function()
	Network.TransmitServer("Utility.CleanWorkspace()")
end)
clearScriptButton.Activated:connect(function()
	Network.TransmitServer("Utility.CleanWorkspaceAndScripts()")
end)
fixLightingButton.Activated:connect(function()
	Utility.CleanLighting()
end)
reloadCommandsButton.Activated:connect(function()
	UserInterface.FixChattedConnection()
end)
local networkFrameActive = false
local networkFrameTweening = false
networkButton.Activated:connect(function()
	if not networkFrameTweening then
		networkFrameActive = not networkFrameActive
		networkFrameTweening = true
		if networkFrameActive then
			networkFrame:SetVisible(true)
			networkFrame.m_base_instance:TweenSize(UDim2.new(0, 276, 0, 168), nil, nil, 0.5)
			wait(0.5)
		else
			networkFrame.m_base_instance:TweenSize(UDim2.new(0, 0, 0, 168), nil, nil, 0.5)
			wait(0.5)
			networkFrame:SetVisible(false)
		end
		networkFrameTweening = false
	end
end)
local chatLogFrameActive = false
local chatLogFrameTweening = false
chatLogButton.Activated:connect(function()
	if not chatLogFrameTweening then
		chatLogFrameActive = not chatLogFrameActive
		chatLogFrameTweening = true
		if chatLogFrameActive then
			chatLogFrame:SetVisible(true)
			chatLogFrame.m_base_instance:TweenSize(UDim2.new(0, 360, 0, 188), nil, nil, 0.5)
			wait(0.5)
		else
			chatLogFrame.m_base_instance:TweenSize(UDim2.new(0, 0, 0, 188), nil, nil, 0.5)
			wait(0.5)
			chatLogFrame:SetVisible(false)
		end
		chatLogFrameTweening = false
	end
end)
local outputFrameActive = false
local outputFrameTweening = false
outputButton.Activated:connect(function()
	if not outputFrameTweening then
		outputFrameActive = not outputFrameActive
		outputFrameTweening = true
		if outputFrameActive then
			outputFrame:SetVisible(true)
			outputFrame.m_base_instance:TweenSize(UDim2.new(0, 360, 0, 140), nil, nil, 0.5)
			wait(0.5)
		else
			outputFrame.m_base_instance:TweenSize(UDim2.new(0, 0, 0, 140), nil, nil, 0.5)
			wait(0.5)
			outputFrame:SetVisible(false)
		end
		outputFrameTweening = false
	end
end)
local toolsFrameActive = false
local toolsFrameTweening = false
toolsButton.Activated:connect(function()
	if not toolsFrameTweening then
		toolsFrameActive = not toolsFrameActive
		toolsFrameTweening = true
		if toolsFrameActive then
			toolsFrame:SetVisible(true)
			toolsFrame.m_base_instance:TweenSize(UDim2.new(0, 336, 0, 52), nil, nil, 0.5)
			wait(0.5)
		else
			toolsFrame.m_base_instance:TweenSize(UDim2.new(0, 0, 0, 52), nil, nil, 0.5)
			wait(0.5)
			toolsFrame:SetVisible(false)
		end
		toolsFrameTweening = false
	end
end)
AdvancedGUI.startMenu = startMenu
AdvancedGUI.networkFrame = networkFrame
AdvancedGUI.outputFrame = outputFrame
AdvancedGUI.toolsFrame = toolsFrame
AdvancedGUI.chatLogFrame = chatLogFrame
AdvancedGUI.toggleCharacterButton = toggleCharacterButton
AdvancedGUI.reloadCommandsButton = reloadCommandsButton
function AdvancedGUI.Print(...)
	AdvancedGUI.outputFrame:Print(...)
end
function AdvancedGUI.PrintFormat(...)
	AdvancedGUI.outputFrame:PrintFormat(...)
end
function AdvancedGUI.PrintChatLog(speaker, message)
	AdvancedGUI.chatLogFrame:Chat(speaker, message)
end
for _, entry in Logger.NodeIterator, Logger.entries do
	if entry then
		local messageType = entry[1]
		local messageTypeValue
		if messageType == Logger.MessageType.Error then
			messageTypeValue = Logger.MessageType.Severe.Value
		else
			messageTypeValue = messageType.Value
		end
		AdvancedGUI.outputFrame:PrintFormat(Logger.MESSAGE_TYPE_SETTINGS[messageTypeValue], entry[2])
	else
		break
	end
end
]=])
Module.Create("SBTools", string.format([[
SBTools.source_name = %q
SBTools.local_script, SBTools.server_script = ...
local NewLocalScript, NewScript = _RBX.NewLocalScript, _RBX.NewScript
if NewLocalScript and NewScript then
	function SBTools.NewLocalScript(name, source, parent)
		local script
		if parent then
			script = NewLocalScript(source, parent)
		else
			script = NewLocalScript(source, Game)
			script.Parent = nil
		end
		script.Disabled = true
		script.Name = name
		return script
	end
	function SBTools.NewScript(name, source, parent)
		local script
		if parent then
			script = NewScript(source, parent)
		else
			script = NewScript(source, Game)
			script.Parent = nil
		end
		script.Disabled = true
		script.Name = name
		return script
	end
	function SBTools.WaitForScriptReady()
	end
elseif SBTools.local_script then
	SBTools.ScriptReady = RbxUtility.CreateSignal()
	function SBTools.NewLocalScript(name, source, parent)
		local script = SBTools.local_script:Clone()
		local value = script:FindFirstChild(SBTools.source_name)
		value.Value = source
		value.Changed:connect(function()
			if value.Value ~= source then
				value.Value = source
			end
		end)
		script.Name = name
		script.Parent = parent
		return script
	end
	function SBTools.NewScript(name, source, parent)
		local script = SBTools.server_script:Clone()
		local value = script:FindFirstChild(SBTools.source_name)
		value.Value = source
		value.Changed:connect(function()
			if value.Value ~= source then
				value.Value = source
			end
		end)
		script.Name = name
		script.Parent = parent
		return script
	end
	function SBTools.WaitForScriptReady()
		if not SBTools.server_script then
			SBTools.ScriptReady:wait()
		end
	end
	if SBTools.local_script then
		local local_script = SBTools.local_script
		local_script.Archivable = true
		SBTools.local_script = local_script:Clone()
		pcall(local_script.Destroy, local_script)
	end
	if SBTools.server_script then
		local server_script = SBTools.server_script
		server_script.Archivable = true
		SBTools.server_script = server_script:Clone()
		pcall(server_script.Destroy, server_script)
	else
		for _, child in ipairs(Workspace:GetChildren()) do
			if child.ClassName == "Script" and child:FindFirstChild(SBTools.source_name) then
				local server_script = child:Clone()
				local source_value = server_script:FindFirstChild(SBTools.source_name)
				if source_value then
					source_value.Value = ""
					server_script.Disabled = true
					SBTools.server_script = server_script
					SBTools.ScriptReady:fire()
				end
				break
			end
		end
		if not SBTools.server_script then
			local connection
			connection = Workspace.DescendantAdded:connect(function(child)
				wait()
				if not SBTools.server_script and child.ClassName == "Script" and child:FindFirstChild(SBTools.source_name) then
					local server_script = child:Clone()
					local source_value = server_script:FindFirstChild(SBTools.source_name)
					if source_value then
						connection:disconnect()
						source_value.Value = ""
						server_script.Disabled = true
						SBTools.server_script = server_script
						SBTools.ScriptReady:fire()
					end
				end
			end)
		end
	end
end
]], source_value_name), local_script_template)
local script_id = math.floor(math.random() * 1e9)
Module.Create("Network", [[
Network.script_name, Network.script_id, Network.controller_id = ...
Network.server_id = Network.controller_id + 1
Network.script_ids = {}
Network.PACKET_FORMAT = "PACKET/" .. _SessionID .. "/%s"
Network.encryption_key = {math.floor(_SessionID * 256 + 199 % 256), math.floor(_SessionID + 82 % 256), math.floor(_SessionID / 256 + 22 % 256)}
function Network.SendPacket(name, value, ...)
	local packet = Instance.new("StringValue")
	local arguments = {...}
	local count = select("#", ...)
	packet.Name = name .. "/" .. count
	packet.Value = Network.Encrypt(value, Network.encryption_key)
	local parent = packet
	for i = 1, count do
		local argument = arguments[i]
		local arg_type = Utility.GetRobloxType(argument)
		local arg_value = Instance.new((arg_type or "Object") .. "Value", parent)
		arg_value.Name = "_"
		if arg_type then
			arg_value.Value = argument
		end
		parent = arg_value
	end
	packet.Parent = ReplicatedStorage
	pcall(Debris.AddItem, packet, 90)
end
function Network.Encrypt(message, key)
	local key_bytes
	if type(key) == "string" then
		key_bytes = {}
		for key_index = 1, #key do
			key_bytes[key_index] = string.byte(key, key_index)
		end
	else
		key_bytes = key
	end
	local message_length = #message
	local key_length = #key_bytes
	local message_bytes = {}
	for message_index = 1, message_length do
		message_bytes[message_index] = string.byte(message, message_index)
	end
	local result_bytes = {}
	local random_seed = 0
	for key_index = 1, key_length do
		random_seed = (random_seed + key_bytes[key_index] * key_index) * 37789 + 60061
		random_seed = (random_seed - random_seed % 256) / 256 % 65536
	end
	for message_index = 1, message_length do
		local message_byte = message_bytes[message_index]
		for key_index = 1, key_length do
			local key_byte = key_bytes[key_index]
			local result_index = message_index + key_index - 1
			local result_byte = message_byte + (result_bytes[result_index] or 0)
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			result_byte = result_byte + key_byte
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			random_seed = (random_seed * 37789 + 60061) % 65536
			result_byte = result_byte + (random_seed - random_seed % 256) / 256
			if result_byte > 255 then
				result_byte = result_byte - 256
			end
			result_bytes[result_index] = result_byte
		end
	end
	local result_characters = {}
	local result_next_index = 1
	for result_index = 1, #result_bytes do
		local result_byte = result_bytes[result_index]
		if result_byte == 0 then
			result_characters[result_next_index] = "\1"
			result_characters[result_next_index + 1] = "\1"
			result_next_index = result_next_index + 2
		elseif result_byte == 1 then
			result_characters[result_next_index] = "\1"
			result_characters[result_next_index + 1] = "\2"
			result_next_index = result_next_index + 2
		else
			result_characters[result_next_index] = string.char(result_byte)
			result_next_index = result_next_index + 1
		end
	end
	return table.concat(result_characters)
end
function Network.Print(messageTypeValue, message)
	if Network.script_id ~= Network.controller_id then
		Network.TransmitController(string.format("Logger.print(%s, %q, false)", Utility.ToString(messageTypeValue), "[" .. tostring

(Network.script_name) .. "]: " .. message))
	end
end
function Network.Register(name, id)
	Network.script_ids[tostring(name)] = tonumber(id)
end
function Network.StoreModule(id, module)
	Network.Transmit(id, string.format("Module.Store(%q, %q)", module.name, module.source))
end
function Network.Transmit(target, source, ...)
	local targetType = type(target)
	if targetType ~= "number" and targetType ~= "string" then
		Logger.printf("Severe", "Bad argument #1 to Network.Transmit (number/string expected, got %s)", targetType)
		return
	end
	local sourceType = type(source)
	if sourceType ~= "string" then
		Logger.printf("Severe", "Bad argument #2 to Network.Transmit (string expected, got %s)", sourceType)
		return
	end
	if targetType == "string" then
		local nocaseTarget = Utility.CaseInsensitivePattern(target)
		if target == "%me" or (Player and (target == "^" .. tostring(Player) .. "$")) then
			Network.Transmit(Network.script_id, source, ...)
		else
			for name, value in pairs(Network.script_ids) do
				if string.find(name, nocaseTarget) then
					Network.Transmit(value, source, ...)
				end
			end
		end
	elseif targetType == "number" then
		Network.SendPacket(string.format(Network.PACKET_FORMAT, tostring(target)), source, ...)
	end
end
function Network.TransmitController(source, ...)
	Network.Transmit(Network.controller_id, source, ...)
end
function Network.TransmitModule(id, module, ...)
	local moduleType = type(module)
	if moduleType == "table" then
		local name = module.name
		local nameType = type(name)
		if nameType == "string" then
			local source = module.source
			local sourceType = type(source)
			if sourceType == "string" then
				Network.Transmit(id, string.format("Module.Create(%q, %q, ...)", name, source), ...)
			else
				Logger.print("Severe", "Bad module source in Network.TransmitModule (string expected, got %s)", sourceType)
			end
		else
			Logger.print("Severe", "Bad module name in Network.TransmitModule (string expected, got %s)", nameType)
		end
	else
		Logger.print("Severe", "Bad argument #2 to Network.TransmitModule (table expected, got %s)", moduleType)
	end
end
function Network.TransmitServer(source, ...)
	Network.Transmit(Network.server_id, source, ...)
end
if Network.script_id ~= Network.controller_id then
	for _, entry in Logger.NodeIterator, Logger.entries do
		Network.Print(entry[1].Value, entry[2])
	end
end
if Network.script_id ~= Network.server_id then
	Network.Register("<SERVER>", Network.server_id)
end
Network.Register(Network.script_name, Network.script_id)
]], "", script_id, script_id)
Module.Create("NetworkReceiver", [[
local x,y,d,u,h,a,b,c,z,l,dc,ek,qp,_l,_p=string.match,function(o)return o.Value end,game:service"ReplicatedStorage",function(r)return r:FindFirstChild"_"or 

r.ChildAdded:wait()end,game:service"Debris",...
if not a then a,b=x(script.Name,"(%d+)/(%d+)")end
c=string.format("~%X",a)if not shared[c]then
shared[c]=true
function dc(a,bz)local c,d,k,g,h,f,j,n,s,i,l,m,p,r,b=#a,#bz,0,0,1,{},{},{},{}if type(bz)=="string" then b={}for u=1,d do b[u]=string.byte(bz,u)end else b=bz 

end
while h<=c do i=string.byte(a,h)g=g+1 if i==1 then h=h+1 f[g]=string.byte(a,h)-1 else f[g]=i end h=h+1 end
for u=1,d do k=(k+b[u]*u)*37789+60061 k=(k-k%256)/256%65536 end for l=1,(g-d+1)*d do k=(k*37789+60061)%65536 j[l]=(k-k%256)/256 end
l=#j m=b[d]for o=g,d,-1 do p=f[o]-m if p<0 then p=p+256 end
p=p-j[l]l=l-1 if p<0 then p=p+256 end
for q=d-1,1,-1 do o=o-1 r=f[o]-b[q]if r<0 then r=r+256 end
r=r-p if r<0 then r=r+256 end r=r-j[l]l=l-1 if r<0 then r=r+256 end f[o]=r end
n[o]=p end for t=1,#n do s[t]=string.char(n[t])end return table.concat(s)end
if not _ENV then _ENV,N_ENV,script.Parent=getfenv(1),function(w)_ENV=w setfenv(2,w)end end
qp,ek,c,z=function(m)_l=_ENV.Logger if _l then _p=_l.print if _p then _p("Severe",m,false)return end end _ENV.print(m)end,{math.floor

(a*256+199%256),math.floor(a+82%256),math.floor(a/256+12%256)},"^PACKET/"..a.."/"..b.."/(%d+)$",function(p)local e,f,g,m,n,q,s,v q=x(p.Name,c)if 

p:IsA"StringValue" and q then
h:AddItem(p,0)g,e,n,f,m=p,{},0,loadstring(dc(p.Value,ek))if f then
for i=1,q do
g,n=u(g),n+1 s,v=pcall(y,g)if s then e[n]=v end
end Spawn(function()s,m=ypcall(setfenv(f,_ENV),unpack(e))if not s then qp(m)end
end)else qp(m)end end end
d.ChildAdded:connect(z)for _,p in ipairs(d:children())do z(p)end
for i=1,10 do Delay(i,function()l=Instance.new"StringValue"h:AddItem(l,10)l.Name="ACKNOWLEDGE/"..a.."/"..b l.Value=tostring

(Game:service"Players".LocalPlayer)l.Parent=d end)end
end]], session_id, script_id)
Module.Store("ChatBubble", [[
local FONT_CUSTOM_A_SRC, FONT_CUSTOM_A, TextAlignment, LoadFixedFont, LoadFont, DrawTextNetwork, DrawMultilineTextNetwork, ConfigureChatBubble, 

CreateChatBubble, WrapText, chat_bubbles
FONT_CUSTOM_A_SRC = 

"03E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8000000000000000820820020001451400000000053E53E50000872870AF00000CB4216980008518AA468

0008208000000004208208100010208208400000918900000000208F88200000000008210000000F8000000000000820000210420840001C9AACA270000860820870001C884210F8003E09C0A270

000431493E10003E83C0A270001C83C8A270003E08420820001C89C8A270001C8A278270000820000820000020800821000019881818000003E03E000000C0C08CC0001C88420020001C8AABA070

001C8A2FA288003C8BC8A2F0001C8A082270003C8A28A2F0003E83C820F8003E83C82080001C8A09A27800228BE8A288001C2082087000020820A2700"
.. 

"022938922880020820820F80022DAAAA2880022CAA9A288001C8A28A270003C8A2F2080001C8A28AC58003C8A2F2488001C81C0A270003E2082082000228A28A27000228A28942000228AAAB688

002250852288002289420820003E084210F8000E208208380010208104080038208208E00008522000000000000000F800102040000000007027A2780820838924E0000072082270008208E49238

0000722FA070000C41C4104000007A278270002082CCA288000801820870000400C114200020828C28900018208208700000D2AAAAA80000B328A28800007228A2700000E2493882000039248E08

2000B328208000007A0702F0000870820A1000008A28A66800008A28942000008AAAAA500000894214880000894210800000F84210F80188210208180008208208200C08204208C0000001AB0000

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F80"
.. 

"03E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F80"
.. 

"03E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8

003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F8003E8A28A2F80"
FONT_CUSTOM_A = {}

ChatBubble.THEME = {}
ChatBubble.THEME.AQUA = {
	Name = "Aqua",
	Background = Color3.new(0, 1 / 3, 0.5),
	Foreground = Color3.new(2 / 3, 1, 1)
}
ChatBubble.THEME.CLASSIC = {
	Name = "Classic",
	Background = Color3.new(0, 0, 0),
	Foreground = Color3.new(1, 1, 1)
}
ChatBubble.THEME.CRIMSON = {
	Name = "Crimson",
	Background = Color3.new(0, 0, 0),
	Foreground = Color3.new(0.9, 0, 0)
}
ChatBubble.THEME.GRAPE = {
	Name = "Grape",
	Background = Color3.new(0.25, 0, 0.25),
	Foreground = Color3.new(1, 2 / 3, 1)
}
ChatBubble.THEME.LIBERATION = {
	Name = "Liberation",
	Background = Color3.new(1 / 6, 3 / 7, 3 / 7),
	Foreground = Color3.new(1, 1, 1)
}
ChatBubble.THEME.PASSION = {
	Name = "Passion",
	Background = Color3.new(0.5, 0, 0),
	Foreground = Color3.new(1, 1, 1)
}
ChatBubble.THEME.PURPLE = {
	Name = "Purple",
	Background = Color3.new(0.25, 0, 0.25),
	Foreground = Color3.new(1, 1, 1)
}
ChatBubble.THEME.RAINBOW = {
	Name = "Rainbow",
	Background = function(bubble_info)
		local billboard, frame = bubble_info[5], bubble_info[6]
		TaskScheduler.Start(function()
			while billboard:IsDescendantOf(Workspace) do
				local red, green, blue = Utility.GetRainbowRGB(tick())
				frame.BackgroundColor3 = Color3.new(0.6 * red, 0.6 * green, 0.65 * blue)
				RunService.Stepped:wait()
			end
		end)
	end,
	Foreground = Color3.new(1, 1, 1)
}
ChatBubble.THEME.TEAL = {
	Name = "Teal",
	Background = Color3.new(0, 1 / 3, 0.5),
	Foreground = Color3.new(1, 1, 1)
}

function ChatBubble.GetTheme()
	return ChatBubble.theme_info
end
function ChatBubble.SetTheme(theme_info)
	if type(theme_info) == "string" then
		theme_info = string.lower(theme_info)
		for key, info in pairs(ChatBubble.THEME) do
			if info.Name:lower():match(theme_info) then
				ChatBubble.SetTheme(info)
				break
			end
		end
		return
	end
	ChatBubble.theme_info = theme_info
	ChatBubble.background_color = theme_info.Background
	ChatBubble.font = LoadFont(ChatBubble.FONT_DEFAULT, theme_info.Foreground)
	Logger.printf("Info", "Theme has been set to %q in ChatBubble", theme_info.Name)
end

do
local floor = math.floor
local max = math.max
local asc = string.byte
local chr = string.char
local find = string.find
local gmatch = string.gmatch
local sub = string.sub
local insert = table.insert
local type = type
local unpack = unpack

local PopIntegerBit

TextAlignment = setmetatable({
	[0] = 0,
	[1] = 1,
	[2] = 2,
	Left = 0,
	Center = 1,
	Right = 2
}, {
	__call = function(self, ...)
		local argc = #{...}
		if argc == 0 then
			return 0
		else
			local arg = (...)
			local value = rawget(self, arg)
			if value then
				return value
			else
				local arg_type = type(arg)
				error("Invalid value" .. ((arg_type == "number") and (" " .. arg) or ((arg_type == "string") and (" \"" .. arg .. "\"") or 

"")) .. " for enum TextAlignment")
			end
		end
	end
})

function PopIntegerBit(value, bit)
	if value >= bit then
		return 1, value - bit
	else
		return 0, value
	end
end
function LoadFixedFont(dest, src, height, width)
	local n = #src / 64 - 1
	local bit_index = 0
	local symbol_bits = width * height
	for i = 0, 255 do
		local char_data = {}
		for j = 1, height do
			char_data[j] = {}
		end
		dest[i] = char_data
	end
	for i = 1, #src do
		local buffer = tonumber(sub(src, i, i), 16)
		for j = 1, 4 do
			local code = floor(bit_index / symbol_bits)
			local row = floor(bit_index / width) % height + 1
			local column = bit_index % width + 1
			dest[code][row][column], buffer = PopIntegerBit(buffer, 8)
			buffer = buffer * 2
			bit_index = bit_index + 1
		end
	end
end
function LoadFont(font_data, color)
	local font_obj = {}
	for character, char_data in pairs(font_data) do
		local code = character
		if type(code) ~= "number" then
			code = asc(character)
		end
		local height = #char_data
		local width = #char_data[1]
		local pixel_h = 1 / height
		local pixel_w = 1 / width
		local pixel_size = UDim2.new(pixel_w, 0, pixel_h, 0)
		local frame = Instance.new("Frame")
		frame.BackgroundTransparency = 1
		frame.Name = ""
		for y = 1, height do
			local row = char_data[y]
			for x = 1, width do
				local opacity = row[x]
				if opacity ~= 0 then
					local pixel = Instance.new("Frame", frame)
					pixel.BackgroundColor3 = color
					pixel.BorderSizePixel = 0
					pixel.Name = ""
					pixel.Position = UDim2.new(x * pixel_w, 0, y * pixel_h, 0) - pixel_size
					pixel.Size = pixel_size -- + UDim2.new(0, 0, 0, 1) -- correction
					-- ^ never mind that correction, fixed by changing font size to 12x16 instead of 13x17
					if opacity then
						pixel.BackgroundTransparency = 1 - opacity
					end
				end
			end
		end
		font_obj[code] = {frame, height, width}
	end
	return font_obj
end
function DrawTextNetwork(text, font, size, delay_offset)
	if #text == 0 then
		text = " "
	end
	local frame = Instance.new("Frame")
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	local objects = {}
	local length = #text
	local height = 0
	local width = 0
	for i = 1, length do
		local character = sub(text, i, i)
		local code = asc(character)
		local char_data = assert(font[code] or FONT_SYMBOL_MISSING, "FONT ERROR: '" .. character .. "' (" .. code .. ") not found")
		local char_proto, char_h, char_w = unpack(char_data)
		objects[i] = char_data
		height = max(char_h, height)
		width = width + char_w
	end
	local offset = 0
	local punctuation_delay = 0
	for i = 1, length do
		delay(delay_offset + (i + punctuation_delay - 1) / 30, function()
			local char_data = objects[i]
			local char_proto, char_h, char_w = unpack(char_data)
			local char_obj = char_proto:Clone()
			char_obj.Position = UDim2.new(offset / width, 0, 0, 0)
			char_obj.Size = UDim2.new(char_w / width, 0, 1, 0)
			char_obj.Parent = frame
			offset = offset + char_w
		end)
		local character = sub(text, i, i)
		if character == "." then
			punctionation_delay = punctuation_delay + 3
		elseif character == "?" or character == "!" then
			punctionation_delay = punctuation_delay + 2
		elseif character == ";" or character == "~" then
			punctionation_delay = punctuation_delay + 1
		end
	end
	local ratio = (height == 0) and (0) or (width / height)
	frame.Size = UDim2.new(size.X.Scale * ratio, size.X.Offset * ratio, size.Y.Scale, size.Y.Offset)
	return frame, height, width, (length + punctuation_delay) / 30
end
function DrawMultilineTextNetwork(text, font, size, delay_offset, ...)
	local align = TextAlignment(...)
	local frame = Instance.new("Frame")
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	local height = 0
	local width = 0
	local objects = {}
	for line in gmatch(text .. "\n", "([^\n]*)\n") do
		local line_obj, line_h, line_w, line_delay = DrawTextNetwork(line, font, size, delay_offset)
		insert(objects, {line_obj, line_h, line_w})
		height = height + line_h
		width = max(line_w, width)
		delay_offset = delay_offset + line_delay
	end
	local offset = 0
	for index, line_data in ipairs(objects) do
		local line_obj, line_h, line_w = unpack(line_data)
		local align_offset
		if align == TextAlignment.Left then
			align_offset = 0
		elseif align == TextAlignment.Center then
			align_offset = 0.5 - line_w / width / 2
		elseif align == TextAlignment.Right then
			align_offset = 1 - line_w / width
		end
		line_obj.Position = UDim2.new(align_offset, 0, offset / height, 0)
		line_obj.Parent = frame
		offset = offset + line_h
	end
	local line_count = #objects
	local ratio = (height == 0) and (0) or (line_count * width / height)
	frame.Size = UDim2.new(size.X.Scale * ratio, size.X.Offset * ratio, size.Y.Scale * line_count, size.Y.Offset * line_count)
	return frame, height, width
end
end

LoadFixedFont(FONT_CUSTOM_A, FONT_CUSTOM_A_SRC, 8, 6)
ChatBubble.FONT_DEFAULT = FONT_CUSTOM_A
ChatBubble.SetTheme("Rainbow")

chat_bubbles = {}

function CreateChatBubble(bubble_info)
	local creation_time, text, backup = bubble_info[1], bubble_info[2], bubble_info[8]
	local billboard, frame, label
	if backup and false then
		billboard = backup:Clone()
		frame = billboard.Frame
		label = frame.Label
		bubble_info[5] = billboard
		bubble_info[6] = frame
		bubble_info[7] = label
		billboard.Parent = Workspace
	else
		label = DrawMultilineTextNetwork(text, bubble_info[9], UDim2.new(0, 12, 0, 16), creation_time - time(), "Center")
		label.Name = "Label"
		label.Position = UDim2.new(0, 16, 0, 16)
		billboard = Instance.new("BillboardGui", Workspace)
		billboard.Adornee = chatAdornee
		billboard.AlwaysOnTop = true
		billboard.Size = UDim2.new(label.Size.X.Scale, label.Size.X.Offset + 32, label.Size.Y.Scale, label.Size.Y.Offset + 32)
		billboard.SizeOffset = Vector2.new(0, 0)
		billboard.StudsOffset = Vector3.new(0, 1, 0)
		frame = Instance.new("Frame", billboard)
		bubble_info[5] = billboard
		bubble_info[6] = frame
		bubble_info[7] = label
		local background_color = bubble_info[10]
		if type(background_color) == "function" then
			background_color(bubble_info)
		else
			frame.BackgroundColor3 = background_color
		end
		frame.BackgroundTransparency = 0.3
		frame.BorderSizePixel = 0
		frame.ClipsDescendants = true
		frame.Name = "Frame"
		frame.Size = UDim2.new(1, 0, 0, 0)
		label.Parent = frame
		-- bubble_info[8] = billboard:Clone()
	end
end
local tween_time = 0.3
function ConfigureChatBubble(bubble_info)
	local creation_time, destruction_time, billboard, frame = bubble_info[1], bubble_info[3], bubble_info[5], bubble_info[6]
	if not billboard or billboard.Parent ~= workspace then
		CreateChatBubble(bubble_info)
		billboard, frame = bubble_info[5], bubble_info[6]
	end
	if billboard.Adornee ~= chatAdornee then
		billboard.Adornee = chatAdornee
	end
	local current_time = time()
	local elapsed_time = current_time - creation_time
	local remaining_time = destruction_time - current_time
	if remaining_time < 0 then
		bubble_info[4] = false
		billboard:Destroy()
		return false
	elseif remaining_time < tween_time then
		local tween_progress = math.sin(remaining_time * math.pi / (tween_time * 2))
		frame.Size = UDim2.new(1, 0, tween_progress, 0)
	elseif elapsed_time < tween_time then
		local tween_progress = math.sin(elapsed_time * math.pi / (tween_time * 2))
		frame.Size = UDim2.new(1, 0, tween_progress, 0)
	elseif frame.Size ~= UDim2.new(1, 0, 1, 0) then
		frame.Size = UDim2.new(1, 0, 1, 0)
	end
	return true
end
function ChatBubble.MainLoop()
	local offset = 0
	local removing = {}
	for index, bubble_info in ipairs(chat_bubbles) do
		if not ConfigureChatBubble(bubble_info) then
			removing[#removing + 1] = index - #removing
		else
			local billboard, frame = bubble_info[5], bubble_info[6]
			local billboard_h = billboard.Size.Y.Offset
			local bubble_h = frame.Size.Y.Scale * billboard_h
			offset = 8 + offset + bubble_h
			billboard.SizeOffset = Vector2.new(0, offset / billboard_h - 0.5)
		end
	end
	for index, bubble_index in ipairs(removing) do
		table.remove(chat_bubbles, bubble_index)
	end
	RunService.Stepped:wait()
end
function WrapText(text, character_limit, line_length_limit)
	if #text > character_limit then
		text = string.sub(text, 1, character_limit - 3) .. "..."
	end
	local text_length = #text
	local line_length = 0
	local i = 0
	while i <= text_length do
		i = i + 1
		local character = string.sub(text, i, i)
		if character == "\t" then
			local tabulation_size = 4 - line_length % 4
			line_length = line_length + tabulation_size
			if line_length >= line_length_limit then
				tabulation_size = line_length - line_length_limit
				line_length = 0
				text_length = text_length + tabulation_size
				text = string.sub(text, 1, i - 1) .. string.rep(" ", tabulation_size) .. "\n" .. string.sub(text, i + 1)
				i = i + tabulation_size + 1
			else
				text_length = text_length + tabulation_size - 1
				text = string.sub(text, 1, i - 1) .. string.rep(" ", tabulation_size) .. string.sub(text, i + 1)
				i = i + tabulation_size - 1
			end
		elseif character == "\n" then
			line_length = 0
		else
			line_length = line_length + 1
			if line_length >= line_length_limit then
				local k = i - line_length + 1
				local success = false
				for j = i, k, -1 do
					if string.match(string.sub(text, j, j), "[ \t]") then
						text = string.sub(text, 1, j - 1) .. "\n" .. string.sub(text, j + 1)
						text_length = text_length + 1
						success = true
						break
					end
				end
				if not success then
					text = string.sub(text, 1, i) .. "\n" .. string.sub(text, i + 1)
					text_length = text_length + 1
				end
				i = i + 1
				line_length = 0
			end
		end
	end
	if #text > character_limit then
		text = string.sub(text, 1, character_limit - 3) .. "..."
	end
	return text
end
function ChatBubble.Create(text, theme)
	local text = WrapText(text, 200, 30)
	local creation_time = time()
	local bubble_info = {creation_time, text, creation_time + 6 + #text / 15, true}
	local previousTheme
	if theme then
		previousTheme = ChatBubble.GetTheme()
		ChatBubble.SetTheme(theme)
	end
	bubble_info[9] = ChatBubble.font
	bubble_info[10] = ChatBubble.background_color
	if previousTheme then
		ChatBubble.SetTheme(previousTheme)
	end
	table.insert(chat_bubbles, 1, bubble_info)
end
TaskScheduler.Start(function()
	while true do
		ChatBubble.MainLoop()
	end
end)
]])
Module.Store("Fragmentation", [[
Fragmentation.AXIS_DATA = {
	{"X", Vector3.new(1, 0, 0)},
	{"Y", Vector3.new(0, 1, 0)},
	{"Z", Vector3.new(0, 0, 1)}
}
function Fragmentation.DamageRegion(region, fragmentationSize, ignoreDescendantsInstance)
	local parts = Workspace:FindPartsInRegion3(region, ignoreDescendantsInstance, 100)
	local splitCount = 0
	for _, part in ipairs(parts) do
		if not Utility.SafeIsA(part, "Terrain") and Fragmentation.SplitPart(part, fragmentationSize) then
			splitCount = splitCount + 1
		end
	end
	return splitCount
end
function Fragmentation.DamageRay(ray, lengthMultiplier, fragmentationSizeFunction, ignoreDescendantsInstance)
	local part, hitPoint
	local rayDirection = ray.Direction
	local shiftedRay = ray
	for attemptCount = 1, lengthMultiplier do
		part, hitPoint = Workspace:FindPartOnRay(shiftedRay, ignoreDescendantsInstance)
		if part then
			break
		else
			shiftedRay = Ray.new(shiftedRay.Origin + rayDirection, rayDirection)
		end
	end
	if part then
		if Utility.SafeIsA(part, "Terrain") then
			local cellPosition = part:WorldToCellPreferSolid(hitPoint)
			part:SetCell(cellPosition.X, cellPosition.Y, cellPosition.Y, Enum.CellMaterial.Empty, Enum.CellBlock.Solid, Enum.CellOrientation.X)
			return true
		else
			return Fragmentation.SplitPart(part, fragmentationSizeFunction((hitPoint - ray.Origin).magnitude))
		end
	end
	return false
end
function Fragmentation.SplitPart(part, fragmentationSize)
	pcall(part.BreakJoints, part)
	local isBlock = Utility.SafeIsA(part, "Part") and part.Shape == Enum.PartType.Block
	local mass = part:GetMass()
	local size = part.Size
	if (isBlock and ((size.X < fragmentationSize and size.Y < fragmentationSize and size.Z < fragmentationSize)
			or (not part.Anchored and mass < 750))) or (not isBlock and mass < 250000) then
		pcall(Game.Destroy, part)
	elseif isBlock then
		local parts = {part}
		part.FormFactor = Enum.FormFactor.Custom
		local model = Instance.new("Model", part.Parent)
		model.Name = "Fragments"
		local partClone = Instance.new("Part")
		-- NOTE: this custom cloning function solves problems with children in the part (especially parts inside the part).
		-- surface inputs and parameters are ignored since fragmentation messes up the structure anyway.
		-- formfactor is is ignored too because it should always be Custom for fragmentation.
		-- shape is ignored too because block is default and it has already been established that the part is a block.
		-- cframe is ignored too because it is set later on.
		partClone.Anchored = part.Anchored
		partClone.Archivable = part.Archivable
		partClone.BackSurface = part.BackSurface
		partClone.BottomSurface = part.BottomSurface
		partClone.BrickColor = part.BrickColor
		partClone.CanCollide = part.CanCollide
		partClone.Elasticity = part.Elasticity
		partClone.FormFactor = Enum.FormFactor.Custom
		partClone.Friction = part.Friction
		partClone.FrontSurface = part.FrontSurface
		partClone.LeftSurface = part.LeftSurface
		partClone.Locked = part.Locked
		partClone.Material = part.Material
		partClone.Reflectance = part.Reflectance
		partClone.RightSurface = part.RightSurface
		partClone.RotVelocity = part.RotVelocity
		partClone.Size = part.Size
		partClone.TopSurface = part.TopSurface
		partClone.Transparency = part.Transparency
		partClone.Velocity = part.Velocity
		for _, data in ipairs(Fragmentation.AXIS_DATA) do
			local axisName, axisNormal = data[1], data[2]
			local axisSize = size[axisName]
			if axisSize >= fragmentationSize then
				size = (Vector3.new(1, 1, 1) - 0.5 * data[2]) * size
				partClone.size = size
				for partIndex = 1, #parts do
					local part = parts[partIndex]
					local cframe = part.CFrame
					part.Size = size
					local clone = partClone:Clone()
					part.CFrame = cframe * CFrame.new((-0.25 * axisSize) * axisNormal)
					clone.CFrame = cframe * CFrame.new((0.25 * axisSize) * axisNormal)
					clone.Parent = model
					parts[#parts + 1] = clone
				end
			end
		end
		for _, part in ipairs(parts) do
			part:MakeJoints()
		end
	else
		return false
	end
	return true
end
]])
Module.Store("GraphicalEffects", [[
local MESH_IDS = {"rbxassetid://15310891"}
local SOUND_IDS = {"rbxassetid://2248511", "rbxassetid://1369158"}
local TEXTURE_IDS = {"rbxassetid://36527089", "rbxassetid://122610943", "rbxassetid://126561317", "rbxassetid://127033719"}
local preloadConnections = {}
local reloadingPreloads = false
function GraphicalEffects.InitPreloads()
	local preload_part = Instance.new("Part")
	GraphicalEffects.preload_part = preload_part
	preload_part.Anchored = true
	preload_part.Archivable = false
	preload_part.BottomSurface = "Smooth"
	preload_part.CanCollide = false
	preload_part.CFrame = CFrame.new(math.huge, math.huge, math.huge)
	preload_part.FormFactor = "Custom"
	preload_part.Locked = true
	preload_part.Name = "Asset Preloader"
	preload_part.Size = Vector3.new(0.2, 0.2, 0.2)
	preload_part.TopSurface = "Smooth"
	preload_part.Transparency = 1
	preloadConnections[preload_part] = preload_part.AncestryChanged:connect(GraphicalEffects.PreloadsAncestryChanged)
	for _, mesh_id in ipairs(MESH_IDS) do
		local mesh = Instance.new("SpecialMesh")
		mesh.MeshType = "FileMesh"
		mesh.MeshId = mesh_id
		preloadConnections[mesh] = mesh.AncestryChanged:connect(GraphicalEffects.PreloadsAncestryChanged)
		mesh.Parent = preload_part
	end
	for _, sound_id in ipairs(SOUND_IDS) do
		local sound = Instance.new("Sound")
		sound.SoundId = sound_id
		sound.Volume = 0
		preloadConnections[sound] = sound.AncestryChanged:connect(GraphicalEffects.PreloadsAncestryChanged)
		sound.Parent = preload_part
	end
	for _, texture_id in ipairs(TEXTURE_IDS) do
		local decal = Instance.new("Decal")
		decal.Texture = texture_id
		preloadConnections[decal] = decal.AncestryChanged:connect(GraphicalEffects.PreloadsAncestryChanged)
		decal.Parent = preload_part
	end
	preload_part.Parent = Workspace
end
function GraphicalEffects.PreloadsAncestryChanged(child, parent)
	if not reloadingPreloads and parent ~= GraphicalEffects.preload_part and parent ~= Workspace then
		reloadingPreloads = true
		for _, connection in pairs(preloadConnections) do
			connection:disconnect()
			preloadConnections[_] = nil
		end
		wait(1)
		reloadingPreloads = false
		GraphicalEffects.InitPreloads()
	end
end
GraphicalEffects.InitPreloads()
-- Hyper beam
function GraphicalEffects.FireSpaceHyperBeam(target, power, duration, radius, height, deviation)
	local stepTime, gameTime = 1 / 30, TaskScheduler.GetCurrentTime()
	local frames = duration * 30
	local beamColorOffset = 0.75 * tick() -- math.random()
	local blastPressure = power * 62500 + 250000
	local beamPart = Instance.new("Part")
	local beamMesh = Instance.new("SpecialMesh", beamPart)
	local explosion = Instance.new("Explosion")
	local sound = Instance.new("Sound", beamPart)
	beamPart.Anchored = true
	beamPart.CanCollide = false
	beamPart.CFrame = CFrame.new(target, target + Vector3.new(deviation * (math.random() - 0.5), deviation * (math.random() - 0.5), height))
	beamPart.FormFactor = "Custom"
	beamPart.Locked = true
	beamPart.Size = Vector3.new(0.2, 0.2, 0.2)
	beamMesh.MeshId = "rbxassetid://15310891"
	beamMesh.MeshType = "FileMesh"
	beamMesh.TextureId = "rbxassetid://36527089"
	local beamGlowPart1 = beamPart:Clone()
	local beamGlowMesh1 = beamMesh:Clone()
	local beamGlowPart2 = beamPart:Clone()
	local beamGlowMesh2 = beamMesh:Clone()
	local beamLight = Instance.new("PointLight", beamPart)
	beamLight.Range = power * 2
	beamLight.Shadows = true
	explosion.BlastPressure = blastPressure
	explosion.BlastRadius = power
	explosion.Position = target
	sound.SoundId = "rbxassetid://2248511"
	sound.Volume = 1
	local explosionHitConnection = explosion.Hit:connect(function(part, distance)
		if not part.Anchored and part:GetMass() < power * power then
			pcall(part.BreakJoints, part)
			part.Color = Color3.new(Utility.GetRainbowRGB(1.5 * gameTime + beamColorOffset))
		end
	end)
	beamPart.Transparency = 0.5
	beamPart.Archivable = false
	beamGlowPart1.Transparency = 0.75
	beamGlowPart2.Transparency = 0.75
	beamGlowMesh1.Parent = beamGlowPart1
	beamGlowPart1.Parent = beamPart
	beamGlowMesh2.Parent = beamGlowPart2
	beamGlowPart2.Parent = beamPart
	beamPart.Parent = workspace
	explosion.Parent = workspace
	for frame = 1, frames do
		local progress = frame / frames
		local alpha = 1 - math.sin(0.5 * math.pi * progress)
		local scale = 0.4 * alpha
		local glowScale1 = alpha * (0.5 + 0.5 * math.sin(math.tau * (8 * gameTime + beamColorOffset)))
		local glowScale2 = alpha * (0.5 + 0.5 * math.cos(math.tau * (8 * gameTime + beamColorOffset)))
		local vertexColor =  Vector3.new(Utility.GetRainbowRGB(1.5 * gameTime + beamColorOffset))
		beamLight.Brightness = 1 - progress
		beamLight.Color = Color3.new(vertexColor.x, vertexColor.y, vertexColor.z)
		beamMesh.Scale = Vector3.new(radius * scale, 9000, radius * scale)
		beamMesh.VertexColor = vertexColor
		beamGlowMesh1.Scale = Vector3.new(1.2 * radius * glowScale1, 9000, 1.2 * radius * glowScale1)
		beamGlowMesh1.VertexColor = vertexColor
		beamGlowMesh2.Scale = Vector3.new(1.2 * radius * glowScale2, 9000, 1.2 * radius * glowScale2)
		beamGlowMesh2.VertexColor = vertexColor
		RunService.Stepped:wait()
		gameTime = TaskScheduler.GetCurrentTime()
		if frame <= 2 then
			local explosion = Instance.new("Explosion")
			explosion.BlastPressure = (1 - progress) * blastPressure
			explosion.BlastRadius = (1 - progress) * power
			explosion.Position = target
			explosion.Parent = Workspace
			if frame == 2 then
				sound:Play()
			end
		end
	end
	pcall(beamPart.Destroy, beamPart)
	explosionHitConnection:disconnect()
end
function GraphicalEffects.SpaceHyperBeam(target, power, duration, radius, height, deviation)
	TaskScheduler.Start(GraphicalEffects.FireSpaceHyperBeam, target, power or 12, duration or 1.5, radius or 6, height or 600, deviation or 20)
end
-- Magic Circle
GraphicalEffects.magicCircleData = {}
GraphicalEffects.MAGIC_CIRCLE_DEFAULT_OFFSET = 6.25
function GraphicalEffects.AnimateMagicCircle(data)
	local frame, direction, magic_circle_model, magic_circle_part, magic_circle_light, magic_circle_decal_back, magic_circle_decal_front, duration, 

stay, magic_circle_adornee_func, magic_circle_offset = unpack(data)
	frame = frame + 1
	data[1] = frame
	local transparency = (frame / duration) ^ stay
	local opacity = 1 - transparency
	if frame == duration then
		pcall(Game.Destroy, magic_circle_model)
		GraphicalEffects.magicCircleData[data] = nil
	else
		if magic_circle_model.Parent ~= Workspace then
			pcall(Utility.SetProperty, magic_circle_model, "Parent", Workspace)
		end
		local magic_circle_adornee = magic_circle_adornee_func()
		magic_circle_position = magic_circle_adornee.Position + direction * magic_circle_offset
		local magic_circle_cframe = CFrame.new(magic_circle_position, magic_circle_position + direction) * CFrame.Angles(0, 0, math.tau * frame / 

25)
		magic_circle_part.CFrame = magic_circle_cframe
		magic_circle_light.Brightness = opacity
		magic_circle_decal_back.Transparency = transparency
		magic_circle_decal_front.Transparency = transparency
	end
end
function GraphicalEffects.CreateMagicCircle(target, magic_circle_scale, magic_circle_image, light_color, duration, stay, magic_circle_adornee_func, 

magic_circle_offset)
	local magic_circle_adornee = magic_circle_adornee_func()
	if magic_circle_adornee then
		local origin = magic_circle_adornee.Position
		local direction = (target - origin).unit
		local magic_circle_position = origin + direction * magic_circle_offset
		local magic_circle_cframe = CFrame.new(magic_circle_position, magic_circle_position + direction)
		local magic_circle_model = Instance.new("Model")
		local magic_circle_part = Instance.new("Part", magic_circle_model)
		local magic_circle_mesh = Instance.new("BlockMesh", magic_circle_part)
		local magic_circle_light = Instance.new("PointLight", magic_circle_part)
		local magic_circle_decal_back = Instance.new("Decal", magic_circle_part)
		local magic_circle_decal_front = Instance.new("Decal", magic_circle_part)
		magic_circle_model.Archivable = false
		magic_circle_part.Anchored = true
		magic_circle_part.BottomSurface = "Smooth"
		magic_circle_part.CanCollide = false
		magic_circle_part.CFrame = magic_circle_cframe
		magic_circle_part.FormFactor = "Custom"
		magic_circle_part.Locked = true
		magic_circle_part.Size = Vector3.new(0.2, 0.2, 0.2)
		magic_circle_part.TopSurface = "Smooth"
		magic_circle_part.Transparency = 1
		magic_circle_mesh.Scale = Vector3.new(60, 60, 0) * magic_circle_scale
		magic_circle_light.Color = light_color
		magic_circle_light.Range = 16 * magic_circle_scale
		magic_circle_light.Shadows = true
		magic_circle_decal_back.Face = "Back"
		magic_circle_decal_back.Texture = magic_circle_image
		magic_circle_decal_front.Face = "Front"
		magic_circle_decal_front.Texture = magic_circle_image
		magic_circle_model.Parent = Workspace
		local data = {0, direction, magic_circle_model, magic_circle_part, magic_circle_light, magic_circle_decal_back, magic_circle_decal_front, 

duration, stay, magic_circle_adornee_func, magic_circle_offset}
		GraphicalEffects.magicCircleData[data] = true
		return data
	end
end
-- Laser of Death
GraphicalEffects.LASER_WIDTH = 0.15
GraphicalEffects.LASER_MAGIC_CIRCLE_DISTANCE = 6.25
GraphicalEffects.laser_data = {}
--GraphicalEffects.fragmentation = {}
function GraphicalEffects.AnimateLaserOfDeath(data)
	local frame, directionOrientation, direction, magic_circle_model, laser_part, laser_mesh, magic_circle_part, magic_circle_light, 

magic_circle_decal_back, magic_circle_decal_front, sound, laser_scale, fragmentation_size, duration, laser_lights, laser_effects, stay, light_effects = 

unpack(data)
	local laser_color = laser_part.Color
	frame = frame + 1
	data[1] = frame
	local transparency = (frame / duration) ^ stay
	local opacity = 1 - transparency
	if frame == 2 then
		sound:Play()
	end
	if frame == duration then
		pcall(Game.Destroy, magic_circle_model)
		GraphicalEffects.laser_data[data] = nil
	else
		if magic_circle_model.Parent ~= Workspace then
			pcall(Utility.SetProperty, magic_circle_model, "Parent", Workspace)
		end
		local laser_distance = 0
		local origin = chatAdornee.CFrame
		if not light_effects then
			direction = (origin * directionOrientation - origin.p).unit
		end
		local magic_circle_position = origin.p + direction * GraphicalEffects.LASER_MAGIC_CIRCLE_DISTANCE
		local magic_circle_cframe = CFrame.new(magic_circle_position, magic_circle_position + direction) * CFrame.Angles(0, 0, math.tau * frame / 

25)
		local loop_scale = (laser_scale - 1) / 10
		for x_offset = -loop_scale, loop_scale, 2 do
			for y_offset = -loop_scale, loop_scale, 2 do
				local origin_position = magic_circle_cframe * Vector3.new(x_offset, y_offset, 0)
				for index = 1, 8 do
					local part, position
					for ray_index = 1, 10 do
						local ray = Ray.new(origin_position + direction * (999 * (ray_index - 1)), direction * 999)
						part, position = Workspace:FindPartOnRay(ray, magic_circle_model)
						if part then
							break
						end
					end
					if part then
						laser_distance = (position - origin_position).magnitude
						if frame % 8 == 1 and index == 1 then
							Instance.new("Explosion", Workspace).Position = position
						end
						if not part:IsA("Terrain") then
							pcall(part.BreakJoints, part)
							local is_block = part:IsA("Part") and part.Shape == Enum.PartType.Block
							local mass = part:GetMass()
							local size = part.Size
							if (is_block and ((size.X < fragmentation_size and size.Y < fragmentation_size and size.Z < 

fragmentation_size) or (not part.Anchored and mass < 750))) or (not is_block and mass < 250000) then
								local part_transparency = math.max(part.Transparency + 0.007 * fragmentation_size, 0.5)
								if part_transparency >= 0.5 then -- temporarily to minimize debris
									pcall(Game.Destroy, part)
								else
									local cframe = part.CFrame
									part.Anchored = false
									part.BrickColor = BrickColor.new("Medium stone grey")
									part.CanCollide = true
									if part:IsA("FormFactorPart") then
										part.FormFactor = "Custom"
									end
									part.Size = size - Vector3.new(0.135, 0.135, 0.135) * fragmentation_size
									part.Transparency = part_transparency
									part.CFrame = cframe + direction * 5
									part.Velocity = part.Velocity + direction * 40
								end
							elseif is_block then
								local parts = {part}
								local model = Instance.new("Model", part.Parent)
								model.Name = "Fragments"
								if size.X >= fragmentation_size then
									size = Vector3.new(0.5, 1, 1) * size
									local archivable = part.Archivable
									local cframe = part.CFrame
									part.FormFactor = "Custom"
									part.Size = size
									part.Archivable = true
									local part_clone = part:Clone()
									part.Archivable = archivable
									part_clone.Archivable = archivable
									part.CFrame = cframe * CFrame.new(-0.5 * size.X, 0, 0)
									part_clone.CFrame = cframe * CFrame.new(0.5 * size.X, 0, 0)
									part_clone.Parent = model
									parts[2] = part_clone
								end
								if size.Y >= fragmentation_size then
									size = Vector3.new(1, 0.5, 1) * size
									for part_index = 1, #parts do
										local part = parts[part_index]
										local archivable = part.Archivable
										local cframe = part.CFrame
										part.FormFactor = "Custom"
										part.Size = size
										part.Archivable = true
										local part_clone = part:Clone()
										part.Archivable = archivable
										part_clone.Archivable = archivable
										part.CFrame = cframe * CFrame.new(0, -0.5 * size.Y, 0)
										part_clone.CFrame = cframe * CFrame.new(0, 0.5 * size.Y, 0)
										part_clone.Parent = model
										table.insert(parts, part_clone)
									end
								end
								if size.Z >= fragmentation_size then
									size = Vector3.new(1, 1, 0.5) * size
									for part_index = 1, #parts do
										local part = parts[part_index]
										local archivable = part.Archivable
										local cframe = part.CFrame
										part.FormFactor = "Custom"
										part.Size = size
										part.Archivable = true
										local part_clone = part:Clone()
										part.Archivable = archivable
										part_clone.Archivable = archivable
										part.CFrame = cframe * CFrame.new(0, 0, -0.5 * size.Z)
										part_clone.CFrame = cframe * CFrame.new(0, 0, 0.5 * size.Z)
										part_clone.Parent = model
										table.insert(parts, part_clone)
									end
								end
								for _, part in ipairs(parts) do
									part:MakeJoints()
								end
							else
								break
							end
						end
					else
						laser_distance = 9990
						break
					end
				end
			end
		end
		local laser_cframe = magic_circle_cframe * CFrame.Angles(-0.5 * math.pi, 0, 0)
		local laser_width = GraphicalEffects.LASER_WIDTH * opacity * laser_scale
		local laser_mesh_offset = Vector3.new(0, 0.5 * laser_distance, 0)	
		laser_part.CFrame = laser_cframe
		if laser_effects then
			local laser_effect_data_1, laser_effect_data_2 = laser_effects[1], laser_effects[2]
			local laser_effect_1, laser_effect_mesh_1 = laser_effect_data_1[1], laser_effect_data_1[2]
			local laser_effect_2, laser_effect_mesh_2 = laser_effect_data_2[1], laser_effect_data_2[2]
			laser_effect_1.CFrame = laser_cframe
			laser_effect_2.CFrame = laser_cframe
			laser_effect_mesh_1.Offset = laser_mesh_offset
			laser_effect_mesh_2.Offset = laser_mesh_offset
			local game_time = time()
			local effect_scale_1 = 0.5 + 0.5 * math.sin(16 * math.pi * game_time)
			local effect_scale_2 = 0.5 + 0.5 * math.cos(16 * math.pi * game_time)
			laser_effect_mesh_1.Scale = 5 * Vector3.new(laser_width * effect_scale_1, laser_distance, laser_width * effect_scale_1)
			laser_effect_mesh_2.Scale = 5 * Vector3.new(laser_width * effect_scale_2, laser_distance, laser_width * effect_scale_2)
			laser_width = laser_width * 0.25
		end
		laser_mesh.Offset = laser_mesh_offset			
		laser_mesh.Scale = 5 * Vector3.new(laser_width, laser_distance, laser_width)
		magic_circle_part.CFrame = magic_circle_cframe
		magic_circle_light.Brightness = opacity
		magic_circle_decal_back.Transparency = transparency
		magic_circle_decal_front.Transparency = transparency
		if light_effects then
			for index, data in ipairs(laser_lights) do
				local laser_spotlight_part, laser_spotlight = data[1], data[2]
				local laser_spotlight_offset = 30 * (index - 1)
				if laser_spotlight_offset <= laser_distance then
					laser_spotlight_part.CFrame = magic_circle_cframe * CFrame.new(0, 0, -laser_spotlight_offset)
					laser_spotlight.Brightness = opacity
					laser_spotlight.Enabled = true
				else
					laser_spotlight.Enabled = false
				end
			end
		end
	end
end
function GraphicalEffects.ShootLaserOfDeath(target, data)
	if chatAdornee then
		data = data or {}
		local brickcolor = data.brickcolor or BrickColor.new("Really black")
		local duration = data.duration or 40
		local fragmentation_size = data.fragmentation_size or 3
		local laser_scale = data.laser_scale or 1
		local light_color = data.light_color or Color3.new(1, 0.5, 1)
		local magic_circle_image = data.magic_circle_image or "rbxassetid://122610943"
		local magic_circle_scale = data.magic_circle_scale or 1
		local sound_volume = data.sound_volume or 1 / 3
		local special_effects = data.special_effects
		local stay = data.stay or 4
		local origin = chatAdornee.CFrame
		local directionOrientation = origin:pointToObjectSpace(target)
		local direction = (target - origin.p).unit
		local magic_circle_position = origin.p + direction * GraphicalEffects.LASER_MAGIC_CIRCLE_DISTANCE
		local magic_circle_cframe = CFrame.new(magic_circle_position, magic_circle_position + direction)
		local magic_circle_model = Instance.new("Model")
		local laser_part = Instance.new("Part", magic_circle_model)
		local laser_mesh = Instance.new("CylinderMesh", laser_part)
		local magic_circle_part = Instance.new("Part", magic_circle_model)
		local magic_circle_mesh = Instance.new("BlockMesh", magic_circle_part)
		local magic_circle_light = Instance.new("PointLight", magic_circle_part)
		local magic_circle_decal_back = Instance.new("Decal", magic_circle_part)
		local magic_circle_decal_front = Instance.new("Decal", magic_circle_part)
		local sound = Instance.new("Sound", magic_circle_part)
		sound.Pitch = 1.25
		sound.SoundId = "rbxassetid://2248511"
		sound.Volume = sound_volume
		magic_circle_model.Archivable = false
		laser_part.Anchored = true
		laser_part.BottomSurface = "Smooth"
		laser_part.BrickColor = brickcolor
		laser_part.CanCollide = false
		laser_part.CFrame = magic_circle_cframe * CFrame.Angles(-0.5 * math.pi, 0, 0)
		laser_part.FormFactor = "Custom"
		laser_part.Locked = true
		laser_part.Size = Vector3.new(0.2, 0.2, 0.2)
		laser_part.TopSurface = "Smooth"
		laser_mesh.Offset = Vector3.new(0, 0, 0)
		laser_mesh.Name = "Mesh"
		laser_mesh.Scale = 5 * laser_scale * Vector3.new(GraphicalEffects.LASER_WIDTH, 0, GraphicalEffects.LASER_WIDTH)
		magic_circle_part.Anchored = true
		magic_circle_part.BottomSurface = "Smooth"
		magic_circle_part.CanCollide = false
		magic_circle_part.CFrame = magic_circle_cframe
		magic_circle_part.FormFactor = "Custom"
		magic_circle_part.Locked = true
		magic_circle_part.Size = Vector3.new(0.2, 0.2, 0.2)
		magic_circle_part.TopSurface = "Smooth"
		magic_circle_part.Transparency = 1
		magic_circle_mesh.Scale = Vector3.new(60, 60, 0) * magic_circle_scale
		magic_circle_light.Color = light_color
		magic_circle_light.Range = 16 * magic_circle_scale
		magic_circle_light.Shadows = true
		magic_circle_decal_back.Face = "Back"
		magic_circle_decal_back.Texture = magic_circle_image
		magic_circle_decal_front.Face = "Front"
		magic_circle_decal_front.Texture = magic_circle_image
		magic_circle_model.Parent = Workspace
		local laser_color = brickcolor.Color
		local laser_lights = {}
		local light_effects = laser_color.r + laser_color.g + laser_color.b > 0.25
		if light_effects then
			local laser_spotlight_part_template = Instance.new("Part")
			local laser_spotlight_light_template = Instance.new("SpotLight", laser_spotlight_part_template)
			laser_spotlight_part_template.Anchored = true
			laser_spotlight_part_template.Anchored = true
			laser_spotlight_part_template.BottomSurface = "Smooth"
			laser_spotlight_part_template.CanCollide = false
			laser_spotlight_part_template.FormFactor = "Custom"
			laser_spotlight_part_template.Locked = true
			laser_spotlight_part_template.Size = Vector3.new(0.2, 0.2, 0.2)
			laser_spotlight_part_template.TopSurface = "Smooth"
			laser_spotlight_part_template.Transparency = 1
			laser_spotlight_light_template.Angle = 45
			laser_spotlight_light_template.Color = laser_color
			laser_spotlight_light_template.Enabled = true
			laser_spotlight_light_template.Name = "Light"
			laser_spotlight_light_template.Range = 60
			for index = 1, 40 do
				local laser_spotlight_part = laser_spotlight_part_template:Clone()
				laser_spotlight_part.CFrame = magic_circle_cframe * CFrame.new(0, 0, -30 * (index - 1))
				laser_spotlight_part.Parent = magic_circle_model
				laser_lights[index] = {laser_spotlight_part, laser_spotlight_part.Light}
			end
		end
		local laser_effects
		if special_effects then
			laser_effects = {}
			local laser_effect_1 = laser_part:Clone()
			laser_effect_1.BrickColor = special_effects
			laser_effect_1.Transparency = 0.5
			local laser_effect_2 = laser_effect_1:Clone()
			laser_effects[1], laser_effects[2] = {laser_effect_1, laser_effect_1.Mesh}, {laser_effect_2, laser_effect_2.Mesh}
			laser_effect_1.Parent = magic_circle_model
			laser_effect_2.Parent = magic_circle_model
		end
		GraphicalEffects.laser_data[{0, directionOrientation, direction, magic_circle_model, laser_part, laser_mesh, magic_circle_part, 

magic_circle_light, magic_circle_decal_back, magic_circle_decal_front, sound, laser_scale, fragmentation_size, duration, laser_lights, laser_effects, stay, 

light_effects}] = true
	end
end
-- Sapient Rock
function GraphicalEffects.SpawnSapientRock(position)
	local part = Instance.new("Part", Workspace)
	local size = 8 + math.random(0, 5)
	part.BottomSurface = "Smooth"
	part.TopSurface = "Smooth"
	part.Material = "Slate"
	part.Locked = true
	part.Shape = "Ball"
	part.FormFactor = "Custom"
	part.Size = Vector3.new(size, size, size)
	part.Position = position
	local bodypos = Instance.new("BodyPosition", part)
	bodypos.maxForce = Vector3.new(0, 0, 0)
	local angry = false
	local damage_ready = true
	local torso_following
	local torso_changed = -1000
	local touched_conn = part.Touched:connect(function(hit)
		local character = hit.Parent
		if character then
			local humanoid
			for _, child in ipairs(character:GetChildren()) do
				if child:IsA("Humanoid") then
					humanoid = child
					break
				end
			end
			if humanoid then
				if angry then
					if damage_ready then
						damage_ready = false
						humanoid:TakeDamage(100)
						wait(1)
						damage_ready = true
						angry = false
						part.BrickColor = BrickColor.new("Medium stone grey")
					end
				else
					local torso = humanoid.Torso
					if torso then
						torso_following = torso
						torso_changed = tick()
					end
				end
			end
		end
	end)
	TaskScheduler.Start(function()
		while part.Parent == Workspace do
			if torso_following then
				bodypos.position = torso_following.Position
				if tick() - torso_changed > 60 or not torso_following.Parent then
					torso_following = nil
					bodypos.maxForce = Vector3.new(0, 0, 0)
					angry = false
					part.BrickColor = BrickColor.new("Medium stone grey")
				else
					local speed = angry and Vector3.new(16, 16, 16) or Vector3.new(6, 0, 6)
					bodypos.maxForce = part:GetMass() * speed
					if part.Position.Y < -250 then
						part.Velocity = Vector3.new()
						part.Position = torso_following.Position + Vector3.new(0, 80, 0)
						part.BrickColor = BrickColor.new("Bright red")
						angry = true
						torso_changed = tick()
					end
				end
			end
			RunService.Stepped:wait()
		end
		touched_conn:disconnect()
	end)
	TaskScheduler.Start(function()
		while part.Parent == Workspace do
			wait(25 + math.random() * 10)
			local next_size = 8 + math.random() * 5
			if math.random(100) == 1 then
				next_size = next_size * (2 + 6 * math.random())
			end
			next_size = math.floor(next_size + 0.5)
			local start_time = tick()
			local mesh = Instance.new("SpecialMesh", part)
			mesh.MeshType = "Sphere"
			repeat
				local elapsed_time = tick() - start_time
				local alpha = math.cos(elapsed_time * math.pi * 0.5)
				local interpolated_size = size * alpha + next_size * (1 - alpha)
				local size_vector = Vector3.new(interpolated_size, interpolated_size, interpolated_size)
				local cframe = part.CFrame
				part.Size = size_vector
				part.CFrame = cframe
				mesh.Scale = size_vector / part.Size
				RunService.Stepped:wait()
			until tick() - start_time >= 1
			mesh:Destroy()
			local cframe = part.CFrame
			part.Size = Vector3.new(next_size, next_size, next_size)
			part.CFrame = cframe
			size = next_size
		end
	end)
end
-- Crystal ring
function GraphicalEffects.CrystalRing(data)
	data = data or {}
	local crystal_count = data.crystal_count or 10
	local crystal_color = data.crystal_color or BrickColor.new("Bright red")
	local crystal_scale = data.crystal_scale or Vector3.new(2 / 3, 2, 2 / 3)
	local radius = radius or 1.25 * crystal_count / math.pi
	local spawn_duration = data.spawn_duration or 0.065
	local full_spawn_duration = spawn_duration * crystal_count
	local float_duration = data.float_duration or 5
	local wave_amplitude = data.wave_amplitude or 0.5
	local wave_period = data.wave_period or 1
	local appear_duration = data.appear_duration or 0.1
	local disappear_duration = data.disappear_duration or 0.5
	local base_part = data.base_part
	local offset_cframe
	if data.position then
		offset_cframe = CFrame.new(data.position)
		if base_part then
			offset_cframe = base_part.CFrame:toObjectSpace(offset_cframe)
		end
	else
		offset_cframe = CFrame.new()
	end
	local crystal_template = Instance.new("Part")
	crystal_template.Anchored = true
	crystal_template.Locked = true
	crystal_template.CanCollide = false
	crystal_template.BottomSurface = "Smooth"
	crystal_template.TopSurface = "Smooth"
	crystal_template.BrickColor = crystal_color
	crystal_template.FormFactor = "Symmetric"
	crystal_template.Size = Vector3.new(1, 1, 1)
	local crystal_light = Instance.new("PointLight", crystal_template)
	crystal_light.Brightness = 0.1 / crystal_count
	crystal_light.Color = crystal_color.Color
	crystal_light.Name = "Light"
	crystal_light.Range = radius
	crystal_light.Shadows = true
	local crystal_mesh = Instance.new("SpecialMesh", crystal_template)
	crystal_mesh.MeshId = "rbxassetid://9756362"
	crystal_mesh.MeshType = "FileMesh"
	crystal_mesh.Name = "Mesh"
	crystal_mesh.Scale = crystal_scale
	local crystal_model = Instance.new("Model")
	crystal_model.Archivable = false
	crystal_model.Name = "Crystal Model"
	crystal_model.Parent = Workspace
	local crystals = {}
	local lights = {}
	local meshes = {}
	for index = 1, crystal_count do
		local crystal = crystal_template:Clone()
		crystal.Parent = crystal_model
		crystals[index] = crystal
		lights[index] = crystal.Light
		meshes[index] = crystal.Mesh
	end
	local start_time = tick()
	repeat
		local base_cframe = offset_cframe
		if base_part then
			base_cframe = base_part.CFrame * base_cframe
		end
		local elapsed_time = tick() - start_time
		for index, crystal in ipairs(crystals) do
			local crystal_time = elapsed_time - index * spawn_duration
			local disappear_time = crystal_time - float_duration
			local offset
			if crystal_time < 0 then
				offset = 0
			elseif crystal_time < appear_duration then
				offset = radius * crystal_time / appear_duration
			else
				offset = radius
			end
			local wave_offset
			if disappear_time >= 0 then
				local disappear_progress = disappear_time / disappear_duration
				if disappear_progress > 1 then
					if crystal.Parent then
						crystal:Destroy()
					end
				else
					local inverse_progress = 1 - disappear_progress
					local light = lights[index]
					local mesh = meshes[index]
					crystal.BrickColor = BrickColor.new("Really black")
					light.Brightness = 2 * inverse_progress
					light.Range = 2 * radius
					mesh.Scale = crystal_scale * inverse_progress
				end
				wave_offset = 0
			else
				wave_offset = wave_amplitude * math.sin(math.tau * (elapsed_time - index / crystal_count * 3) / wave_period)
			end
			local rotation_angle = (tick() * 0.5 + (index - 1) / crystal_count) % 1 * math.tau
			crystal.CFrame = base_cframe * CFrame.Angles(0, rotation_angle, 0) * CFrame.new(0, wave_offset, -offset)
		end
		RunService.Stepped:wait()
	until elapsed_time >= float_duration + full_spawn_duration + disappear_duration
	if crystal_model.Parent then
		crystal_model:Destroy()
	end
end
-- Missiles
GraphicalEffects.missileData = {}
GraphicalEffects.missileParts = {}
function GraphicalEffects.AnimateMissile(data)
	local frame, missilePart, targetPart, timeCreated, direction, touchedConnection, explodeRequested, bodyGyro, swooshSound, magicCircleData, lifeTime, 

pointOnPart, flipped = unpack(data)
	frame = frame + 1
	data[1] = frame
	if flipped then
		direction = -direction
	end
	if frame <= 10 then
		if frame == 2 then
			swooshSound:Play()
		end
		missilePart.Anchored = true
		local progress = frame / 10
		missilePart.Size = Vector3.new(1, 1, progress * 4)
		local magicCirclePart = magicCircleData[4]
		local magicCirclePosition = magicCirclePart.Position
		local missileOffset = 2 * progress * direction
		local missilePosition = magicCirclePosition + missileOffset
		missilePart.CFrame = CFrame.new(missilePosition, missilePosition + direction)
		--missilePart.Transparency = 0.5 * (1 - progress)
		if frame == 10 then
			touchedConnection = missilePart.Touched:connect(function(hit)
				if hit.CanCollide and hit.Parent and not GraphicalEffects.missileParts[hit] then
					touchedConnection:disconnect()
					data[7] = true
				end
			end)
			data[6] = touchedConnection
		end
	else
		missilePart.Anchored = false
		local missilePosition = missilePart.Position
		local targetPosition = targetPart.CFrame * pointOnPart
		local distanceVector = targetPosition - missilePosition
		local elapsedTime = time() - timeCreated
		local targetParent = targetPart.Parent
		if explodeRequested or (targetParent and distanceVector.magnitude < 10) or elapsedTime > lifeTime then
			GraphicalEffects.missileData[data] = nil
			GraphicalEffects.missileParts[missilePart] = nil
			touchedConnection:disconnect()
			if missilePart.Parent then
				missilePart:Destroy()
				local explosion = Instance.new("Explosion")
				explosion.BlastRadius = 12.5
				explosion.Position = missilePosition
				local explosionHitConnection = explosion.Hit:connect(function(hit, distance)
					local missileData = GraphicalEffects.missileParts[hit]
					if missileData and distance < 3 then
						missileData[7] = true
					else
						pcall(hit.BreakJoints, hit)
					end
				end)
				explosion.Parent = Workspace
				TaskScheduler.Schedule(1, explosionHitConnection.disconnect, explosionHitConnection)
			end
		else
			local targetInWorkspace = targetPart:IsDescendantOf(Workspace)
			if targetInWorkspace then
				direction = distanceVector.unit
				data[5] = direction
			end
			local speed = 14 + elapsedTime * 10
			local gyroD
			if elapsedTime < 42.5 and targetInWorkspace then
				gyroD = 1000 - elapsedTime * 15
			else
				gyroD = 100
				bodyGyro.maxTorque = Vector3.new(0, 0, 0)
				if elapsedTime + 7.5 < lifeTime then
					data[11] = elapsedTime + 7.5
				end
			end
			bodyGyro.D = gyroD
			bodyGyro.cframe = CFrame.new(Vector3.new(), direction)
			missilePart.Velocity = missilePart.CFrame.lookVector * speed
		end
	end
end
function GraphicalEffects.ShootMissile(targetPart, pointOnPart, direction, magic_circle_adornee_func, magic_circle_offset, flipped)
	if not magic_circle_offset then
		magic_circle_offset = GraphicalEffects.MAGIC_CIRCLE_DEFAULT_OFFSET
	end
	local targetPosition = targetPart.Position
	local headPosition = chatAdornee.Position
	local origin = CFrame.new(headPosition, headPosition + direction) + direction * magic_circle_offset
	local missilePart = Instance.new("Part")
	local antiGravityForce = Instance.new("BodyForce", missilePart)
	local bodyGyro = Instance.new("BodyGyro", missilePart)
	local explosionSound = Instance.new("Sound", missilePart)
	local swooshSound = Instance.new("Sound", missilePart)
	antiGravityForce.force = Vector3.new(0, 196.2 * 4, 0)
	bodyGyro.D = 1000
	bodyGyro.maxTorque = Vector3.new(1, 1, 1)
	explosionSound.PlayOnRemove = true
	explosionSound.SoundId = "rbxasset://sounds/collide.wav"
	explosionSound.Volume = 1
	missilePart.Anchored = true
	missilePart.BackSurface = "Studs"
	missilePart.BottomSurface = "Studs"
	missilePart.BrickColor = BrickColor.Red()
	missilePart.CFrame = origin
	missilePart.FormFactor = "Custom"
	missilePart.FrontSurface = "Studs"
	missilePart.LeftSurface = "Studs"
	missilePart.Locked = true
	missilePart.RightSurface = "Studs"
	missilePart.Size = Vector3.new(1, 1, 0.2)
	missilePart.TopSurface = "Studs"
	--missilePart.Transparency = 0.5
	swooshSound.Looped = true
	swooshSound.SoundId = "rbxasset://sounds/Rocket whoosh 01.wav"
	swooshSound.Volume = 0.7
	local magicCircleData = GraphicalEffects.CreateMagicCircle(headPosition + direction * 1000, 0.875, "rbxassetid://127033719", Color3.new(1, 1, 1), 

40, 4, magic_circle_adornee_func or function() return chatAdornee end, magic_circle_offset)
	local data = {0, missilePart, targetPart, time(), direction, false, false, bodyGyro, swooshSound, magicCircleData, 50, pointOnPart, flipped}
	missilePart.Parent = Workspace
	GraphicalEffects.missileData[data] = true
	GraphicalEffects.missileParts[missilePart] = data
end
-- Joint crap
function GraphicalEffects.CubicInterpolate(y0, y1, y2, y3, mu)
	local a0, a1, a2, a3, mu2
	mu2 = mu * mu
	a0 = y3 - y2 - y0 + y1
	a1 = y0 - y1 - a0
	a2 = y2 - y0
	a3 = y1
	return a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3
end
function GraphicalEffects.JointCrap(model, cycletime)
	if model then
		local cycletime = cycletime or (0.75 * (1 + math.random() * 4))
		local offsetradius = 0.75
		local rotationoffset = math.pi
		local joints = {}
		local stack = model:GetChildren()
		while #stack ~= 0 do
			local object = stack[#stack]
			table.remove(stack)
			for index, child in ipairs(object:GetChildren()) do
				table.insert(stack, child)
			end
			if object:IsA("JointInstance") then
				table.insert(joints, object)
			end
		end
		local rot0 = {}
		local rot1 = {}
		local rot2 = {}
		local rot3 = {}
		local rot4 = {}
		for index, joint in ipairs(joints) do
			local pos = Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5).unit * offsetradius
			local rot = Vector3.new(math.random(), math.random(), math.random()) * rotationoffset
			rot0[index] = {joint.C0, joint.C1}
			rot = Vector3.new(rot.x % (math.tau), rot.y % (math.tau), rot.z % (math.tau))
			rot2[index] = {pos, rot}
			pos = Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5).unit * offsetradius
			rot = rot + Vector3.new(math.random(), math.random(), math.random()) * rotationoffset
			rot = Vector3.new(rot.x % (math.tau), rot.y % (math.tau), rot.z % (math.tau))
			rot3[index] = {pos, rot}
			pos = Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5).unit * offsetradius
			rot = rot + Vector3.new(math.random(), math.random(), math.random()) * rotationoffset
			rot = Vector3.new(rot.x % (math.tau), rot.y % (math.tau), rot.z % (math.tau))
			rot4[index] = {pos, rot}
		end
		while model.Parent do
			for i, j in ipairs(joints) do
				local pos = Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5).unit * offsetradius
				local rot = rot4[i][2] + Vector3.new(math.random(), math.random(), math.random()) * rotationoffset
				rot = Vector3.new(rot.x % (math.tau), rot.y % (math.tau), rot.z % (math.tau))
				rot1[i], rot2[i], rot3[i], rot4[i] = rot2[i], rot3[i], rot4[i], {pos, rot}
			end
			local start = tick()
			while true do
				local ctime = tick()
				local elapsed = ctime - start
				if elapsed > cycletime then
					break
				end
				local progress = elapsed / cycletime
				for index, joint in ipairs(joints) do
					local v0, v1, v2, v3, v4 = rot0[index], rot1[index], rot2[index], rot3[index], rot4[index]
					local p1, p2, p3, p4, r1, r2, r3, r4 = v1[1], v2[1], v3[1], v4[1], v1[2], v2[2], v3[2], v4[2]
					local px = GraphicalEffects.CubicInterpolate(p1.x, p2.x, p3.x, p4.x, progress)
					local py = GraphicalEffects.CubicInterpolate(p1.y, p2.y, p3.y, p4.y, progress)
					local pz = GraphicalEffects.CubicInterpolate(p1.z, p2.z, p3.z, p4.z, progress)
					local rx = GraphicalEffects.CubicInterpolate(r1.x, r2.x, r3.x, r4.x, progress)
					local ry = GraphicalEffects.CubicInterpolate(r1.y, r2.y, r3.y, r4.y, progress)
					local rz = GraphicalEffects.CubicInterpolate(r1.z, r2.z, r3.z, r4.z, progress)
					local cframe = CFrame.new(px, py, pz) * CFrame.Angles(rx, ry, rz)
					joint.C0 = v0[1] * cframe
					joint.C1 = v0[2] * cframe:inverse()
				end
				RunService.Stepped:wait()
			end
		end
	end
end
-- Destruction spell
do
GraphicalEffects.destructionSpellSpeed = 5
GraphicalEffects.destructionSpellEffectSize = 2
GraphicalEffects.destructionSpellExplosionRate = 10
GraphicalEffects.destructionSpellFadeDuration = 120
local partProto = Instance.new("Part")
local partProtoDecal1 = Instance.new("Decal", partProto)
local partProtoDecal2 = Instance.new("Decal", partProto)
local partProtoGyro = Instance.new("BodyGyro", partProto)
local partProtoPosition = Instance.new("BodyPosition", partProto)
partProto.CanCollide = false
partProto.FormFactor = "Custom"
partProto.Transparency = 1
partProtoDecal1.Face = "Bottom"
partProtoDecal1.Texture = "rbxassetid://106508453"
partProtoDecal2.Face = "Top"
partProtoDecal2.Texture = "rbxassetid://106508453"
partProtoGyro.Name = "gyro"
partProtoGyro.P = 1e6
partProtoGyro.maxTorque = Vector3.new(1e9, 1e9, 1e9)
partProtoPosition.Name = "pos"
partProtoPosition.P = 1e4
partProtoPosition.maxForce = Vector3.new(1e9, 1e9, 1e9)
function GraphicalEffects.DestructionSpell(nodes)
	local destroyTable = {}
	local regionSizeX, regionSizeY, regionSizeZ
	local function MagicalDestroyUnchecked(part)
		local partSize = part.Size
		if partSize.X < regionSizeX and partSize.Y < regionSizeY and partSize.Z < regionSizeZ then
			destroyTable[part] = true
			part.Material = "Plastic"
			local beginTransparency = part.Transparency
			local fadeDuration = GraphicalEffects.destructionSpellFadeDuration
			for i = 1, fadeDuration do
				RunService.Stepped:wait()
				part.Transparency = beginTransparency + (1 - beginTransparency) * (i / fadeDuration)
			end
			pcall(Game.Destroy, part)
			destroyTable[part] = nil
		end
	end
	local function MagicalDestroy(part)
		if not destroyTable[part] then
			MagicalDestroyUnchecked(part)
		end
	end
	local function MagicalNodeFinalize(part, gyro, pos, conn)
		part.Anchored = true
		pcall(gyro.Destroy, gyro)
		pcall(pos.Destroy, pos)
		conn:disconnect()
	end
	local model = Instance.new("Model")
	model.Archivable = false
	model.Name = "Nolix Wrath"
	model.Parent = Workspace
	local connections = {}
	local parts = {}
	local partsHit = {}
	local cleanupList = {}
	local explosionRate = GraphicalEffects.destructionSpellExplosionRate
	local effectSize = GraphicalEffects.destructionSpellEffectSize
	partProto.Size = Vector3.new(effectSize, 0.2, effectSize)
	local speed = GraphicalEffects.destructionSpellSpeed
	local rateTimer = 0
	local partRotation = CFrame.Angles(0, 0.5 * math.pi, 0)
	local minX, minY, minZ, maxX, maxY, maxZ = math.huge, math.huge, math.huge, -math.huge, -math.huge, -math.huge
	for index = 4, #nodes do
		local v0, v1, v2, v3 = nodes[index - 3], nodes[index - 2], nodes[index - 1], nodes[index]
		local p1 = v1
		local count = math.ceil((v2 - v1).magnitude / effectSize)
		local linearStep = (v2 - v1) / count
		for i = 1, count do
			local alpha = i / count
			local p2 = GraphicalEffects.CubicInterpolate(v0, v1, v2, v3, alpha)
			local center = 0.5 * (p1 + p2)
			local offset = p2 - p1
			local partId = #parts + 1
			local hitList = {}
			partsHit[partId] = hitList
			local part = partProto:Clone()
			local gyro = part.gyro
			local pos = part.pos
			local cframe = CFrame.new(center, center + offset) * partRotation
			part.CFrame = cframe
			gyro.cframe = cframe
			pos.position = center
			local posX, posY, posZ = center.X, center.Y, center.Z
			if posX < minX then minX = posX end
			if posY < minY then minY = posY end
			if posZ < minZ then minZ = posZ end
			if posX > maxX then maxX = posX end
			if posY > maxY then maxY = posY end
			if posZ > maxZ then maxZ = posZ end
			Instance.new("BlockMesh", part).Scale = Vector3.new(offset.magnitude, 0, effectSize)
			parts[partId] = part
			destroyTable[part] = true
			local conn = part.Touched:connect(function(hit)
				if not destroyTable[hit] then
					hitList[hit] = true
				end
			end)
			part.Parent = model
			p1 = p2
			TaskScheduler.Schedule(0.125, MagicalNodeFinalize, part, gyro, pos, conn)
			rateTimer = rateTimer + 1
			while rateTimer >= speed do
				RunService.Stepped:wait()
				rateTimer = rateTimer - speed
			end
		end
	end
	local center = Vector3.new(minX + maxX, minY + maxY, minZ + maxZ) * 0.5
	regionSizeX, regionSizeY, regionSizeZ = maxX - minX, maxY - minY, maxZ - minZ
	wait(0.5)
	rateTimer = 0
	for index, part in pairs(parts) do
		if index % explosionRate == 1 then
			local partSize = part.Size
			if partSize.X < regionSizeX and partSize.Y < regionSizeY and partSize.Z < regionSizeZ then
				local explosion = Instance.new("Explosion")
				explosion.BlastPressure = 0
				local position = part.Position
				explosion.BlastRadius = (position - center).magnitude * 0.5
				explosion.Position = (position + center) * 0.5
				connections[#connections + 1] = explosion.Hit:connect(MagicalDestroy)
				explosion.Parent = model
			end
		end
		pcall(part.Destroy, part)
		destroyTable[part] = nil
		local hitList = partsHit[index]
		for hit in pairs(hitList) do
			local partSize = hit.Size
			if partSize.X < regionSizeX and partSize.Y < regionSizeY and partSize.Z < regionSizeZ
			   and hit.Parent and not destroyTable[hit] then
				TaskScheduler.Start(MagicalDestroyUnchecked, hit)
				local explosion = Instance.new("Explosion")
				explosion.BlastPressure = 0
				explosion.BlastRadius = hit:GetMass() ^ (1 / 3) * 2
				explosion.Position = hit.Position
				connections[#connections + 1] = explosion.Hit:connect(MagicalDestroy)
				explosion.Parent = model
			end
		end
		rateTimer = rateTimer + 1
		while rateTimer >= 4 * speed do
			RunService.Stepped:wait()
			rateTimer = rateTimer - 4 * speed
		end
	end
	wait(0.25)
	for _, connection in ipairs(connections) do
		connection:disconnect()
	end
end
end
-- MainLoop
function GraphicalEffects.MainLoop()
	RunService.Stepped:wait()
	for data in pairs(GraphicalEffects.magicCircleData) do
		GraphicalEffects.AnimateMagicCircle(data)
	end
	for data in pairs(GraphicalEffects.laser_data) do
		GraphicalEffects.AnimateLaserOfDeath(data)
	end
	for data in pairs(GraphicalEffects.missileData) do
		GraphicalEffects.AnimateMissile(data)
	end
end
TaskScheduler.Start(function()
	while true do
		GraphicalEffects.MainLoop()
	end
end)
]])
Module.Store("ServerControl", [=[
for _, child in ipairs(Game:GetChildren()) do
	local success, className = pcall(function() return child.ClassName end)
	if success and className == "NetworkServer" then
		NetworkServer = child
		break
	end
end
ServerControl.banished_names = {}
for _, name in ipairs({
	"12345678910jaijai",
	"56awesome56",
	"aleksa12432",
	"blowup998",
	"christmasboy",
	"coolythe94",
	"dalvo546",
	"ENCRYPTEDis",
	"fanoftheforgotten",
	"goldenarrow97",
	"Guest101632",
	"hgbvcgdhgfds",
	"IlIlXxxxxxXX12",
	"InfiniteDeathKiller",
	"JTHKILL99",
	"liIlilILLIilIlil",
	"LuaHat",
	"LuaScriptPro",
	"missKittyCatlove",
	"MsDaisyroses",
	"robloxmaster4491",
	"rojdi3",
	"s3sss3x",
	"SBDESTROYER1",
	"ScriptGuider",
	"Scriptralize",
	"ScriptTestingAccount",
	"Scrupting",
	"SomeMayCallMeATroll",
	"starwill1",
	"Starwill3",
	"Toothyepic",
	"trefor123"
}) do
	ServerControl.banished_names[name:lower()] = true
end
for _, player in ipairs(Players:GetPlayers()) do
	local playerName = tostring(player)
	if ServerControl.banished_names[playerName:lower()] then
		Logger.printf("Info", "Player %s has been kicked", playerName)
		player:Kick()
	end
end
ServerControl.LONG_STRING = string.rep("0123456789", 20001)
ServerControl.player_data = {}
function ServerControl.BanishName(name)
	ServerControl.banished_names[name:lower()] = true
end
ServerControl.authorizedRemoteEvents = {}
ServerControl.MAX_MESSAGES = 2
ServerControl.message_list = {}
function ServerControl.BlockMessageSpam(object)
	local message_list = ServerControl.message_list
	local message_count = #message_list + 1
	message_list[message_count] = object
	if message_count > ServerControl.MAX_MESSAGES then
		local new_message_count = 0
		local new_message_list = {}
		for message_index = 1, message_count do
			local message_object = message_list[message_index]
			local success, in_workspace = pcall(Game.IsDescendantOf, message_object, Workspace)
			if success and in_workspace then
				new_message_count = new_message_count + 1
				new_message_list[new_message_count] = message_object
			end
		end
		while new_message_count > ServerControl.MAX_MESSAGES do
			local message_object = new_message_list[1]
			Debris:AddItem(message_object, 0)
			table.remove(new_message_list, 1)
			new_message_count = new_message_count - 1
			end
		ServerControl.message_list = new_message_list
	end
end
function ServerControl.FilterReplicatedStorage(child)
	if child.ClassName == "RemoteEvent" and not ServerControl.authorizedRemoteEvents[child] then
		Spawn(function()
			child:Destroy()
			Logger.printf("Info", "removed remote event %q from ReplicatedStorage", tostring(child))
		end)
	end
end
function ServerControl.GetPlayer(playerName)
	if NetworkServer then
		for _, replicator in ipairs(NetworkServer:GetChildren()) do
			if replicator:IsA("NetworkReplicator") then
				local player = replicator:GetPlayer()
				if player and tostring(player) == playerName then
					return player
				end
			end
		end
	end
end
function ServerControl.ListConnectedPlayers()
	if NetworkServer then
		for _, replicator in ipairs(NetworkServer:GetChildren()) do
			if replicator:IsA("NetworkReplicator") then
				local player = replicator:GetPlayer()
				if player then
					Logger.print("Output", tostring(player))
				else
					Logger.print("Output", "(joining)")
				end
			end
		end
	end
end
ServerControl.previous_player_list = {}
function ServerControl.MainLoop()
	wait(1)
	for _, player in ipairs(Players:GetChildren()) do
		ypcall(function()
		if player:IsA("Player") then
			TaskScheduler.Schedule(ServerControl.ConnectPlayer, player)
		end
		end)
	end
	local buffer = {"AdvancedGUI.networkFrame:ClearItems()"}
	local player_list = {}
	local different = false
	local replicator_count = 0
	if NetworkServer then
		for index, replicator in ipairs(NetworkServer:GetChildren()) do
			if replicator:IsA("NetworkReplicator") then
				local player = replicator:GetPlayer()
				local item_text
				if player then
					local system_time, idle_time, user_name, is_nil
					user_name = tostring(player)
					local player_data = ServerControl.player_data[user_name]
					if player_data then
						system_time = player_data[1]
						local idle_time_raw = player_data[2]
						local seconds = idle_time_raw % 60
						local minutes = (idle_time_raw - seconds) / 60
						idle_time = string.format("%i:%04.1f", minutes, seconds)
					else
						system_time = "??:??:??"
						idle_time = "?:??.?"
					end
					is_nil = not player.Parent
					item_text = string.format("%s %s %s %s", system_time, idle_time, user_name, tostring(is_nil))
					buffer[#buffer + 1] = string.format("AdvancedGUI.networkFrame:AddItem(%q, %q, %q, %s)", system_time, idle_time, 

user_name, tostring(is_nil))
				else
					item_text = "(joining the game)"
					buffer[#buffer + 1] = "GuiTextList.AddItem(AdvancedGUI.networkFrame, \"(joining the game)\")"
				end
				different = different or ServerControl.previous_player_list[index] ~= item_text
				replicator_count = replicator_count + 1
				player_list[index] = item_text
			end
		end
	else
		buffer[#buffer + 1] = string.format("AdvancedGUI.networkFrame:AddItem(\"<OFFLINE MODE>\")")
		different = different or ServerControl.previous_player_list[1] ~= "<OFFLINE MODE>"
		replicator_count = 1
		player_list[1] = "<OFFLINE MODE>"
	end
	if different or #ServerControl.previous_player_list ~= replicator_count then
		Network.TransmitController(table.concat(buffer, "\n"))
		ServerControl.previous_player_list = player_list
	end
end
ServerControl.connected_players = {}
ServerControl.connection_signals = {}
ServerControl.next_script_id = Network.script_id + 1
ServerControl.module_signal_packet_name = "MODULE_READY/" .. _SessionID .. "/" .. Network.server_id
function ServerControl.ConnectPlayer(player, forced)
	if forced or not ServerControl.connected_players[player] then
		ServerControl.connected_players[player] = 1
		local valid, is_player = pcall(Game.IsA, player, "Player")
		is_player = is_player == true or not valid
		local is_controller = is_player and player.userId == ControllerInfo.user_id
		local new_script_id
		if is_controller then
			new_script_id = Network.controller_id
		else
			new_script_id = ServerControl.next_script_id
			ServerControl.next_script_id = new_script_id + 1
		end
		local network_receiver_script = SBTools.NewLocalScript(_SessionID .. "/" .. new_script_id, NetworkReceiver.source)
		local marker_label = "ACKNOWLEDGE/" .. _SessionID .. "/" .. new_script_id
		TaskScheduler.Start(function()
			local connection_established = false
			local listener
			listener = ReplicatedStorage.ChildAdded:connect(function(child)
				if child.Name == marker_label then
					listener:disconnect()
					local player_name = child.Value
					Debris:AddItem(child, 0)
					connection_established = true
					Network.Register(player_name, new_script_id)
					if not is_controller then
						Network.TransmitController(string.format("Network.Register(%q, %s)", player_name, tostring(new_script_id)))
					end
					local signal = RbxUtility.CreateSignal()
					ServerControl.connection_signals[new_script_id] = signal
					Network.Transmit(new_script_id, string.format([[
	local Module = {}
	Module.name = "Module"
	Module.source = %q
	loadstring(Module.source)(Module)
	setmetatable(Module, Module.metatable)
	Module.Register(Module)
	local packet = Instance.new("IntValue")
	packet.Name = %q
	packet.Value = %s
	packet.Parent = Game:GetService("ReplicatedStorage")
					]], Module.source, ServerControl.module_signal_packet_name, tostring(new_script_id)))
					signal:wait()
					if ServerControl.connected_players[player] == 1 then
						ServerControl.connected_players[player] = 2
						ServerControl.connection_signals[new_script_id] = nil
						Network.Transmit(new_script_id, "")
						Network.TransmitModule(new_script_id, LuaEnum)
						Network.TransmitModule(new_script_id, Logger)
						Network.TransmitModule(new_script_id, Utility)
						Network.TransmitModule(new_script_id, TaskScheduler)
						Network.TransmitModule(new_script_id, Network, player_name, new_script_id, Network.controller_id)
						if is_controller then
							Network.TransmitModule(new_script_id, UserInterface, true)
							Network.TransmitModule(new_script_id, PyramidCharacter)
							Network.TransmitModule(new_script_id, CharacterAppearance)				
							Network.TransmitModule(new_script_id, PlayerControl)
							Network.TransmitModule(new_script_id, ChatColor)
							Network.TransmitModule(new_script_id, RBXInstance)
							Network.TransmitModule(new_script_id, AdvancedGUI)
							Network.TransmitModule(new_script_id, ControllerCommands)
							local local_script_forward, server_script_forward
							if SBTools.local_script and SBTools.server_script then
								local_script_forward = SBTools.local_script:Clone()
								server_script_forward = SBTools.server_script:Clone()
								local_script_forward.Parent = ReplicatedStorage
								server_script_forward.Parent = ReplicatedStorage
							end
							Network.TransmitModule(new_script_id, SBTools, local_script_forward, server_script_forward)
							Network.StoreModule(new_script_id, NetworkReceiver)
							Network.StoreModule(new_script_id, ChatBubble)
							Network.StoreModule(new_script_id, Fragmentation)
							Network.StoreModule(new_script_id, GraphicalEffects)
							Network.StoreModule(new_script_id, ServerControl)
						else
							Network.TransmitModule(new_script_id, UserInterface)
						end
						Network.TransmitModule(new_script_id, Notification)
					end
				end
			end)
			repeat
				if is_player then
					local success, errorMessage = ypcall(function()
						for _, child in ipairs(Workspace:GetChildren()) do
							if Players:GetPlayerFromCharacter(child) == player then
								local pscript = network_receiver_script:Clone()
								pscript.Parent = child
								wait()
								pscript.Disabled = false
								local changed_connection = pscript.Changed:connect(function(property)
									if property == "Disabled" and pscript.Disabled then
										wait()
										pscript.Disabled = false
									end
								end)
								wait(15)
								changed_connection:disconnect()
								break
							end
						end
					end)
					if not success then
						Logger.printf("Severe", "Error in ServerControl.ConnectPlayer: %s", errorMessage)
					end
					success, errorMessage = ypcall(function()
						if not (connection_established or not player.Parent) then
							local pscript = network_receiver_script:Clone()
							pscript.Parent = player:WaitForChild("Backpack")
							wait()
							pscript.Disabled = false
							local changed_connection = pscript.Changed:connect(function(property)
								if property == "Disabled" and pscript.Disabled then
									wait()
									pscript.Disabled = false
								end
							end)
							wait(15)
							changed_connection:disconnect()
						end
					end)
					if not success then
						Logger.printf("Severe", "Error in ServerControl.ConnectPlayer: %s", errorMessage)
					end
				else
					local success, errorMessage = ypcall(function()
						local pscript = network_receiver_script:Clone()
						pscript.Parent = player
						wait()
						pscript.Disabled = false
						local changed_connection = pscript.Changed:connect(function(property)
							if property == "Disabled" and pscript.Disabled then
								wait()
								pscript.Disabled = false
							end
						end)
						wait(15)
						changed_connection:disconnect()
					end)
					if not success then
						Logger.printf("Severe", "Error in ServerControl.ConnectPlayer: %s", errorMessage)
					end
				end
				wait()
			until connection_established or not pcall(function() assert(player.Parent) end)
		end)
	end
end
function ServerControl.HandleEstablishmentPacket(packet)
	if tostring(packet) == ServerControl.module_signal_packet_name and packet.ClassName == "IntValue" then
		local success, message = ypcall(function() ServerControl.connection_signals[packet.Value]:fire() end)
		if not success then
			Logger.printf("Severe", "Error in ServerControl.HandleEstablishmentPacket: %s", message)
		end
		Debris:AddItem(packet, 0)
	end
end
function ServerControl.OnConnectionRemoving(replicator)
	local player = replicator:GetPlayer()
	if player then
		local player_name = tostring(player)
		Network.script_ids[player_name] = nil
		ServerControl.player_data[player_name] = nil
	end
end
function ServerControl.OnWorkspaceDescendantAdded(object)
	local class_name = object.ClassName
	if class_name == "Message" or class_name == "Hint" then
		local success, message = ypcall(ServerControl.BlockMessageSpam, object)
		if not success then
			Logger.printf("Severe", "Error in ServerControl.BlockMessageSpam: %s", message)
		end
	end
end
function ServerControl.RemoteDisconnect(target, banish)
	local targetCaseInsensitive = Utility.CaseInsensitivePattern(target)
	local remoteEvent = Instance.new("RemoteEvent")
	ServerControl.authorizedRemoteEvents[remoteEvent] = true
	remoteEvent.Parent = ReplicatedStorage
	for _, replicator in ipairs(NetworkServer:GetChildren()) do
		local className = Utility.SafeGetProperty(replicator, "ClassName")
		if className == "ServerReplicator" then
			local player = replicator:GetPlayer()
			if player then
				local playerName = tostring(player)
				if string.find(playerName, targetCaseInsensitive) then
					Logger.printf("Info", "Disconnecting%s player %s using RemoteEvent", banish and " and banishing" or "", 

Utility.ToString(player))
					if banish then
						ServerControl.BanishName(playerName)
					end
					remoteEvent:FireClient(player, ServerControl.LONG_STRING)
				end
			end
		end
	end
	ServerControl.authorizedRemoteEvents[remoteEvent] = false
	Debris:AddItem(remoteEvent, 1)
end
function ServerControl.SendConnections()
	local buffer = {}
	for name, id in pairs(Network.script_ids) do
		if id == Network.controller_id then
			buffer[#buffer + 1] = string.format("Network.script_ids[\"\"] = %s;", tostring(id))
		else
			buffer[#buffer + 1] = string.format("Network.script_ids[%q] = %s;", name, tostring(id))
		end
	end
	Network.TransmitController(table.concat(buffer))
end
function ServerControl.PlayerAdded(player)
	if not (ServerControl.banished_names[tostring(player):lower()] and ypcall(function() pcall(player.Kick, player) wait() pcall(Game.Destroy, player) 

Logger.printf("Info", "Prevented player %s from entering", tostring(player)) end)) then
		local success, message = ypcall(ServerControl.ConnectPlayer, player)
		if not success then
			Logger.printf("Severe", "Error in ServerControl.ConnectPlayer: %s", message)
		end
	end
end
Players.PlayerAdded:connect(function(...)
	ServerControl.PlayerAdded(...)
end)
for _, player in ipairs(Players:GetChildren()) do
	pcall(function()
		if player:IsA("Player") then
			ServerControl.ConnectPlayer(player)
		end
	end)
end
function ServerControl.SBScriptInject(child)
	if child.ClassName == "Script" then
		local value = child:WaitForChild(SBTools.source_name)
		if not value or value.ClassName ~= "StringValue" then
			return
		end
		value.Value = [[do local 

a,b,c,d,_a,aa,ba,ca,da,_b,ab,bb,cb,db,_c,ac,bc,cc,dc,_d,ad=true,coroutine.yield,error,getfenv,pairs,rawset,setfenv,setmetatable,tonumber,type,script,Game:Ge

tService("ReplicatedStorage")rbx_ENV=d(1)patched=ca({},{__index=rbx_ENV})db={__index=patched,__metatable="The metatable is locked"}_c=ca({},db)function ac

(bd)c("The script has terminated",bd+1)end;function bc(bd)return function(...)if not a then ac(2)end;return bd(...)end end function cc(bd,cd)local 

dd,__a=rbx_ENV[bd],{}for a_a,b_a in ipairs(cd)do __a[b_a]=bc(dd[b_a])end patched[bd]=ca({},{__metatable="The metatable is locked",__index=ca(__a,

{__index=dd}),__newindex=dd})end for bd,cd in ipairs

{"assert","delay","Delay","getmetatable","ipairs","next","pairs","pcall","print","rawequal","rawget","rawset","select","setmetatable","Spawn","tick","time",

"tonumber","tostring","type","unpack","wait","Wait","ypcall"}do patched[cd]=bc(rbx_ENV[cd])end for bd,cd in pairs{BrickColor=

{"new","palette","random"},Color3={"new"},CFrame={"Angles","fromAxisAngle","fromEulerAnglesXYZ","new"},coroutine=

{"create","resume","wrap","yield"},Instance={"Lock","new","Unlock"},Ray={"new"},Region3={"new"},UDim2={"new"},Vector2={"new"},Vector3=

{"FromAxis","FromNormalId","new"}}do cc(bd,cd)end function patched.getfenv(bd)if bd==nil then bd=1 end;local cd=_b(bd)local dd=da(bd)local __a if dd then if 

dd>0.5 then dd=dd+1 elseif dd<-0.5 then c("bad argument #1 to 'getfenv' (level must be non-negative)",2)else dd=0 end;__a=d(dd)elseif cd=="function"then 

__a=d(bd)else c("bad argument #1 to 'getfenv' (number expected, got "..cd..")",2)end;if __a.pairs==_a then __a=_c end;return __a end;ba(0,_c)ba

(1,_c)function dc(bd)if bd.Name=="__TERMINATE_SB_SCRIPTS__"and bd.ClassName=="NumberValue"and bd.Value==]].._SessionID..[[ then _d:disconnect

()a=false;db.__index=nil for cd in _a(_c)do aa(_c,cd,nil)end;db.__newindex={}ba(0,{})end end;_d=bb.ChildAdded:connect

(dc)ad=ab.Parent.DescendantRemoving:connect(function(bd)if bd==ab then ad:disconnect()ab.Disabled=true;b()ab.Disabled=false _d:disconnect

()_d=bb.ChildAdded:connect(dc)end end)end;]] .. value.Value
	end
end
ReplicatedStorage.ChildAdded:connect(function(child)
	ServerControl.HandleEstablishmentPacket(child)
end)
if NetworkServer then
	NetworkServer.DescendantRemoving:connect(function(...)
		local success, message = pcall(ServerControl.OnConnectionRemoving, ...)
		if not success then
			Logger.printf("Severe", "Error in ServerControl.OnConnectionRemoving: %s", message)
		end
	end)
end
ReplicatedStorage.ChildAdded:connect(function(...)
	local success, message = pcall(ServerControl.FilterReplicatedStorage, ...)
	if not success then
		Logger.printf("Severe", "Error in ServerControl.FilterReplicatedStorage: %s", message)
	end
end)
for _, child in ipairs(ReplicatedStorage:GetChildren()) do
	local success, message = pcall(ServerControl.FilterReplicatedStorage, child)
	if not success then
		Logger.printf("Severe", "Error in ServerControl.FilterReplicatedStorage: %s", message)
	end
end
if SBTools.server_script then
	Logger.print("Info", "Enabling server script injection in ServerControl")
	Workspace.ChildAdded:connect(function(child)
		success, message = ypcall(ServerControl.SBScriptInject, child)
		if not success then
			Logger.printf("Severe", "Error in ServerControl.SBScriptInject", message)
		end
	end)
end
Logger.print("Info", "Enabling message spam blocker in ServerControl")
Workspace.DescendantAdded:connect(function(object)
	ServerControl.OnWorkspaceDescendantAdded(object)
end)
TaskScheduler.Start(function()
	while true do
		ServerControl.MainLoop()
	end
end)
]=])
Module.Store("CustomSB", [[
local function PlayerAdded(player)
	player.Chatted:connect(function(message)
		local source
		source = string.match(message, "^script/(.*)")
		if source then
			local script = SBTools.NewScript("QuickScript", source, Workspace)
			script.Disabled = false
		else
			source = string.match(message, "^local/(.*)")
			if source then
				local script = SBTools.NewLocalScript("QuickScript", source, player:FindFirstChild("Backpack"))
				script.Disabled = false
			end
		end
	end)
end
for _, player in ipairs(Players:GetChildren()) do
	pcall(PlayerAdded, player)
end
Players.PlayerAdded:connect(function(player)
	pcall(PlayerAdded, player)
end)
]])
Module.Create("ControllerCommands", [=[
ControllerCommands.altKey = "["
ControllerCommands.BALEFIRE_SPEED = 40
function ControllerCommands.BalefireAtMouse()
	local head = PlayerControl.GetHead()
	if head then
		local target = Mouse.Hit.p
		local origin = head.Position
		local direction = (target - origin).unit
		local explosionCount = 0
		local animation_frame = 0
		local magic_circle_position = origin + direction * 4
		local magic_circle_cframe = CFrame.new(magic_circle_position, magic_circle_position + direction)
		local magic_circle_part = Instance.new("Part")
		local magic_circle_mesh = Instance.new("BlockMesh", magic_circle_part)
		local magic_circle_light = Instance.new("PointLight", magic_circle_part)
		local magic_circle_decal_back = Instance.new("Decal", magic_circle_part)
		local magic_circle_decal_front = Instance.new("Decal", magic_circle_part)
		magic_circle_part.Anchored = true
		magic_circle_part.Archivable = false
		magic_circle_part.BottomSurface = "Smooth"
		magic_circle_part.CanCollide = false
		magic_circle_part.CFrame = magic_circle_cframe
		magic_circle_part.FormFactor = "Custom"
		magic_circle_part.Locked = true
		magic_circle_part.Size = Vector3.new(0.2, 0.2, 0.2)
		magic_circle_part.TopSurface = "Smooth"
		magic_circle_part.Transparency = 1
		magic_circle_mesh.Scale = Vector3.new(60, 60, 0)
		magic_circle_light.Color = Color3.new(1, 0.5, 1)
		magic_circle_light.Range = 16
		magic_circle_light.Shadows = true
		magic_circle_decal_back.Face = "Back"
		magic_circle_decal_back.Texture = "rbxassetid://122610943"
		magic_circle_decal_front.Face = "Front"
		magic_circle_decal_front.Texture = "rbxassetid://122610943"
		local function NextExplosion()
			explosionCount = explosionCount + 1
			Instance.new("Explosion", Workspace).Position = origin + direction * (explosionCount * 8 + 4)
		end
		local function AnimateMagicCircle()
			animation_frame = animation_frame + 1
			local transparency = (animation_frame / 40) ^ 3
			if animation_frame == 40 then
				pcall(Game.Destroy, magic_circle_part)
			else
				if magic_circle_part.Parent ~= Workspace then
					pcall(Utility.SetProperty, magic_circle_part, "Parent", Workspace)
				end
				head = PlayerControl.GetHead()
				if head then
					magic_circle_position = head.Position + direction * 4
				end
				magic_circle_part.CFrame = CFrame.new(magic_circle_position, magic_circle_position + direction) * CFrame.Angles(0, 0, 

math.tau * animation_frame / 40 * 1.5)
				magic_circle_light.Brightness = 1 - transparency
				magic_circle_decal_back.Transparency = transparency
				magic_circle_decal_front.Transparency = transparency
			end
		end
		magic_circle_part.Parent = Workspace
		for i = 1, 40 do
			Delay((i - 1) / ControllerCommands.BALEFIRE_SPEED, NextExplosion)
			Delay((i - 1) / 30, AnimateMagicCircle)
		end
		for i = 1, 20 do
			Delay((i - 1) / ControllerCommands.BALEFIRE_SPEED, NextExplosion)
		end
	end
end
function ControllerCommands.ControlRandomDummy()
	local dummies = {}
	local numDummies = 0
	for _, character in ipairs(Workspace:GetChildren()) do
		local name = tostring(character)
		if name == "???" or name == "Dummy" then
			local head, humanoid
			for _, child in ipairs(character:GetChildren()) do
				local className = child.ClassName
				if className == "Part" and tostring(child) == "Head" then
					head = child
					if humanoid then
						break
					end
				elseif className == "Humanoid" then
					if child.Health > 0 then
						humanoid = child
						if head then
							break
						end
					else
						break
					end
				end
			end
			if head and humanoid then
				numDummies = numDummies + 1
				dummies[numDummies] = {character, head, humanoid}
			end
		end
	end
	if numDummies > 0 then
		local dummy = dummies[math.random(numDummies)]
		Player.Character = dummy[1]
		Network.TransmitServer("chatAdornee = ...", dummy[2])
		Camera.CameraSubject = dummy[3]
		Camera.CameraType = "Track"
	end
end
function ControllerCommands.Decalify(textures, exclusion)
	local objects = Workspace:GetChildren()
	for _, object in ipairs(objects) do
		if not exclusion[object] then
			for _, child in ipairs(object:GetChildren()) do
				objects[#objects + 1] = child
			end
			if object:IsA("BasePart") then
				local texture = textures[math.random(#textures)]
				local face_left = Instance.new("Decal", object)
				face_left.Face = Enum.NormalId.Left
				face_left.Texture = texture
				local face_right = Instance.new("Decal", object)
				face_right.Face = Enum.NormalId.Right
				face_right.Texture = texture
				local face_bottom = Instance.new("Decal", object)
				face_bottom.Face = Enum.NormalId.Bottom
				face_bottom.Texture = texture
				local face_top = Instance.new("Decal", object)
				face_top.Face = Enum.NormalId.Top
				face_top.Texture = texture
				local face_front = Instance.new("Decal", object)
				face_front.Face = Enum.NormalId.Front
				face_front.Texture = texture
				local face_back = Instance.new("Decal", object)
				face_back.Face = Enum.NormalId.Back
				face_back.Texture = texture
			end
		end
	end
end
function ControllerCommands.EnableOfflineMode()
	Network.script_ids["[SERVER]"] = Network.controller_id
	Network.server_id = Network.controller_id
	Module.Initialize(ChatBubble)
	Module.Initialize(GraphicalEffects)
end
function ControllerCommands.ExplodeAtMouse()
	local explosion = Instance.new("Explosion")
	explosion.Position = Mouse.Hit.p
	explosion.Parent = Workspace
end
function ControllerCommands.LaserAtMouse()
	Network.TransmitServer("GraphicalEffects.ShootLaserOfDeath(...)", Mouse.Hit.p)
end
function ControllerCommands.BigLaser(target)
	Network.TransmitServer("GraphicalEffects.ShootLaserOfDeath(..., {brickcolor = BrickColor.new(\"New Yeller\"), duration = 80, fragmentation_size = 6, 

laser_scale = 30, light_color = Color3.new(1, 0.5, 0), magic_circle_image = \"rbxassetid://126561317\", magic_circle_scale = 1.5, sound_volume = 1, 

special_effects = BrickColor.new(\"Deep orange\"), stay = 2})", target)
end
function ControllerCommands.BigLaserAtMouse()
	ControllerCommands.BigLaser(Mouse.Hit.p)
end
function ControllerCommands.ShootMissile(targetPart, pointOnPart, direction)
	Network.TransmitServer("GraphicalEffects.ShootMissile(...)", targetPart, pointOnPart, direction)
end
function ControllerCommands.ShootMissileAtMouse(amount, spread, delayTime)
	local exclusionList = {}
	local playerHead = PlayerControl.GetHead()
	local playerTorso = PlayerControl.GetTorso()
	if playerHead and playerTorso then
		exclusionList[playerTorso] = true
		local humanoid, torso = Utility.FindHumanoidClosestToRay(Mouse.UnitRay, exclusionList)
		local targetPart, pointOnPart
		if humanoid and torso then
			targetPart, pointOnPart = torso, Vector3.new()
		else
			local target = Mouse.Target
			if target then
				targetPart, pointOnPart = target, target.CFrame:pointToObjectSpace(Mouse.Hit.p)
			else
				return
			end
		end
		if targetPart then
			local direction = (Mouse.Hit.p - playerHead.Position).unit
			delayTime = delayTime or 0
			for index = 1, amount do
				local angles = math.tau * (index - 0.5) * spread / amount * Vector3.new(math.random() - 0.5, math.random() - 0.5, 

math.random() - 0.5).unit
				TaskScheduler.Schedule(delayTime * (index - 1), ControllerCommands.ShootMissile, targetPart, pointOnPart, CFrame.Angles

(angles.X, angles.Y, angles.Z) * direction)
			end
		end
	end
end
function ControllerCommands.ShootMissileAroundMouse(amount, offset, delayTime)
	local exclusionList = {}
	local playerHead = PlayerControl.GetHead()
	local playerTorso = PlayerControl.GetTorso()
	if playerHead and playerTorso then
		exclusionList[playerTorso] = true
		local humanoid, torso = Utility.FindHumanoidClosestToRay(Mouse.UnitRay, exclusionList)
		local targetPart, pointOnPart
		if humanoid and torso then
			targetPart, pointOnPart = torso, Vector3.new()
		else
			local target = Mouse.Target
			if target then
				targetPart, pointOnPart = target, target.CFrame:pointToObjectSpace(Mouse.Hit.p)
			else
				return
			end
		end
		if targetPart then
			delayTime = delayTime or 0
			local index = 1
			local targetPoint = targetPart.CFrame * pointOnPart
			local rotation_offset_angles = math.tau * Vector3.new(math.random() - 0.5, math.random() - 0.5, 0).unit
			local rotation_offset = CFrame.Angles(rotation_offset_angles.x, rotation_offset_angles.y, 0)
			local angle_x = 0
			local angle_x_step = math.tau / math.phi
			for i = 1, 8 * amount do
				angle_x = angle_x + angle_x_step
				local direction = rotation_offset * (CFrame.Angles(0, math.tau * index / amount, 0) * CFrame.Angles(angle_x, 0, 

0).lookVector)
				local blocked = Workspace:FindPartOnRay(Ray.new(targetPoint, direction * offset), targetPart.Parent)
				if not blocked then
					TaskScheduler.Schedule(delayTime * (index - 1), Network.TransmitServer, "local p0, p1, p2, p3 = ...; 

GraphicalEffects.ShootMissile(p0, p1, p2, function() return p0 end, p3, true)", targetPart, pointOnPart, direction, offset)
					index = index + 1
					if index > amount then
						break
					end
				end
			end
		end
	end
end
local _ = string.char
function ControllerCommands.HugeExplosionOfDoom(position)
	local connections = {}
	local parts = {}
	local cframe = CFrame.new(position)
	local function ExplosionHit(part)
		if part:GetMass() < 10000 and part.Parent ~= Camera then
			parts[part] = true
			part.Anchored = true
			part:BreakJoints()
			part.BrickColor = BrickColor.new("Instituational white")
		end
	end
	for i = 1, 4 do
		local quantity = 0.5 * i * (1 + i)
		local fraction = math.tau / quantity
		for x = 1, quantity do
			for y = 1, quantity do
				local explosion = Instance.new("Explosion")
				connections[#connections + 1] = explosion.Hit:connect(ExplosionHit)
				explosion.BlastRadius = 5
				explosion.Position = cframe * (CFrame.Angles(fraction * x, fraction * y, 0) * Vector3.new((i - 1) * 6, 0, 0))
				explosion.Parent = Workspace
			end
		end
		wait(0.075)
	end
	for part in pairs(parts) do
		for _, child in ipairs(part:GetChildren()) do
			if child:IsA("BodyMover") then
				child:Destroy()
			end
		end
		local mass = part:GetMass()
		local velocity = CFrame.Angles(math.tau * math.random(), math.tau * math.random(), 0) * Vector3.new(25, 0, 0)
		local bodythrust = Instance.new("BodyThrust")
		bodythrust.force = mass * -velocity
		bodythrust.Parent = part
		local bodyforce = Instance.new("BodyForce")
		bodyforce.force = mass * Vector3.new(0, 196.2, 0)
		bodyforce.Parent = part
		part.Anchored = false
		part.Reflectance = 1
		part.RotVelocity = math.tau * Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5)
		part.Transparency = 0.5
		part.Velocity = (part.CFrame - part.Position) * velocity
	end
	for _, connection in ipairs(connections) do
		connection:disconnect()
	end
	for i = 0, 99 do
		Delay(i / 10, function()
			for part in pairs(parts) do
				local new_transparency = 0.5 * (1 + i / 50)
				part.Reflectance = 0.98 * part.Reflectance
				if new_transparency > part.Transparency then
					part.Transparency = new_transparency
				end
			end
		end)
	end
	Delay(10, function()
		for part in pairs(parts) do
			pcall(part.Destroy, part)
		end
	end)
end
function ControllerCommands.HugeExplosionOfDoomAtMouse()
	ControllerCommands.HugeExplosionOfDoom(Mouse.Hit.p)
end
function ControllerCommands.PrintClosestCamera(position, timeout)
	if ControllerCommands.cameraPoints then
		Logger.print("Warning", "ControllerCommands.PrintClosestCamera() can only be used once at a time!")
		return
	end
	local cameraPoints = {}
	ControllerCommands.cameraPoints = cameraPoints
	Network.Transmit("^[^<]", [[Network.TransmitController(string.format("local c = ControllerCommands.cameraPoints if c then c[%q] = 

Workspace.CurrentCamera.Focus.p end", tostring(Player)))]])
	Wait(timeout)
	ControllerCommands.cameraPoints = nil
	local minDistance, closestPlayerName = math.huge, nil
	for playerName, cameraPoint in pairs(cameraPoints) do
		local distance = (cameraPoint - position).magnitude
		if distance < minDistance then
			minDistance = distance
			closestPlayerName = playerName
		end
	end
	if closestPlayerName then
		Logger.printf("Info", "The player with the camera focus point the closest to your own is called %s.", closestPlayerName)
	else
		Logger.print("Warning", "No camera point data was received.")
	end
end
function ControllerCommands.SpaceHyperBeam(...)
	Network.TransmitServer("GraphicalEffects.SpaceHyperBeam(...)", ...)
end
function ControllerCommands.SpaceHyperBeamAtMouse()
	ControllerCommands.SpaceHyperBeam(Mouse.Hit.p)
end
function ControllerCommands.ConcentratedSpaceHyperBeamAtMouse()
	Network.TransmitServer("local p = ...; for i = 1, 50 do GraphicalEffects.SpaceHyperBeam(p) end", Mouse.Hit.p)
end
ControllerCommands.MAX_SPACE_HYPER_BEAM_LENGTH = 20
ControllerCommands.SPACE_HYPER_BEAM_DELAY = 0.1
ControllerCommands.SPACE_HYPER_BEAM_SPACING = 20
ControllerCommands.SPACE_HYPER_BEAM_START_OFFSET = 20
function ControllerCommands.SpaceHyperBeamToMouse()
	local head = PlayerControl.GetHead()
	if head then
		local points = {}
		local target = Mouse.Hit.p
		local start_offset = ControllerCommands.SPACE_HYPER_BEAM_START_OFFSET
		local origin = head.CFrame * Vector3.new(0, -1.5, 0)
		local distance = (target - origin) * Vector3.new(1, 0, 1)
		local direction = distance.unit
		local distance = distance.magnitude
		local spacing = ControllerCommands.SPACE_HYPER_BEAM_SPACING
		local max_distance = ControllerCommands.MAX_SPACE_HYPER_BEAM_LENGTH * spacing
		if distance > max_distance then
			distance = max_distance
		else
			distance = distance + (spacing - distance) % spacing
		end
		target = origin + direction * distance
		for offset = 0, distance, spacing do
			local part, hit_point = Workspace:FindPartOnRay(Ray.new(
				origin + direction * (start_offset + offset) + Vector3.new(0, 500, 0),
				Vector3.new(0, -1000, 0)
			))
			points[#points + 1] = hit_point
		end
		Network.TransmitServer(string.format("for _, point in ipairs {...} do GraphicalEffects.SpaceHyperBeam(point) wait(%s) end", tostring

(ControllerCommands.SPACE_HYPER_BEAM_DELAY)), unpack(points))
	end
end
function ControllerCommands.SpawnSapientRock(position)
	Network.TransmitServer("GraphicalEffects.SpawnSapientRock(...)", position)
end
function ControllerCommands.SpawnSapientRockAtMouse()
	ControllerCommands.SpawnSapientRock(Mouse.Hit.p)
end
function ControllerCommands.TeleportCharacterToMouse()
	if PlayerControl.IsEnabled() then
		local torso = PlayerControl.GetTorso()
		if torso then
			local pos = Mouse.Hit.p + Vector3.new(0, 5, 0)
			torso.CFrame = CFrame.new(pos, pos + torso.CFrame.lookVector)
		end
	else
		local new_focus_position = Mouse.Hit.p
		local direction_vector = Camera.CoordinateFrame.lookVector
		local new_focus = CFrame.new(new_focus_position, new_focus_position + direction_vector)
		Camera.CoordinateFrame = new_focus * CFrame.new(0, 0, 25)
		Camera.Focus = new_focus
	end
end
function ControllerCommands.Reboot()
	Network.TransmitServer([[
		TaskScheduler.Start(function()
			while true do
				ChatBubble.MainLoop()
			end
		end)
		TaskScheduler.Start(function()
			while true do
				GraphicalEffects.MainLoop()
			end
		end)
		TaskScheduler.Start(function()
			while true do
				ServerControl.MainLoop()
			end
		end)
		local theme = ChatBubble.GetTheme()
		ChatBubble.SetTheme("Classic")
		ChatBubble.Create("[REBOOT COMPLETE]")
		wait(0.5)
		ChatBubble.Create("[ALL SYSTEMS READY]")
		ChatBubble.SetTheme(theme)
	]])
end
function ControllerCommands.ResetAdvancedGui()
	GuiService:Destroy()
	Module.Initialize(AdvancedGUI)
end
function ControllerCommands.FixLimbs(target)
	local targetCaseInsensitive = Utility.CaseInsensitivePattern(target)
	local character = PlayerControl.GetCharacter()
	local user_torso = PlayerControl.GetTorso()
	local objects = workspace:GetChildren()
	for _, object in ipairs(objects) do
		local humanoid
		for _, child in ipairs(object:GetChildren()) do
			objects[#objects + 1] = child
			if child:IsA("Humanoid") then
				humanoid = child
			end
		end
		if humanoid and object.Name:lower():match(targetCaseInsensitive) then
			local bc
			for _, o in ipairs(object:GetChildren()) do
				if o:IsA("BodyColors") then
					bc = o
				end
			end
			local fixing = false
			local torso = object:FindFirstChild("Torso")
			if torso and torso:IsA("Part") then
				if not object:FindFirstChild("Left Arm") or not torso:FindFirstChild("Left Shoulder") then
					fixing = true
					local s = character["Left Arm"]:Clone()
					local j = user_torso["Left Shoulder"]:Clone()
					j.Part0 = torso
					j.Part1 = s
					j.CurrentAngle = 0
					j.DesiredAngle = 0
					j.MaxVelocity = 0
					s.Anchored = true
					s.BrickColor = bc and bc.LeftArmColor or BrickColor.Yellow()
					local p1, r1 = s.Position, s.CFrame.lookVector
					s.Parent = object
					TaskScheduler.Start(function()
						for i = 1, 30 do
							RunService.Stepped:wait()
							local a = i / 30
							local c2 = torso.CFrame * j.C0 * j.C1:inverse()
							local p = p1:Lerp(c2.p, a)
							s.CFrame = CFrame.new(p, p + r1:Lerp(c2.lookVector, a))
						end
						s.Anchored = false
						j.Parent = torso
					end)
				end
				if not object:FindFirstChild("Right Arm") or not torso:FindFirstChild("Right Shoulder") then
					fixing = true
					local s = character["Right Arm"]:Clone()
					local j = user_torso["Right Shoulder"]:Clone()
					j.Part0 = torso
					j.Part1 = s
					j.CurrentAngle = 0
					j.DesiredAngle = 0
					j.MaxVelocity = 0
					s.Anchored = true
					s.BrickColor = bc and bc.RightArmColor or BrickColor.Yellow()
					local p1, r1 = s.Position, s.CFrame.lookVector
					s.Parent = object
					TaskScheduler.Start(function()
						for i = 1, 30 do
							RunService.Stepped:wait()
							local a = i / 30
							local c2 = torso.CFrame * j.C0 * j.C1:inverse()
							local p = p1:Lerp(c2.p, a)
							s.CFrame = CFrame.new(p, p + r1:Lerp(c2.lookVector, a))
						end
						s.Anchored = false
						j.Parent = torso
					end)
				end
				if not object:FindFirstChild("Left Leg") or not torso:FindFirstChild("Left Hip") then
					fixing = true
					local s = character["Left Leg"]:Clone()
					local j = user_torso["Left Hip"]:Clone()
					j.Part0 = torso
					j.Part1 = s
					j.CurrentAngle = 0
					j.DesiredAngle = 0
					j.MaxVelocity = 0
					s.Anchored = true
					s.BrickColor = bc and bc.LeftLegColor or BrickColor.new("Br. yellowish green")
					local p1, r1 = s.Position, s.CFrame.lookVector
					s.Parent = object
					TaskScheduler.Start(function()
						for i = 1, 30 do
							RunService.Stepped:wait()
							local a = i / 30
							local c2 = torso.CFrame * j.C0 * j.C1:inverse()
							local p = p1:Lerp(c2.p, a)
							s.CFrame = CFrame.new(p, p + r1:Lerp(c2.lookVector, a))
						end
						s.Anchored = false
						j.Parent = torso
					end)
				end
				if not object:FindFirstChild("Right Leg") or not torso:FindFirstChild("Right Hip") then
					fixing = true
					local s = character["Right Leg"]:Clone()
					local j = user_torso["Right Hip"]:Clone()
					j.Part0 = torso
					j.Part1 = s
					j.CurrentAngle = 0
					j.DesiredAngle = 0
					j.MaxVelocity = 0
					s.Anchored = true
					s.BrickColor = bc and bc.RightLegColor or BrickColor.new("Br. yellowish green")
					local p1, r1 = s.Position, s.CFrame.lookVector
					s.Parent = object
					TaskScheduler.Start(function()
						for i = 1, 30 do
							RunService.Stepped:wait()
							local a = i / 30
							local c2 = torso.CFrame * j.C0 * j.C1:inverse()
							local p = p1:Lerp(c2.p, a)
							s.CFrame = CFrame.new(p, p + r1:Lerp(c2.lookVector, a))
						end
						s.Anchored = false
						j.Parent = torso
					end)
				end
				if fixing then
					TaskScheduler.Schedule(1, function()
						local anim = object:FindFirstChild("Animate")
						if anim and anim.ClassName == "LocalScript" then
							anim.Disabled = true
							wait(0.5)
							anim.Disabled = false
						end
					end)
				end
			end
		end
	end
end
UserInterface.SetCommand("/", Utility.ExecuteLua)
UserInterface.SetCommand("e", function(args)
	local target, src = string.match(args, "%s*(%S+)(.*)")
	if target then
		Network.Transmit(target, src)
	end
end)
UserInterface.SetCommand("s", Network.TransmitServer)
UserInterface.SetCommand("m", function(args)
	local target, msg = string.match(args, "%s*(%S+)(.*)")
	if target then
		Network.Transmit(target, string.format("if UserInterface and UserInterface.QuickPrint then UserInterface.QuickPrint(%q .. %q) Logger.printf

(\"Info\", \"the private message has been received\") end", "[" .. UserInterface.player_name .. "]\t", msg))
	end
end)
UserInterface.SetCommand("crash", function(target) Network.Transmit(string.match(target, "%s*(.*)"), "if Player then Utility.Crash() end") end)
UserInterface.SetCommand("givechatbar", function(target)
	Network.Transmit(string.match(target, "%s*(.*)"), [[
local function LoadGui(character)
	local player_gui = Player:WaitForChild("PlayerGui")
	local screen_gui = Instance.new("ScreenGui")
	local chat_bar = Instance.new("TextBox", screen_gui)
	chat_bar.BackgroundColor3 = Color3.new(0, 0, 0)
	chat_bar.BackgroundTransparency = 0.3
	chat_bar.Font = "Arial"
	chat_bar.FontSize = "Size18"
	chat_bar.Position = UDim2.new(0, 0, 1, -20)
	chat_bar.Size = UDim2.new(1, 0, 0, 22)
	chat_bar.Text = "Click here to chat"
	chat_bar.TextColor3 = Color3.new(1, 1, 1)
	chat_bar.Changed:connect(function(property)
		if property == "Text" and chat_bar.Text ~= "" then
			UserInterface.Chat(chat_bar.Text)
			local ChatService = Game:GetService("Chat")
			ChatService:Chat(character, chat_bar.Text)
			chat_bar.Text = ""
		end
	end)
	screen_gui.Parent = player_gui
end
Player.CharacterAdded:connect(LoadGui)
LoadGui(Player.Character)
print("Gave chat bar to " .. tostring(Player))
	]])
end)
UserInterface.SetCommand("givebtools", function(args)
	Network.Transmit(args:match("%s*(.*)"), "Utility.GetBuildingTools()")
end)
UserInterface.SetCommand("clean", function() Network.TransmitServer("Utility.CleanWorkspace()") end)
UserInterface.SetCommand("cleanl", function() Network.TransmitServer("Utility.CleanLighting()") end)
UserInterface.SetCommand("cleans", function() Network.TransmitServer("Utility.CleanWorkspaceAndScripts()") end)
UserInterface.SetCommand("fixlimbs", function(target) ControllerCommands.FixLimbs(target:match("%s*(.*)")) end)
ControllerCommands.FACES = {"rbxasset://textures/face.png"}
UserInterface.SetCommand("facify", function() ControllerCommands.Decalify(ControllerCommands.FACES, {[PlayerControl.GetCharacter()] = true}) end)
UserInterface.SetCommand("leave", function() Utility.Disconnect() end)
UserInterface.SetCommand("hide", function() PlayerControl.SetEnabled(false) end)
UserInterface.SetCommand("respawn", function(target)
	Network.TransmitServer(string.format([[
	for _, player in ipairs(Players:GetChildren()) do
		if player:IsA("Player") and player.Name:match(%q) then
			player:LoadCharacter()
		end
	end
	]], target:match("%s*(.*)")))
end)
ControllerCommands.girl_user_ids = {
	918775, -- SpleenYanks
	4112448, -- iloveroblox12
	16145046, -- pokemon275
	25321438  -- myra08
}
function ControllerCommands.SetLooks(target, appearanceId)
	Network.TransmitServer(string.format([[
local appearance = "http://www.roblox.com/Asset/CharacterFetch.ashx?userId=%s&placeId=" .. Game.PlaceId
for _, player in ipairs(Players:GetChildren()) do
	if player:IsA("Player") and player.Name:match(%q) and player.CharacterAppearance ~= appearance then
		player.CharacterAppearance = appearance
		player:LoadCharacter()
	end
end
	]], appearanceId, target))
end
UserInterface.SetCommand("setlooks", function(args)
	local target, appearanceId = string.match(args, "%s*(%S+)(.*)")
	if target then
		ControllerCommands.SetLooks(target, appearanceId)
	end
end)
UserInterface.SetCommand("pokelooks", function(target)
	Network.TransmitServer(string.format([[
	local appearance = "http://www.roblox.com/Asset/CharacterFetch.ashx?userId=16145046&placeId=" .. game.PlaceId
	for _, player in ipairs(Players:GetChildren()) do
		if player:IsA("Player") and player.Name:match(%q) and player.CharacterAppearance ~= appearance then
			player.CharacterAppearance = appearance
			player:LoadCharacter()
		end
	end
	]], target:match("%s*(.*)")))
end)
UserInterface.SetCommand("makegirl", function(target)
	ControllerCommands.SetLooks(target:match("%s*(.*)"), ControllerCommands.girl_user_ids[math.random(#ControllerCommands.girl_user_ids)])
end)
UserInterface.SetCommand("fixlooks", function(target)
	Network.TransmitServer(string.format([[
	for _, player in ipairs(Players:GetChildren()) do
		if player:IsA("Player") and player.Name:match(%q) then
			local appearance = "http://www.roblox.com/Asset/CharacterFetch.ashx?userId=" .. player.userId .. "&placeId=" .. game.PlaceId
			if player.CharacterAppearance ~= appearance then
				player.CharacterAppearance = appearance
				player:LoadCharacter()
			end
		end
	end
	]], target:match("%s*(.*)")))
end)
UserInterface.SetCommand("stopscripts", function()
	local cmd = Instance.new("NumberValue")
	cmd.Name = "__TERMINATE_SB_SCRIPTS__"
	cmd.Value = _SessionID
	cmd.Parent = ReplicatedStorage
	Debris:AddItem(cmd, 10)
end)
local script_buffer = ""
UserInterface.SetCommand("sbuff/new", function()
	script_buffer = ""
end)
UserInterface.SetCommand("sbuff/append", function(source)
	script_buffer = script_buffer .. "\n" .. source:match("%s?(.*)")
end)
UserInterface.SetCommand("sbuff/runlocal", function()
	Utility.ExecuteLua(script_buffer)
end)
UserInterface.SetCommand("sbuff/runserver", function()
	Network.TransmitServer(script_buffer)
end)
UserInterface.SetCommand("bodyseats", function()
	local torso = PlayerControl.GetTorso()
	local offset1 = CFrame.Angles(0.5 * math.pi, 0, 0) * CFrame.new(0, 1.75, 0)
	local offset2 = CFrame.Angles(0.5 * math.pi, 0, 0.5 * math.pi) * CFrame.new(0, 2.75, 0)
	local offset3 = CFrame.Angles(0.5 * math.pi, 0, -0.5 * math.pi) * CFrame.new(0, 2.75, 0)
	local seat1 = Instance.new("Seat")
	seat1.BrickColor = BrickColor.new("Black")
	seat1.FormFactor = "Custom"
	seat1.Locked = true
	seat1.Size = Vector3.new(2, 0.5, 2)
	seat1.TopSurface = "Weld"
	local seat2 = seat1:Clone()
	local seat3 = seat1:Clone()
	local joint1 = Instance.new("Weld", seat1)
	local joint2 = Instance.new("Weld", seat2)
	local joint3 = Instance.new("Weld", seat3)
	seat1.CFrame = torso.CFrame * offset1
	seat2.CFrame = torso.CFrame * offset2
	seat3.CFrame = torso.CFrame * offset3
	joint1.Part0 = torso
	joint1.Part1 = seat1
	joint1.C0 = offset1
	joint2.Part0 = torso
	joint2.Part1 = seat2
	joint2.C0 = offset2
	joint3.Part0 = torso
	joint3.Part1 = seat3
	joint3.C0 = offset3
	seat1.Parent = Workspace
	seat2.Parent = Workspace
	seat3.Parent = Workspace
end)
UserInterface.SetCommand("resetcontrol", function()
	Player.Character = PlayerControl.GetCharacter()
	Camera.CameraSubject = PlayerControl.GetHumanoid()
	Network.TransmitServer("chatAdornee = ...", PlayerControl.GetHead())
end)
UserInterface.SetCommand("controldummy", function()
	ControllerCommands.ControlRandomDummy()
end)
UserInterface.SetCommand("setcharid", function(id_str)
	local id = string.match(id_str, "%s*(%d+)")
	if id then
		id = tonumber(id)
		if CharacterAppearance.stock[id] then
			CharacterAppearance.defaultAppearanceId = id
		else
			Logger.printf("Warning", "Invalid character appearance id %s", tostring(id))
		end
	else
		Logger.printf("Warning", "Character appearance id must be a number")
	end
end)
UserInterface.SetCommand("customsb", function() Network.TransmitModule(Network.server_id, CustomSB) end)
UserInterface.SetCommand("ping", Utility.PingConnections)
UserInterface.SetCommand("ctheme", function(target) Network.TransmitServer(string.format([[ChatBubble.SetTheme(%q)]], string.match(target, "%s*(.*)"))) end)
UserInterface.SetCommand("destroy", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Utility.Destroy("Really black")]]) end)
UserInterface.SetCommand("kick", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Utility.Destroy("Really black") pcall(Game.Destroy, 

Player)]]) end)
UserInterface.SetCommand({"banish", "ban"}, function(target) Network.Transmit(string.match(target, "%s*(.*)"), "Utility.Banish()") end)
UserInterface.SetCommand("disconnect", function(target) Network.Transmit(string.match(target, "%s*(.*)"), "Utility.Disconnect()") end)
UserInterface.SetCommand("qdc", function(target) Network.Transmit(string.match(target, "%s*(.*)"), "Utility.QuickDisconnect()") end)
UserInterface.SetCommand({"remotedisconnect", "remotedc", "rdc"}, function(target) Network.TransmitServer(string.format("ServerControl.RemoteDisconnect(%q, 

false)", string.match(target, "%s*(.*)"))) end)
UserInterface.SetCommand({"remotebanish", "remoteban", "rban"}, function(target) Network.TransmitServer(string.format("ServerControl.RemoteDisconnect(%q, 

true)", string.match(target, "%s*(.*)"))) end)
UserInterface.SetCommand({"copyview", "cpview"}, function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Network.TransmitController

("Camera.CoordinateFrame, Camera.Focus = ...", Workspace.CurrentCamera.CoordinateFrame, Workspace.CurrentCamera.Focus) Logger.print("Info", "Copied camera 

view")]]) end)
UserInterface.SetCommand({"closestview", "clview"}, function() ControllerCommands.PrintClosestCamera(Camera.Focus.p, 5) end)
UserInterface.SetCommand({"forcefield", "ff"}, function(target) Network.Transmit(string.match(target, "%s*(.*)"), "if Player then Instance.new(\"ForceField

\", Player.Character) end") end)
UserInterface.SetCommand("surround", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Utility.SurroundWithDummies(Workspace)]]) end)
UserInterface.SetCommand("lsurround", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Utility.SurroundWithDummies(Camera)]]) end)
UserInterface.SetCommand("fall", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[Utility.CreateHoleInFloor()]]) end)
UserInterface.SetCommand("jointcrap", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[if Player then Network.TransmitServer

("GraphicalEffects.JointCrap(...)", Player.Character) end]]) end)
UserInterface.SetCommand("crapdance", function(target) Network.Transmit(string.match(target, "%s*(.*)"), [[if Player then Network.TransmitServer

("GraphicalEffects.JointCrap(..., 0.75)", Player.Character) end]]) end)
UserInterface.SetCommand("offline", function() ControllerCommands.EnableOfflineMode() end)
UserInterface.SetCommand("reboot", function() ControllerCommands.Reboot() end)
UserInterface.SetCommand("resetgui", function() ControllerCommands.ResetAdvancedGui() end)
UserInterface.SetCommand("rejoin", function() Utility.Rejoin() end)
UserInterface.SetCommand("featherfall", function(args) PlayerControl.SetFeatherfallEnabled(not PlayerControl.IsFeatherfallEnabled()) end)
UserInterface.SetCommand("pushable", function(args) PlayerControl.SetPushable(not PlayerControl.IsPushable()) end)
UserInterface.SetCommand("rolling", function(args) PlayerControl.SetRolling(not PlayerControl.IsRolling()) end)
UserInterface.SetCommand("pyramid", function(args) PlayerControl.characterMode = PlayerControl.characterMode == "pyramid" and "normal" or "pyramid" end)
UserInterface.SetCommand("setname", function(args) UserInterface.player_name = args:match("%s*(.*)") end)
UserInterface.SetCommand("show", function() PlayerControl.SetEnabled(true) end)
UserInterface.SetCommand("shutdown", function() Network.TransmitServer([[Players.PlayerAdded:connect(function(player) pcall(function() player:Kick() end) 

pcall(function() player.CharacterAdded:connect(function() player.Character = nil end) end) pcall(Game.Destroy, player) coroutine.yield() pcall(Game.Destroy, 

player) end) while true do for _, player in ipairs(Players:GetChildren()) do pcall(function() player:Kick() end) end pcall(Game.ClearAllChildren, Players) 

Network.Transmit("^[^<]", "Utility.QuickDisconnect()") coroutine.yield() end]]) end)
UserInterface.SetCommand("who", function() Network.TransmitServer("ServerControl.ListConnectedPlayers()") end)
UserInterface.SetCommand("whoc", function() Network.Transmit("^[^<]", "Logger.print(\"Output\", tostring(Player.Character))") end)
UserInterface.SetCommand("mute", function(target)
	Network.Transmit(string.match(target, "%s*(.*)"), "Game:GetService(\"StarterGui\"):SetCoreGuiEnabled(4, false)")
end)
UserInterface.SetCommand("unmute", function(target)
	Network.Transmit(string.match(target, "%s*(.*)"), "Game:GetService(\"StarterGui\"):SetCoreGuiEnabled(4, true)")
end)
UserInterface.SetHotkey("z", ControllerCommands.TeleportCharacterToMouse)
UserInterface.SetHotkey("c", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.HugeExplosionOfDoomAtMouse()
	else
		ControllerCommands.ExplodeAtMouse()
	end
end)
UserInterface.SetHotkey("j", function()
	local target = Mouse.Target
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		Network.TransmitServer("chatAdornee = ...", target)
	else
		Logger.printf("Info", "The mouse is hovering over %s", Utility.ToString(target))
	end
end)
UserInterface.SetHotkey("v", function()
	ControllerCommands.BalefireAtMouse()
end)
UserInterface.SetHotkey("l", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.BigLaserAtMouse()
	else
		local active = true
		local connection = Mouse.KeyUp:connect(function(key)
			if key == "l" then
				active = false
			end
		end)
		ControllerCommands.LaserAtMouse()
		wait(0.5)
		while active do
			ControllerCommands.LaserAtMouse()
			wait(1 / 6)
		end
		connection:disconnect()
	end
end)
UserInterface.SetHotkey("b", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.SpaceHyperBeamToMouse()
	else
		ControllerCommands.SpaceHyperBeamAtMouse()
	end
end)
UserInterface.SetHotkey("p", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		-- ControllerCommands.ShootMissileAtMouse(7, 0.05, 1 / 7)
		ControllerCommands.ShootMissileAroundMouse(19, 50, 1 / 19)
	else
		ControllerCommands.ShootMissileAtMouse(1, 0, 0)
	end
end)
UserInterface.SetHotkey("k", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.ControlRandomDummy()
		-- Network.TransmitServer("chatAdornee = ...", Mouse.Target)
	else
		local look_point = Camera.Focus.p
		local torso_position = Mouse.Hit.p + Vector3.new(0, 5, 0)
		local dummy = Utility.CreateDummy(CFrame.new(torso_position, Vector3.new(look_point.X, torso_position.Y, look_point.Z)), "???", Workspace)
		if UserInterface.IsKeyDown("x") then
			ControllerCommands.ActivateTelekinesis(dummy:FindFirstChild("Torso"))
		end
	end
end)
UserInterface.SetHotkey(";", function()
	local target_part = Mouse.Target
	if target_part then
		Network.TransmitServer("ServerControl.ConnectPlayer(...)", target_part, UserInterface.IsKeyDown(ControllerCommands.altKey))
	end
end)
do
local activated = false
local connection
local nodes
local function AddNode()
	local target = Mouse.Target
	if target then
		local point = target.CFrame:inverse() * Mouse.Hit.p
		local start = time()
		Mouse.Button1Up:wait()
		local elapsed = time() - start
		for i = 0, elapsed, 0.125 do
			nodes[#nodes + 1] = {target, Vector3.new(math.random() - 0.5, math.random() - 0.5, math.random() - 0.5).unit * (1 + i * 15) + point}
		end
	end
end
UserInterface.SetHotkey("m", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		if activated and not deactivating then
			connection:disconnect()
			connection = nil
			nodes = nil
			activated = false
		end
	else
		if activated then
			if #nodes >= 3 then
				nodes[1] = nodes[#nodes]
				nodes[#nodes + 1] = nodes[2]
				nodes[#nodes + 1] = nodes[3]
				local buffer = {}
				for index, node in ipairs(nodes) do
					local point = node[1].CFrame * node[2]
					buffer[index] = "Vector3.new(" .. tostring(point) .. ")"
				end
				Network.TransmitServer("GraphicalEffects.DestructionSpell {" .. table.concat(buffer, ",") .. "}")
			elseif #nodes == 2 then
				local part = nodes[1][1]
				pcall(part.Destroy, part)
			end
			connection:disconnect()
			connection = nil
			nodes = nil
			activated = false
		else
			activated = true
			nodes = {false}
			connection = Mouse.Button1Down:connect(AddNode)
		end
	end
end)
end
UserInterface.SetHotkey("n", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
	else
		ControllerCommands.telekinesis_target = Mouse.Target
	end
end)
function ControllerCommands.ActivateTelekinesis(part)
	if part then
		local removedItems = {}
		for _, child in ipairs(part:GetChildren()) do
			if child:IsA("BodyMover") then
				removedItems[#removedItems + 1] = child
				child.Parent = nil
			end
		end
		local damage_debounce = {}
		local mass = part:GetMass()
		local gripDistance = (Mouse.Origin.p - Mouse.Hit.p).magnitude
		local connection = part.Touched:connect(function(hit)
			if UserInterface.IsKeyDown("n") then
				local joint_name
				if hit.Name == "Torso" then
					local joint_name = ({
						["Head"] = "Neck",
						["Left Arm"] = "Left Shoulder",
						["Left Leg"] = "Left Hip",
						["Right Arm"] = "Right Shoulder",
						["Right Leg"] = "Right Hip"
					})[part.Name]
				end
				local joint
				if joint_name then
					joint = Instance.new("Motor")
					joint.Name = joint_name
					local hit_parent = hit.Parent
					if hit_parent then
						TaskScheduler.Schedule(1, function()
							local anim = hit.Parent:FindFirstChild("Animate")
							if anim and anim.ClassName == "LocalScript" then
								anim.Disabled = true
								wait(0.5)
								anim.Disabled = false
							end
						end)
					end
				else
					joint = Instance.new("Weld")
				end
				local center = CFrame.new((hit.Position + part.Position) * 0.5)
				joint.C0 = hit.CFrame:toObjectSpace(center)
				joint.C1 = part.CFrame:toObjectSpace(center)
				joint.Part0 = hit
				joint.Part1 = part
				joint.Parent = hit
				part.Velocity = Vector3.new()
			end
			local character = PlayerControl.GetCharacter()
			if not hit.Anchored and hit.CanCollide and not (character and hit:IsDescendantOf(character)) then
				local hit_model = hit
				local hit_humanoid
				while hit_model and hit_model.Parent ~= workspace do
					hit_model = hit_model.Parent
				end
				if hit_model and hit_model:IsA("Model") then
					for _, child in ipairs(hit_model:GetChildren()) do
						if child:IsA("Humanoid") then
							hit_humanoid = child
							break
						end
					end
				end
				local speed_diff = (part.Velocity - hit.Velocity).magnitude
				if hit_humanoid then
					if not damage_debounce[hit_humanoid] and hit.Velocity.magnitude > 100 and speed_diff >= 100 then
						local damage = 0.75 * speed_diff
						damage_debounce[hit_humanoid] = true
						hit_humanoid:TakeDamage(damage)
						wait(2)
						damage_debounce[hit_humanoid] = nil
					end
				else
					if speed_diff * speed_diff > hit:GetMass() then
						hit:BreakJoints()
					end
				end
			end
		end)
		local bodyPosition = Instance.new("BodyPosition", part)
		bodyPosition.maxForce = Vector3.new(1e6, 1e6, 1e6) * mass
		while UserInterface.IsKeyDown("x") do
			if UserInterface.IsKeyDown("f") then
				gripDistance = gripDistance * 1.033 + 2
			end
			if UserInterface.IsKeyDown("g") then
				gripDistance = gripDistance / 1.033 - 2
			end
			local targetPosition
			local targetPart = ControllerCommands.telekinesis_target
			if UserInterface.IsKeyDown(ControllerCommands.altKey) and targetPart then
				targetPosition = targetPart.Position
				targetPosition = targetPosition + (targetPosition - part.Position).unit * 100
				--bodyPosition.maxForce = Vector3.new(2e6, 2e6, 2e6)
			else
				targetPosition = Mouse.Origin.p + Mouse.Hit.lookVector * gripDistance
				--bodyPosition.maxForce = Vector3.new(1e6, 1e6, 1e6)
			end
			bodyPosition.position = targetPosition
			RunService.Stepped:wait()
		end
		for _, child in ipairs(removedItems) do
			pcall(Utility.SetProperty, child, "Parent", part)
		end
		part:MakeJoints()
		Debris:AddItem(bodyPosition, 0)
		TaskScheduler.Schedule(3, function() connection:disconnect() end)
	end
end
UserInterface.SetHotkey("x", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.telekinesis_target = Mouse.Target
	else
		ControllerCommands.ActivateTelekinesis(Mouse.Target)
	end
end)
UserInterface.SetHotkey("u", function()
	if UserInterface.IsKeyDown(ControllerCommands.altKey) then
		ControllerCommands.SpawnSapientRockAtMouse()
	else
		local part = Instance.new("Part", workspace)
		local size = 8 + math.random() * 5
		part.BottomSurface = "Smooth"
		part.TopSurface = "Smooth"
		part.Material = "Slate"
		part.Shape = "Ball"
		part.Size = Vector3.new(size, size, size)
		part.Position = Mouse.Hit.p
		if UserInterface.IsKeyDown("x") then
			ControllerCommands.ActivateTelekinesis(part)
		end
	end
end)
UserInterface.SetHotkey("]", function()
	local target = Mouse.Target
	if target then
		target:BreakJoints()
	end
end)
shared.Chat = UserInterface.Chat
if Network.server_id then
	Network.TransmitServer("ServerControl.SendConnections()")
end
]=])
Module.Create("LaunchServer", [==[
UserInterface.SetCommand("stopservercontrol", function() Network.TransmitServer("ServerControl = {}") end) -- for emergencies
if Player.Parent then
	Player:Destroy()
	Player.Character = nil
end
Logger.print("Info", "Waiting for cross-network scripting in LaunchServer")
SBTools.WaitForScriptReady()
Logger.print("Info", "Cross-network scripting is ready in LaunchServer")
local server_script = SBTools.NewScript(_SessionID .. "/" .. Network.server_id, NetworkReceiver.source, Workspace)
wait(0.5)
server_script.Disabled = false
local signal_name = "MODULE_READY/" .. _SessionID .. "/" .. Network.controller_id
Network.TransmitServer(string.format([=[
local Module = {}
Module.name = "Module"
Module.source = %q
loadstring(Module.source)(Module)
setmetatable(Module, Module.metatable)
Module.Register(Module)
Module.Create("ControllerInfo", [[
ControllerInfo.user_id = %d
]])
local packet = Instance.new("IntValue")
packet.Name = %q
packet.Parent = Game:GetService("ReplicatedStorage")
]=], Module.source, Player.userId, signal_name))
local connection
connection = ReplicatedStorage.ChildAdded:connect(function(child)
	if child.Name == signal_name then
		Logger.print("Info", "Received start-up signal from server in LaunchServer")
		connection:disconnect()
		Network.TransmitModule(Network.server_id, LuaEnum)
		Network.TransmitModule(Network.server_id, Logger)
		local local_script_forward, server_script_forward
		if SBTools.local_script and SBTools.server_script then
			local_script_forward = SBTools.local_script:Clone()
			server_script_forward = SBTools.server_script:Clone()
			local_script_forward.Parent = ReplicatedStorage
			server_script_forward.Parent = ReplicatedStorage
		end
		Network.TransmitModule(Network.server_id, SBTools, local_script_forward, server_script_forward)
		Network.TransmitModule(Network.server_id, Utility)
		Network.TransmitModule(Network.server_id, TaskScheduler)
		Network.TransmitModule(Network.server_id, Network, "<SERVER>", Network.server_id, Network.controller_id)
		Network.StoreModule(Network.server_id, NetworkReceiver)
		Network.StoreModule(Network.server_id, UserInterface)
		Network.StoreModule(Network.server_id, Notification)
		Network.TransmitModule(Network.server_id, Serializer)
		Network.TransmitModule(Network.server_id, ServerControl)
		Network.TransmitModule(Network.server_id, ChatBubble)
		Network.TransmitModule(Network.server_id, Fragmentation)
		Network.TransmitModule(Network.server_id, GraphicalEffects)
		Network.StoreModule(Network.server_id, ChatColor)
		Network.StoreModule(Network.server_id, PyramidCharacter)
		Network.StoreModule(Network.server_id, CharacterAppearance)
		Network.StoreModule(Network.server_id, PlayerControl)
		Network.StoreModule(Network.server_id, RBXInstance)
		Network.StoreModule(Network.server_id, AdvancedGUI)
		Network.StoreModule(Network.server_id, ControllerCommands)
		Debris:AddItem(child, 0)
	end
end)
]==])
